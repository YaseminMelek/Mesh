{
  "version": 3,
  "sources": ["../../p5.brush/src/index.js", "../../esm-seedrandom/lib/_common.mjs", "../../esm-seedrandom/lib/alea.mjs", "../../esm-seedrandom/lib/xor128.mjs", "../../esm-seedrandom/lib/xorwow.mjs", "../../esm-seedrandom/lib/xorshift7.mjs", "../../esm-seedrandom/lib/xor4096.mjs", "../../esm-seedrandom/lib/tychei.mjs", "../../esm-seedrandom/lib/arc4.mjs"],
  "sourcesContent": ["/**\n * @fileoverview p5.brush - A comprehensive toolset for brush management in p5.js.\n * @version 1.1.4\n * @license MIT\n * @author Alejandro Campos Uribe\n *\n * @description\n * p5.brush is a p5.js library dedicated to the creation and management of custom brushes.\n * It extends the drawing capabilities of p5.js by allowing users to simulate a wide range\n * of brush strokes, vector fields, hatching patterns, and fill textures. These features\n * are essential for emulating the nuanced effects found in traditional sketching and painting.\n * Whether for digital art applications or procedural generation of graphics, p5.brush provides\n * a robust framework for artists and developers to create rich, dynamic, and textured visuals.\n *\n * @example\n * // Basic usage:\n * brush.pick('marker'); // Select brush type\n * brush.stroke(255, 0, 0); // Set brush color\n * brush.strokeWeight(10); // Set brush size\n * brush.line(25, 25, 75, 75); // Draw a line\n *\n * // Add a new brush type:\n * brush.add('customBrush', { /* parameters for the brush *\\/ });\n * brush.pick('customBrush');\n *\n * // Use the custom brush for a vector-field line:\n * brush.field('field_name') // Pick a flowfield\n * brush.flowLine(50, 50, 100, PI / 4); // Draw a line within the vector-field\n *\n * // Fill textures:\n * brush.noStroke();\n * brush.fill('#FF0000', 90); // Set fill color to red and opacity to 90\n * brush.bleed(0.3); // Set bleed effect for a watercolor-like appearance\n * brush.rect(100, 100, 50, 50); // Fill a rectangle with the bleed effect\n *\n * @license\n * MIT License\n *\n * Copyright (c) 2023-2024 Alejandro Campos Uribe\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n// =============================================================================\n// Section: Configure and Initiate\n// =============================================================================\n/**\n * This section contains functions for setting up the drawing system. It allows\n * for configuration with custom options, initialization of the system, preloading\n * necessary assets, and a check to ensure the system is ready before any drawing\n * operation is performed.\n */\n\n/**\n * Reference to the renderer or canvas object.\n * @type {Object}\n */\nlet _r;\n\n/**\n * Flag to indicate if the system is ready for rendering.\n * @type {boolean}\n */\nlet _isReady = false;\nlet _isLoaded = false;\n\n/**\n * Flag to indicate if p5 is instanced or global mode.\n * @type {boolean}\n */\nlet _isInstanced = false;\nlet _inst = false;\n\n/**\n * Initializes the drawing system and sets up the environment.\n * @param {string|boolean} [canvasID=false] - Optional ID of the canvas element to use.\n *                                            If false, it uses the current window as the rendering context.\n */\nexport function load(canvasID = false) {\n  let inst = _isInstanced && canvasID ? _inst : false;\n  if (_isReady) remove(false);\n  // Set the renderer to the specified canvas or to the window if no ID is given\n  if (!canvasID && _isInstanced) canvasID = _inst;\n  _r = !canvasID ? window.self : canvasID;\n\n  // Load color blending\n  Mix.load(inst);\n  _isLoaded = true;\n}\n\n/**\n * Removes brush buffers\n */\nexport function remove(a = true) {\n  if (_isReady) {\n    Mix.masks[0].remove();\n    Mix.masks[0] = null;\n    Mix.masks[1].remove();\n    Mix.masks[1] = null;\n    Mix.masks[2].remove();\n    Mix.masks[2] = null;\n    if (a) brush.load();\n  }\n}\n\n/**\n * Preloads necessary assets or configurations.\n * This function should be called before setup to ensure all assets are loaded.\n */\nexport function preload() {\n  // Load custom image tips\n  T.load();\n}\n\n/**\n * Ensures that the drawing system is ready before any drawing operation.\n * Loads the system if it hasn't been loaded already.\n */\nfunction _ensureReady() {\n  if (!_isReady) {\n    if (!_isLoaded) load();\n    FF.create(); // Load flowfield system\n    scaleBrushes(_r.width / 250); // Adjust standard brushes to match canvas\n    _isReady = true;\n  }\n}\n\n// =============================================================================\n// Section: Randomness and other auxiliary functions\n// =============================================================================\n/**\n * This section includes utility functions for randomness, mapping values,\n * constraining numbers within a range, and precalculated trigonometric values\n * to optimize performance. Additionally, it provides auxiliary functions for\n * geometric calculations such as translation extraction, line intersection,\n * and angle calculation.\n */\n\nimport { prng_alea } from \"esm-seedrandom\";\n\n/**\n * The basic source of randomness, can be seeded for determinism.\n * @returns {number} A random number between 0 and 1.\n */\nlet rng = new prng_alea(Math.random());\nexport function seed(s) {\n  rng = new prng_alea(s);\n}\n\n/**\n * Object for random number generation and related utility functions.\n * @property {function} source - Function that returns a random number from the base random generator.\n * @property {function} random - Function to generate a random number within a specified range.\n * @property {function} randInt - Function to generate a random integer within a specified range.\n * @property {function} weightedRand - Function to generate a random value based on weighted probabilities.\n * @property {function} map - Function to remap a number from one range to another.\n * @property {function} constrain - Function to constrain a number within a range.\n * @property {function} cos - Function to get the cosine of an angle from precalculated values.\n * @property {function} sin - Function to get the sine of an angle from precalculated values.\n * @property {boolean} isPrecalculationDone - Flag to check if precalculation of trigonometric values is complete.\n * @property {function} preCalculation - Function to precalculate trigonometric values.\n */\nconst R = {\n  /**\n   * Generates a random number within a specified range.\n   * @param {number} [min=0] - The lower bound of the range.\n   * @param {number} [max=1] - The upper bound of the range.\n   * @returns {number} A random number within the specified range.\n   */\n  random(e = 0, r = 1) {\n    return e + rng() * (r - e);\n  },\n\n  /**\n   * Generates a random integer within a specified range.\n   * @param {number} min - The lower bound of the range.\n   * @param {number} max - The upper bound of the range.\n   * @returns {number} A random integer within the specified range.\n   */\n  randInt(e, r) {\n    return Math.floor(this.random(e, r));\n  },\n\n  /**\n   * Generates a random gaussian.\n   * @param {number} mean - Mean.\n   * @param {number} stdev - Standard deviation.\n   * @returns {number} A random number following a normal distribution.\n   */\n  gaussian(mean = 0, stdev = 1) {\n    const u = 1 - rng();\n    const v = rng();\n    const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n    return z * stdev + mean;\n  },\n\n  /**\n   * Generates a random value based on weighted probabilities.\n   * @param {Object} weights - An object containing values as keys and their probabilities as values.\n   * @returns {string} A key randomly chosen based on its weight.\n   */\n  weightedRand(e) {\n    let r,\n      a,\n      n = [];\n    for (r in e) for (a = 0; a < 10 * e[r]; a++) n.push(r);\n    return n[Math.floor(rng() * n.length)];\n  },\n\n  /**\n   * Remaps a number from one range to another.\n   * @param {number} value - The number to remap.\n   * @param {number} a - The lower bound of the value's current range.\n   * @param {number} b- The upper bound of the value's current range.\n   * @param {number} c - The lower bound of the value's target range.\n   * @param {number} d - The upper bound of the value's target range.\n   * @param {boolean} [withinBounds=false] - Whether to constrain the value to the target range.\n   * @returns {number} The remapped number.\n   */\n  map(value, a, b, c, d, withinBounds = false) {\n    let r = c + ((value - a) / (b - a)) * (d - c);\n    if (!withinBounds) return r;\n    if (c < d) {\n      return this.constrain(r, c, d);\n    } else {\n      return this.constrain(r, d, c);\n    }\n  },\n\n  /**\n   * Constrains a number to be within a range.\n   * @param {number} n - The number to constrain.\n   * @param {number} low - The lower bound of the range.\n   * @param {number} high - The upper bound of the range.\n   * @returns {number} The constrained number.\n   */\n  constrain(n, low, high) {\n    return Math.max(Math.min(n, high), low);\n  },\n\n  /**\n   * Calculates the cosine for a given angle using precalculated values.\n   * @param {number} angle - The angle in degrees.\n   * @returns {number} The cosine of the angle.\n   */\n  cos(angle) {\n    return this.c[Math.floor(4 * (((angle % 360) + 360) % 360))];\n  },\n\n  /**\n   * Calculates the sine for a given angle using precalculated values.\n   * @param {number} angle - The angle in degrees.\n   * @returns {number} The sine of the angle.\n   */\n  sin(angle) {\n    return this.s[Math.floor(4 * (((angle % 360) + 360) % 360))];\n  },\n  // Flag to indicate if the trigonometric tables have been precalculated\n  isPrecalculationDone: false,\n\n  /**\n   * Precalculates trigonometric values for improved performance.\n   * This function should be called before any trigonometric calculations are performed.\n   */\n  preCalculation() {\n    if (this.isPrecalculationDone) return;\n    const totalDegrees = 1440;\n    const radiansPerIndex = (2 * Math.PI) / totalDegrees;\n    this.c = new Float64Array(totalDegrees);\n    this.s = new Float64Array(totalDegrees);\n    for (let i = 0; i < totalDegrees; i++) {\n      const radians = i * radiansPerIndex;\n      R.c[i] = Math.cos(radians);\n      R.s[i] = Math.sin(radians);\n    }\n    this.isPrecalculationDone = true;\n  },\n\n  /**\n   * Checks if value is numeric\n   */\n  isNumber: (a) => !isNaN(a),\n\n  /**\n   * Changes angles to degrees and between 0-360\n   */\n  toDegrees: (a) =>\n    (((_r.angleMode() === \"radians\" ? (a * 180) / Math.PI : a) % 360) + 360) %\n    360,\n\n  /**\n   * Calculates distance between two 2D points\n   */\n  dist: (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1),\n};\n// Perform the precalculation of trigonometric values for the R object\nR.preCalculation();\n\n/**\n * Calculates the intersection point between two line segments if it exists.\n *\n * @param {Object} seg1Start - The start point of the first line segment.\n * @param {Object} seg1End - The end point of the first line segment.\n * @param {Object} seg2Start - The start point of the second line segment.\n * @param {Object} seg2End - The end point of the second line segment.\n * @param {boolean} [includeSegmentExtension=false] - Whether to include points of intersection not lying on the segments.\n * @returns {Object|boolean} The intersection point as an object with 'x' and 'y' properties, or 'false' if there is no intersection.\n */\nfunction _intersectLines(\n  seg1Start,\n  seg1End,\n  seg2Start,\n  seg2End,\n  includeSegmentExtension = false\n) {\n  // Extract coordinates from points\n  let x1 = seg1Start.x,\n    y1 = seg1Start.y;\n  let x2 = seg1End.x,\n    y2 = seg1End.y;\n  let x3 = seg2Start.x,\n    y3 = seg2Start.y;\n  let x4 = seg2End.x,\n    y4 = seg2End.y;\n  // Early return if line segments are points or if the lines are parallel\n  if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\n    return false; // Segments are points\n  }\n  let deltaX1 = x2 - x1,\n    deltaY1 = y2 - y1;\n  let deltaX2 = x4 - x3,\n    deltaY2 = y4 - y3;\n  let denominator = deltaY2 * deltaX1 - deltaX2 * deltaY1;\n  if (denominator === 0) {\n    return false; // Lines are parallel\n  }\n  // Calculate the intersection point\n  let ua = (deltaX2 * (y1 - y3) - deltaY2 * (x1 - x3)) / denominator;\n  let ub = (deltaX1 * (y1 - y3) - deltaY1 * (x1 - x3)) / denominator;\n  // Check if the intersection is within the bounds of the line segments\n  if (!includeSegmentExtension && (ub < 0 || ub > 1)) {\n    return false;\n  }\n  // Calculate the intersection coordinates\n  let x = x1 + ua * deltaX1;\n  let y = y1 + ua * deltaY1;\n  return { x: x, y: y };\n}\n\n/**\n * Calculates the angle in degrees between two points in 2D space.\n * The angle is measured in a clockwise direction from the positive X-axis.\n *\n * @param {number} x1 - The x-coordinate of the first point.\n * @param {number} y1 - The y-coordinate of the first point.\n * @param {number} x2 - The x-coordinate of the second point.\n * @param {number} y2 - The y-coordinate of the second point.\n * @returns {number} The angle in degrees between the two points.\n */\nfunction _calculateAngle(x1, y1, x2, y2) {\n  // Calculate the angle based on the quadrant in which the second point lies\n  let angleRadians = Math.atan2(-(y2 - y1), x2 - x1);\n  // Convert radians to degrees and normalize the angle between 0 and 360\n  let angleDegrees = angleRadians * (180 / Math.PI);\n  return ((angleDegrees % 360) + 360) % 360;\n}\n\n/**\n * Object that saves the current p5.brush state for push and pop operations\n */\nconst _saveState = {\n  field: {},\n  stroke: {},\n  hatch: {},\n  fill: {},\n  others: {},\n};\n\n/**\n * Saves current state to object\n */\nexport function push() {\n  // Field\n  _saveState.field.isActive = FF.isActive;\n  _saveState.field.current = FF.current;\n\n  // Stroke\n  _saveState.stroke.isActive = B.isActive;\n  _saveState.stroke.name = B.name;\n  _saveState.stroke.color = B.c;\n  _saveState.stroke.weight = B.w;\n  _saveState.stroke.clip = B.cr;\n\n  // Hatch\n  _saveState.hatch.isActive = H.isActive;\n  _saveState.hatch.hatchingParams = H.hatchingParams;\n  _saveState.hatch.hatchingBrush = H.hatchingBrush;\n\n  // Fill\n  _saveState.fill.isActive = F.isActive;\n  _saveState.fill.color = F.color;\n  _saveState.fill.opacity = F.opacity;\n  _saveState.fill.bleed_strength = F.bleed_strength;\n  _saveState.fill.texture_strength = F.texture_strength;\n  _saveState.fill.border_strength = F.border_strength;\n\n  // Rotate\n  _saveState.others.rotate = Matrix.rotation;\n}\n\n/**\n * Restores previous state from object\n */\nexport function pop() {\n  // Field\n  FF.isActive = _saveState.field.isActive;\n  FF.current = _saveState.field.current;\n\n  // Stroke\n  B.isActive = _saveState.stroke.isActive;\n  B.name = _saveState.stroke.name;\n  B.c = _saveState.stroke.color;\n  B.w = _saveState.stroke.weight;\n  B.cr = _saveState.stroke.clip;\n\n  // Hatch\n  H.isActive = _saveState.hatch.isActive;\n  H.hatchingParams = _saveState.hatch.hatchingParams;\n  H.hatchingBrush = _saveState.hatch.hatchingBrush;\n\n  // Fill\n  F.isActive = _saveState.fill.isActive;\n  F.color = _saveState.fill.color;\n  F.opacity = _saveState.fill.opacity;\n  F.bleed_strength = _saveState.fill.bleed_strength;\n  F.texture_strength = _saveState.fill.texture_strength;\n  F.border_strength = _saveState.fill.border_strength;\n\n  // Rotate\n  Matrix.rotation = _saveState.others.rotate;\n}\n\n/**\n * Object to perform matrix translation and rotation operations\n */\nconst Matrix = {\n  translation: [0, 0],\n  rotation: 0,\n  /**\n   * Captures the current translation values from the renderer's transformation matrix.\n   *\n   * Assumes that the renderer's transformation matrix (`uModelMatrix`) is a 4x4 matrix\n   * where the translation components are in the 13th (index 12) and 14th (index 13) positions.\n   *\n   * @returns {number[]} An array containing the x (horizontal) and y (vertical) translation values.\n   */\n  trans() {\n    // Access the renderer's current model-view matrix and extract the translation components\n    this.translation = [\n      _r._renderer.uModelMatrix.mat4[12],\n      _r._renderer.uModelMatrix.mat4[13],\n    ];\n    // Return the translation components as a two-element array\n    return this.translation;\n  },\n};\n\n/**\n * Captures the desired rotation.\n */\nexport function rotate(a = 0) {\n  Matrix.rotation = R.toDegrees(a);\n}\n\n/**\n * Object to perform scale operations\n */\nlet _curScale = 1;\nexport function scale(a) {\n  _curScale *= a;\n}\n\n// =============================================================================\n// Section: Color Blending - Uses spectral.js as a module\n// =============================================================================\n/**\n * The Mix object is responsible for handling color blending operations within\n * the rendering context. It utilizes WebGL shaders to apply advanced blending\n * effects based on Kubelka-Munk theory. It depends on spectral.js for the\n * blending logic incorporated into its fragment shader.\n */\n\n/**\n * Enables/Disables color caching for WebGL Shaders.\n * Color caching increases performance but might produce worse textures\n * when using the same colour repeteadly.\n * @param {bool} bool\n *\n */\nexport function colorCache(bool = true) {\n  Mix.isCaching = bool;\n}\n\n/**\n * Object handling blending operations with WebGL shaders.\n * @property {boolean} loaded - Flag indicating if the blend shaders have been loaded.\n * @property {boolean} isBlending - Flag indicating if the blending has been initiated.\n * @property {boolean} isCaching - Flag indicating if the color caching is active.\n * @property {Float32Array} currentColor - Typed array to hold color values for shaders.\n * @property {function} load - Loads resources and initializes blend operations.\n * @property {function} blend - Applies blending effects using the initialized shader.\n * @property {string} vert - Vertex shader source code.\n * @property {string} frag - Fragment shader source code with blending logic.\n */\nconst Mix = {\n  loaded: false,\n  isBlending: false,\n  isCaching: true,\n  currentColor: new Float32Array(3),\n\n  /**\n   * Loads necessary resources and prepares the mask buffer and shader for colour blending.\n   */\n  load(inst) {\n    this.type = _isInstanced && !inst ? 0 : !inst ? 1 : 2;\n    this.masks = [];\n    // Create a buffer to be used as a mask for blending\n    // WEBGL buffer for img brushes (image() is much quicker like this)\n    // Create a buffer for noBlend brushes\n    for (let i = 0; i < 3; i++) {\n      switch (this.type) {\n        case 0:\n          this.masks[i] = _r.createGraphics(\n            _r.width,\n            _r.height,\n            i == 1 ? _r.WEBGL : _r.P2D\n          );\n          break;\n        case 1:\n          this.masks[i] = createGraphics(\n            _r.width,\n            _r.height,\n            i == 1 ? WEBGL : P2D\n          );\n          break;\n        case 2:\n          this.masks[i] = inst.createGraphics(\n            inst.width,\n            inst.height,\n            i == 1 ? inst.WEBGL : inst.P2D\n          );\n          break;\n      }\n    }\n\n    for (let mask of this.masks) {\n      mask.pixelDensity(_r.pixelDensity());\n      mask.clear();\n      mask.angleMode(_r.DEGREES);\n      mask.noSmooth();\n    }\n\n    // Create the shader program from the vertex and fragment shaders\n    this.shader = _r.createShader(this.vert, this.frag);\n    Mix.loaded = true;\n  },\n\n  /**\n   * Converts a color object with RGB levels to a Float32Array representation.\n   * The RGB levels are normalized to a range of 0.0 to 1.0.\n   * @param {object} _color - A p5 color object representing a color, containing an 'levels' property.\n   * @returns {Float32Array} A Float32Array with three elements, each representing the normalized levels of red, green, and blue.\n   */\n  getPigment(_color) {\n    let currentLevels = _color.levels;\n    let colorArray = new Float32Array(3);\n    colorArray[0] = currentLevels[0] / 255.0;\n    colorArray[1] = currentLevels[1] / 255.0;\n    colorArray[2] = currentLevels[2] / 255.0;\n    return colorArray;\n  },\n\n  /**\n   * There are two parallel blender instances: one uses the 2D mask, the other the WEBGL mask\n   * 2D Canvas API mask: for basi geometry (circles, polygons, etc), which is much faster with the 2D API\n   * WEBGL mask: for image-type brushes. p5 image() is much faster in WEBGL mode\n   */\n  color1: new Float32Array(3),\n  color2: new Float32Array(3),\n  blending1: false,\n  blending2: false,\n\n  /**\n   * Applies the blend shader to the current rendering context.\n   * @param {string} _c - The color used for blending, as a p5.Color object.\n   * @param {boolean} _isLast - Indicates if this is the last blend after setup and draw.\n   * @param {boolean} _isLast - Indicates if this is the last blend after setup and draw.\n   */\n  blend(_color = false, _isLast = false, webgl_mask = false) {\n    _ensureReady();\n\n    // Select between the two options:\n    this.isBlending = webgl_mask ? this.blending1 : this.blending2;\n    this.currentColor = webgl_mask ? this.color1 : this.color2;\n\n    // Check if blending is initialised\n    if (!this.isBlending) {\n      // If color has been provided, we initialise blending\n      if (_color) {\n        this.currentColor = this.getPigment(_color);\n        if (webgl_mask)\n          (this.blending1 = true), (this.color1 = this.currentColor);\n        else (this.blending2 = true), (this.color2 = this.currentColor);\n      } else if (_isLast) {\n        if (!webgl_mask) reDraw();\n        return;\n      }\n    }\n\n    // Checks if newColor is the same than the cadhedColor\n    // If it is the same, we wait before applying the shader for color mixing\n    // If it's NOT the same, we apply the shader and cache the new color\n    let newColor = !_color ? this.currentColor : this.getPigment(_color);\n\n    if (\n      newColor.toString() !== this.currentColor.toString() ||\n      _isLast ||\n      !this.isCaching\n    ) {\n      // Paste info from noBlend buffer\n      reDraw();\n\n      if (this.isBlending) {\n        _r.push();\n        _r.translate(-Matrix.trans()[0], -Matrix.trans()[1]);\n        // Use the blend shader for rendering\n        _r.shader(this.shader);\n        // Set shader uniforms\n        // Color to blend\n        this.shader.setUniform(\"addColor\", this.currentColor);\n        // Source canvas\n        this.shader.setUniform(\"source\", _r._renderer);\n        // Bool to active watercolor blender vs marker blenderd\n        this.shader.setUniform(\"active\", Mix.watercolor);\n        // Random values for watercolor blender\n        this.shader.setUniform(\"random\", [R.random(), R.random(), R.random()]);\n        // We select and apply the correct mask here\n        let mask = webgl_mask ? this.masks[1] : this.masks[0];\n        this.shader.setUniform(\"mask\", mask);\n        // Draw a rectangle covering the whole canvas to apply the shader\n        _r.fill(0, 0, 0, 0);\n        _r.noStroke();\n        _r.rect(-_r.width / 2, -_r.height / 2, _r.width, _r.height);\n        _r.pop();\n        // Clear the mask after drawing\n        mask.clear();\n      }\n      // We cache the new color here\n      if (!_isLast) {\n        this.currentColor = this.getPigment(_color);\n        if (webgl_mask) this.color1 = this.currentColor;\n        else this.color2 = this.currentColor;\n      }\n    }\n\n    if (_isLast) {\n      this.isBlending = false;\n      if (webgl_mask) this.blending1 = this.isBlending;\n      else this.blending2 = this.isBlending;\n    }\n  },\n\n  // Vertex shader source code\n  vert: `precision highp float;attribute vec3 aPosition;attribute vec2 aTexCoord;uniform mat4 uModelViewMatrix,uProjectionMatrix;varying vec2 vVertTexCoord;void main(){gl_Position=uProjectionMatrix*uModelViewMatrix*vec4(aPosition,1);vVertTexCoord=aTexCoord;}`,\n\n  // Fragment shader source code with blending operations\n  // For unminified shader see shader_unminified.frag\n  frag: `precision highp float;varying vec2 vVertTexCoord;uniform sampler2D source,mask;uniform vec4 addColor;uniform vec3 random;uniform bool active;\n        #ifndef SPECTRAL\n        #define SPECTRAL\n        float x(float v){return v<.04045?v/12.92:pow((v+.055)/1.055,2.4);}float v(float v){return v<.0031308?v*12.92:1.055*pow(v,1./2.4)-.055;}vec3 m(vec3 v){return vec3(x(v[0]),x(v[1]),x(v[2]));}vec3 f(vec3 f){return clamp(vec3(v(f[0]),v(f[1]),v(f[2])),0.,1.);}void f(vec3 v,out float m,out float f,out float x,out float y,out float z,out float i,out float r){m=min(v.x,min(v.y,v.z));v-=m;f=min(v.y,v.z);x=min(v.x,v.z);y=min(v.x,v.y);z=min(max(0.,v.x-v.z),max(0.,v.x-v.y));i=min(max(0.,v.y-v.z),max(0.,v.y-v.x));r=min(max(0.,v.z-v.y),max(0.,v.z-v.x));}void f(vec3 v,inout float i[38]){float x,y,d,z,o,m,e;f(v,x,y,d,z,o,m,e);i[0]=max(1e-4,x+y*.96853629+d*.51567122+z*.02055257+o*.03147571+m*.49108579+e*.97901834);i[1]=max(1e-4,x+y*.96855103+d*.5401552+z*.02059936+o*.03146636+m*.46944057+e*.97901649);i[2]=max(1e-4,x+y*.96859338+d*.62645502+z*.02062723+o*.03140624+m*.4016578+e*.97901118);i[3]=max(1e-4,x+y*.96877345+d*.75595012+z*.02073387+o*.03119611+m*.2449042+e*.97892146);i[4]=max(1e-4,x+y*.96942204+d*.92826996+z*.02114202+o*.03053888+m*.0682688+e*.97858555);i[5]=max(1e-4,x+y*.97143709+d*.97223624+z*.02233154+o*.02856855+m*.02732883+e*.97743705);i[6]=max(1e-4,x+y*.97541862+d*.98616174+z*.02556857+o*.02459485+m*.013606+e*.97428075);i[7]=max(1e-4,x+y*.98074186+d*.98955255+z*.03330189+o*.0192952+m*.01000187+e*.96663223);i[8]=max(1e-4,x+y*.98580992+d*.98676237+z*.05185294+o*.01423112+m*.01284127+e*.94822893);i[9]=max(1e-4,x+y*.98971194+d*.97312575+z*.10087639+o*.01033111+m*.02636635+e*.89937713);i[10]=max(1e-4,x+y*.99238027+d*.91944277+z*.24000413+o*.00765876+m*.07058713+e*.76070164);i[11]=max(1e-4,x+y*.99409844+d*.32564851+z*.53589066+o*.00593693+m*.70421692+e*.4642044);i[12]=max(1e-4,x+y*.995172+d*.13820628+z*.79874659+o*.00485616+m*.85473994+e*.20123039);i[13]=max(1e-4,x+y*.99576545+d*.05015143+z*.91186529+o*.00426186+m*.95081565+e*.08808402);i[14]=max(1e-4,x+y*.99593552+d*.02912336+z*.95399623+o*.00409039+m*.9717037+e*.04592894);i[15]=max(1e-4,x+y*.99564041+d*.02421691+z*.97137099+o*.00438375+m*.97651888+e*.02860373);i[16]=max(1e-4,x+y*.99464769+d*.02660696+z*.97939505+o*.00537525+m*.97429245+e*.02060067);i[17]=max(1e-4,x+y*.99229579+d*.03407586+z*.98345207+o*.00772962+m*.97012917+e*.01656701);i[18]=max(1e-4,x+y*.98638762+d*.04835936+z*.98553736+o*.0136612+m*.9425863+e*.01451549);i[19]=max(1e-4,x+y*.96829712+d*.0001172+z*.98648905+o*.03181352+m*.99989207+e*.01357964);i[20]=max(1e-4,x+y*.89228016+d*8.554e-5+z*.98674535+o*.10791525+m*.99989891+e*.01331243);i[21]=max(1e-4,x+y*.53740239+d*.85267882+z*.98657555+o*.46249516+m*.13823139+e*.01347661);i[22]=max(1e-4,x+y*.15360445+d*.93188793+z*.98611877+o*.84604333+m*.06968113+e*.01387181);i[23]=max(1e-4,x+y*.05705719+d*.94810268+z*.98559942+o*.94275572+m*.05628787+e*.01435472);i[24]=max(1e-4,x+y*.03126539+d*.94200977+z*.98507063+o*.96860996+m*.06111561+e*.01479836);i[25]=max(1e-4,x+y*.02205445+d*.91478045+z*.98460039+o*.97783966+m*.08987709+e*.0151525);i[26]=max(1e-4,x+y*.01802271+d*.87065445+z*.98425301+o*.98187757+m*.13656016+e*.01540513);i[27]=max(1e-4,x+y*.0161346+d*.78827548+z*.98403909+o*.98377315+m*.22169624+e*.01557233);i[28]=max(1e-4,x+y*.01520947+d*.65738359+z*.98388535+o*.98470202+m*.32176956+e*.0156571);i[29]=max(1e-4,x+y*.01475977+d*.59909403+z*.98376116+o*.98515481+m*.36157329+e*.01571025);i[30]=max(1e-4,x+y*.01454263+d*.56817268+z*.98368246+o*.98537114+m*.4836192+e*.01571916);i[31]=max(1e-4,x+y*.01444459+d*.54031997+z*.98365023+o*.98546685+m*.46488579+e*.01572133);i[32]=max(1e-4,x+y*.01439897+d*.52110241+z*.98361309+o*.98550011+m*.47440306+e*.01572502);i[33]=max(1e-4,x+y*.0143762+d*.51041094+z*.98357259+o*.98551031+m*.4857699+e*.01571717);i[34]=max(1e-4,x+y*.01436343+d*.50526577+z*.98353856+o*.98550741+m*.49267971+e*.01571905);i[35]=max(1e-4,x+y*.01435687+d*.5025508+z*.98351247+o*.98551323+m*.49625685+e*.01571059);i[36]=max(1e-4,x+y*.0143537+d*.50126452+z*.98350101+o*.98551563+m*.49807754+e*.01569728);i[37]=max(1e-4,x+y*.01435408+d*.50083021+z*.98350852+o*.98551547+m*.49889859+e*.0157002);}vec3 t(vec3 x){mat3 i;i[0]=vec3(3.24306333,-1.53837619,-.49893282);i[1]=vec3(-.96896309,1.87542451,.04154303);i[2]=vec3(.05568392,-.20417438,1.05799454);float v=dot(i[0],x),y=dot(i[1],x),o=dot(i[2],x);return f(vec3(v,y,o));}vec3 d(float m[38]){vec3 i=vec3(0);i+=m[0]*vec3(6.469e-5,1.84e-6,.00030502);i+=m[1]*vec3(.00021941,6.21e-6,.00103681);i+=m[2]*vec3(.00112057,3.101e-5,.00531314);i+=m[3]*vec3(.00376661,.00010475,.01795439);i+=m[4]*vec3(.01188055,.00035364,.05707758);i+=m[5]*vec3(.02328644,.00095147,.11365162);i+=m[6]*vec3(.03455942,.00228226,.17335873);i+=m[7]*vec3(.03722379,.00420733,.19620658);i+=m[8]*vec3(.03241838,.0066888,.18608237);i+=m[9]*vec3(.02123321,.0098884,.13995048);i+=m[10]*vec3(.01049099,.01524945,.08917453);i+=m[11]*vec3(.00329584,.02141831,.04789621);i+=m[12]*vec3(.00050704,.03342293,.02814563);i+=m[13]*vec3(.00094867,.05131001,.01613766);i+=m[14]*vec3(.00627372,.07040208,.0077591);i+=m[15]*vec3(.01686462,.08783871,.00429615);i+=m[16]*vec3(.02868965,.09424905,.00200551);i+=m[17]*vec3(.04267481,.09795667,.00086147);i+=m[18]*vec3(.05625475,.09415219,.00036904);i+=m[19]*vec3(.0694704,.08678102,.00019143);i+=m[20]*vec3(.08305315,.07885653,.00014956);i+=m[21]*vec3(.0861261,.0635267,9.231e-5);i+=m[22]*vec3(.09046614,.05374142,6.813e-5);i+=m[23]*vec3(.08500387,.04264606,2.883e-5);i+=m[24]*vec3(.07090667,.03161735,1.577e-5);i+=m[25]*vec3(.05062889,.02088521,3.94e-6);i+=m[26]*vec3(.03547396,.01386011,1.58e-6);i+=m[27]*vec3(.02146821,.00810264,0);i+=m[28]*vec3(.01251646,.0046301,0);i+=m[29]*vec3(.00680458,.00249138,0);i+=m[30]*vec3(.00346457,.0012593,0);i+=m[31]*vec3(.00149761,.00054165,0);i+=m[32]*vec3(.0007697,.00027795,0);i+=m[33]*vec3(.00040737,.00014711,0);i+=m[34]*vec3(.00016901,6.103e-5,0);i+=m[35]*vec3(9.522e-5,3.439e-5,0);i+=m[36]*vec3(4.903e-5,1.771e-5,0);i+=m[37]*vec3(2e-5,7.22e-6,0);return i;}float d(float y,float m,float v){float z=m*pow(v,2.);return z/(y*pow(1.-v,2.)+z);}vec3 f(vec3 v,vec3 y,float z){vec3 x=m(v),o=m(y);float i[38],a[38];f(x,i);f(o,a);float r=d(i)[1],e=d(a)[1];z=d(r,e,z);float s[38];for(int u=0;u<38;u++){float p=(1.-z)*(pow(1.-i[u],2.)/(2.*i[u]))+z*(pow(1.-a[u],2.)/(2.*a[u]));s[u]=1.+p-sqrt(pow(p,2.)+2.*p);}return t(d(s));}vec4 f(vec4 v,vec4 x,float y){return vec4(f(v.xyz,x.xyz,y),mix(v.w,x.w,y));}\n        #endif\n        float d(vec2 m,vec2 v,float y,out vec2 i){vec2 f=vec2(m.x+m.y*.5,m.y),x=floor(f),o=fract(f);float z=step(o.y,o.x);vec2 d=vec2(z,1.-z),r=x+d,e=x+1.,a=vec2(x.x-x.y*.5,x.y),p=vec2(a.x+d.x-d.y*.5,a.y+d.y),s=vec2(a.x+.5,a.y+1.),w=m-a,g=m-p,k=m-s;vec3 u,c,t,A;if(any(greaterThan(v,vec2(0)))){t=vec3(a.x,p.x,s);A=vec3(a.y,p.y,s.y);if(v.x>0.)t=mod(vec3(a.x,p.x,s),v.x);if(v.y>0.)A=mod(vec3(a.y,p.y,s.y),v.y);u=floor(t+.5*A+.5);c=floor(A+.5);}else u=vec3(x.x,r.x,e),c=vec3(x.y,r.y,e.y);vec3 S=mod(u,289.);S=mod((S*51.+2.)*S+c,289.);S=mod((S*34.+10.)*S,289.);vec3 b=S*.07482+y,C=cos(b),D=sin(b);vec2 h=vec2(C.x,D),B=vec2(C.y,D.y),E=vec2(C.z,D.z);vec3 F=.8-vec3(dot(w,w),dot(g,g),dot(k,k));F=max(F,0.);vec3 G=F*F,H=G*G,I=vec3(dot(h,w),dot(B,g),dot(E,k)),J=G*F,K=-8.*J*I;i=10.9*(H.x*h+K.x*w+(H.y*B+K.y*g)+(H.z*E+K.z*k));return 10.9*dot(H,I);}vec4 d(vec3 v,float x){return vec4(mix(v,vec3(dot(vec3(.299,.587,.114),v)),x),1);}float f(vec2 v,float x,float y,float f){return fract(sin(dot(v,vec2(x,y)))*f);}void main(){vec4 v=texture2D(mask,vVertTexCoord);if(v.x>0.){vec2 x=vec2(12.9898,78.233),o=vec2(7.9898,58.233),m=vec2(17.9898,3.233);float y=f(vVertTexCoord,x.x,x.y,43358.5453)*2.-1.,z=f(vVertTexCoord,o.x,o.y,43213.5453)*2.-1.,e=f(vVertTexCoord,m.x,m.y,33358.5453)*2.-1.;const vec2 i=vec2(0);vec2 s;vec4 r;if(active){float a=d(vVertTexCoord*5.,i,10.*random.x,s),p=d(vVertTexCoord*5.,i,10.*random.y,s),g=d(vVertTexCoord*5.,i,10.*random.z,s),k=.25+.25*d(vVertTexCoord*4.,i,3.*random.x,s);r=vec4(d(addColor.xyz,k).xyz+vec3(a,p,g)*.03*abs(addColor.x-addColor.y-addColor.z),1);}else r=vec4(addColor.xyz,1);if(v.w>.7){float a=.5*(v.w-.7);r=r*(1.-a)-vec4(.5)*a;}vec3 a=f(texture2D(source,vVertTexCoord).xyz,r.xyz,.9*v.w);gl_FragColor=vec4(a+.01*vec3(y,z,e),1);}}`,\n};\n\n/**\n * This function forces standard-brushes to be updated into the canvas\n */\nexport function reDraw() {\n  _r.push();\n  _r.translate(-Matrix.trans()[0], -Matrix.trans()[1]);\n  _r.image(Mix.masks[2], -_r.width / 2, -_r.height / 2);\n  Mix.masks[2].clear();\n  _r.pop();\n}\n\n/**\n * This function forces marker-brushes and fills to be updated into the canvas\n */\nexport function reBlend() {\n  Mix.blend(false, true);\n  Mix.blend(false, true, true);\n}\n\n/**\n * Register methods after setup() and post draw() for belding last buffered color\n */\nfunction _registerMethods(p5p) {\n  p5p.registerMethod(\"afterSetup\", () => Mix.blend(false, true));\n  p5p.registerMethod(\"afterSetup\", () => Mix.blend(false, true, true));\n  p5p.registerMethod(\"post\", () => Mix.blend(false, true));\n  p5p.registerMethod(\"post\", () => Mix.blend(false, true, true));\n}\nif (typeof p5 !== \"undefined\") _registerMethods(p5.prototype);\n\nexport function instance(inst) {\n  _isInstanced = true;\n  _inst = inst;\n  _r = inst;\n  _registerMethods(inst);\n}\n\n// =============================================================================\n// Section: FlowField\n// =============================================================================\n/**\n * The FlowField (FF) section includes functions and objects for creating and managing vector fields.\n * These fields can guide the motion of particles or brush strokes in a canvas, creating complex and\n * dynamic visual patterns.\n */\n\n/**\n * Activates a specific vector field by name, ensuring it's ready for use.\n * @param {string} a - The name of the vector field to activate.\n */\nexport function field(a) {\n  _ensureReady();\n  // Check if field exists\n  FF.isActive = true; // Mark the field framework as active\n  FF.current = a; // Update the current field\n}\n\n/**\n * Deactivates the current vector field.\n */\nexport function noField() {\n  _ensureReady();\n  FF.isActive = false;\n}\n\n/**\n * Adds a new vector field to the field list with a unique name and a generator function.\n * @param {string} name - The unique name for the new vector field.\n * @param {Function} funct - The function that generates the field values.\n */\nexport function addField(name, funct) {\n  FF.list.set(name, { gen: funct }); // Map the field name to its generator function\n  FF.current = name; // Set the newly added field as the current one to be used\n  FF.refresh(); // Refresh the field values using the generator function\n}\n\n/**\n * Refreshes the current vector field based on the generator function, which can be time-dependent.\n * @param {number} [t=0] - An optional time parameter that can affect field generation.\n */\nexport function refreshField(t) {\n  FF.refresh(t);\n}\n\n/**\n * Retrieves a list of all available vector field names.\n * @returns {Iterator<string>} An iterator that provides the names of all the fields.\n */\nexport function listFields() {\n  return Array.from(FF.list.keys());\n}\n\n/**\n * Represents a framework for managing vector fields used in dynamic simulations or visualizations.\n * @property {boolean} isActive - Indicates whether any vector field is currently active.\n * @property {Map} list - A map associating field names to their respective generator functions and current states.\n * @property {Array} field - An array representing the current vector field grid with values.\n */\nconst FF = {\n  isActive: false,\n  list: new Map(),\n  current: \"\",\n\n  /**\n   * Calculates a relative step length based on the renderer's dimensions, used in field grid calculations.\n   * @returns {number} The relative step length value.\n   */\n  step_length() {\n    return Math.min(_r.width, _r.height) / 1000;\n  },\n\n  /**\n   * Initializes the field grid and sets up the vector field's structure based on the renderer's dimensions.\n   */\n  create() {\n    this.R = _r.width * 0.01; // Determine the resolution of the field grid\n    this.left_x = -1 * _r.width; // Left boundary of the field\n    this.top_y = -1 * _r.height; // Top boundary of the field\n    this.num_columns = Math.round((2 * _r.width) / this.R); // Number of columns in the grid\n    this.num_rows = Math.round((2 * _r.height) / this.R); // Number of columns in the grid\n    this.addStandard(); // Add default vector fields\n  },\n\n  /**\n   * Retrieves the field values for the current vector field.\n   * @returns {Float64Array[]} The current vector field grid.\n   */\n  flow_field() {\n    return this.list.get(this.current).field;\n  },\n\n  /**\n   * Regenerates the current vector field using its associated generator function.\n   * @param {number} [t=0] - An optional time parameter that can affect field generation.\n   */\n  refresh(t = 0) {\n    this.list.get(this.current).field = this.list\n      .get(this.current)\n      .gen(t, this.genField());\n  },\n\n  /**\n   * Generates empty field array using its associated generator function.\n   * @returns {Float64Array[]} Empty vector field grid.\n   */\n  genField() {\n    let grid = new Array(this.num_columns); // Initialize the field array\n    for (let i = 0; i < this.num_columns; i++) {\n      grid[i] = new Float64Array(this.num_rows);\n    }\n    return grid;\n  },\n\n  /**\n   * Adds standard predefined vector fields to the list with unique behaviors.\n   */\n  addStandard() {\n    addField(\"curved\", function (t, field) {\n      let angleRange = R.randInt(-25, -15);\n      if (R.randInt(0, 100) % 2 == 0) {\n        angleRange = angleRange * -1;\n      }\n      for (let column = 0; column < FF.num_columns; column++) {\n        for (let row = 0; row < FF.num_rows; row++) {\n          let noise_val = _r.noise(\n            column * 0.02 + t * 0.03,\n            row * 0.02 + t * 0.03\n          );\n          let angle = R.map(noise_val, 0.0, 1.0, -angleRange, angleRange);\n          field[column][row] = 3 * angle;\n        }\n      }\n      return field;\n    });\n    addField(\"truncated\", function (t, field) {\n      let angleRange = R.randInt(-25, -15) + 5 * R.sin(t);\n      if (R.randInt(0, 100) % 2 == 0) {\n        angleRange = angleRange * -1;\n      }\n      let truncate = R.randInt(5, 10);\n      for (let column = 0; column < FF.num_columns; column++) {\n        for (let row = 0; row < FF.num_rows; row++) {\n          let noise_val = _r.noise(column * 0.02, row * 0.02);\n          let angle =\n            Math.round(\n              R.map(noise_val, 0.0, 1.0, -angleRange, angleRange) / truncate\n            ) * truncate;\n          field[column][row] = 4 * angle;\n        }\n      }\n      return field;\n    });\n    addField(\"zigzag\", function (t, field) {\n      let angleRange = R.randInt(-30, -15) + Math.abs(44 * R.sin(t));\n      if (R.randInt(0, 100) % 2 == 0) {\n        angleRange = angleRange * -1;\n      }\n      let dif = angleRange;\n      let angle = 0;\n      for (let column = 0; column < FF.num_columns; column++) {\n        for (let row = 0; row < FF.num_rows; row++) {\n          field[column][row] = angle;\n          angle = angle + dif;\n          dif = -1 * dif;\n        }\n        angle = angle + dif;\n        dif = -1 * dif;\n      }\n      return field;\n    });\n    addField(\"waves\", function (t, field) {\n      let sinrange = R.randInt(10, 15) + 5 * R.sin(t);\n      let cosrange = R.randInt(3, 6) + 3 * R.cos(t);\n      let baseAngle = R.randInt(20, 35);\n      for (let column = 0; column < FF.num_columns; column++) {\n        for (let row = 0; row < FF.num_rows; row++) {\n          let angle =\n            R.sin(sinrange * column) * (baseAngle * R.cos(row * cosrange)) +\n            R.randInt(-3, 3);\n          field[column][row] = angle;\n        }\n      }\n      return field;\n    });\n    addField(\"seabed\", function (t, field) {\n      let baseSize = R.random(0.4, 0.8);\n      let baseAngle = R.randInt(18, 26);\n      for (let column = 0; column < FF.num_columns; column++) {\n        for (let row = 0; row < FF.num_rows; row++) {\n          let addition = R.randInt(15, 20);\n          let angle = baseAngle * R.sin(baseSize * row * column + addition);\n          field[column][row] = 1.1 * angle * R.cos(t);\n        }\n      }\n      return field;\n    });\n  },\n};\n\n/**\n * The Position class represents a point within a two-dimensional space, which can interact with a vector field.\n * It provides methods to update the position based on the field's flow and to check whether the position is\n * within certain bounds (e.g., within the field or canvas).\n */\nexport class Position {\n  /**\n   * Constructs a new Position instance.\n   * @param {number} x - The initial x-coordinate.\n   * @param {number} y - The initial y-coordinate.\n   */\n  constructor(x, y) {\n    this.update(x, y);\n    this.plotted = 0;\n  }\n\n  /**\n   * Updates the position's coordinates and calculates its offsets and indices within the flow field if active.\n   * @param {number} x - The new x-coordinate.\n   * @param {number} y - The new y-coordinate.\n   */\n  update(x, y) {\n    (this.x = x), (this.y = y);\n    if (FF.isActive) {\n      this.x_offset = this.x - FF.left_x + Matrix.trans()[0];\n      this.y_offset = this.y - FF.top_y + Matrix.trans()[1];\n      this.column_index = Math.round(this.x_offset / FF.R);\n      this.row_index = Math.round(this.y_offset / FF.R);\n    }\n  }\n\n  /**\n   * Resets the 'plotted' property to 0.\n   */\n  reset() {\n    this.plotted = 0;\n  }\n\n  /**\n   * Checks if the position is within the active flow field's bounds.\n   * @returns {boolean} - True if the position is within the flow field, false otherwise.\n   */\n  isIn() {\n    return FF.isActive\n      ? this.column_index >= 0 &&\n          this.row_index >= 0 &&\n          this.column_index < FF.num_columns &&\n          this.row_index < FF.num_rows\n      : this.isInCanvas();\n  }\n\n  /**\n   * Checks if the position is within reasonable bounds (+ half canvas on each side).\n   * @returns {boolean} - True if the position is within bounds, false otherwise.\n   */\n  isInCanvas() {\n    let w = _r.width,\n      h = _r.height;\n    return (\n      this.x >= -w - Matrix.trans()[0] &&\n      this.x <= w - Matrix.trans()[0] &&\n      this.y >= -h - Matrix.trans()[1] &&\n      this.y <= h - Matrix.trans()[1]\n    );\n  }\n\n  /**\n   * Calculates the angle of the flow field at the position's current coordinates.\n   * @returns {number} - The angle in radians, or 0 if the position is not in the flow field or if the flow field is not active.\n   */\n  angle() {\n    return this.isIn() && FF.isActive\n      ? FF.flow_field()[this.column_index][this.row_index]\n      : 0;\n  }\n\n  /**\n   * Moves the position along the flow field by a certain length.\n   * @param {number} _length - The length to move along the field.\n   * @param {number} _dir - The direction of movement.\n   * @param {number} _step_length - The length of each step.\n   * @param {boolean} isFlow - Whether to use the flow field for movement.\n   */\n  moveTo(_length, _dir, _step_length = B.spacing(), isFlow = true) {\n    if (this.isIn()) {\n      let a, b;\n      if (!isFlow) {\n        a = R.cos(-_dir);\n        b = R.sin(-_dir);\n      }\n      for (let i = 0; i < _length / _step_length; i++) {\n        if (isFlow) {\n          let angle = this.angle();\n          a = R.cos(angle - _dir);\n          b = R.sin(angle - _dir);\n        }\n        let x_step = _step_length * a,\n          y_step = _step_length * b;\n        this.plotted += _step_length;\n        this.update(this.x + x_step, this.y + y_step);\n      }\n    } else {\n      this.plotted += _step_length;\n    }\n  }\n\n  /**\n   * Plots a point to another position within the flow field, following a Plot object\n   * @param {Position} _plot - The Plot path object.\n   * @param {number} _length - The length to move towards the target position.\n   * @param {number} _step_length - The length of each step.\n   * @param {number} _scale - The scaling factor for the plotting path.\n   */\n  plotTo(_plot, _length, _step_length, _scale) {\n    if (this.isIn()) {\n      const inverse_scale = 1 / _scale;\n      for (let i = 0; i < _length / _step_length; i++) {\n        let current_angle = this.angle();\n        let plot_angle = _plot.angle(this.plotted);\n        let x_step = _step_length * R.cos(current_angle - plot_angle);\n        let y_step = _step_length * R.sin(current_angle - plot_angle);\n        this.plotted += _step_length * inverse_scale;\n        this.update(this.x + x_step, this.y + y_step);\n      }\n    } else {\n      this.plotted += _step_length / scale;\n    }\n  }\n}\n\n// =============================================================================\n// Section: Brushes\n// =============================================================================\n/**\n * The Brushes section provides tools for drawing with various brush types. Each brush\n * can simulate different materials and techniques, such as spray, marker, or custom\n * image stamps. The 'B' object is central to this section, storing brush properties\n * and methods for applying brush strokes to the canvas.\n *\n * The 'B' object contains methods to control the brush, including setting the brush\n * type, color, weight, and blending mode. It also handles the application of the brush\n * to draw lines, flow lines, and shapes with specific behaviors defined by the brush type.\n * Additionally, it provides a mechanism to clip the drawing area, ensuring brush strokes\n * only appear within the defined region.\n *\n * Brush tips can vary from basic circles to complex patterns, with support for custom\n * pressure curves, opacity control, and dynamic size adjustments to simulate natural\n * drawing tools. The brush engine can create effects like variable line weight, texture,\n * and color blending, emulating real-world drawing experiences.\n *\n * The brush system is highly customizable, allowing users to define their own brushes\n * with specific behaviors and appearances. By extending the brush types and parameters,\n * one can achieve a wide range of artistic styles and techniques.\n */\n\n/**\n * Adjusts the global scale of brush parameters based on the provided scale factor.\n * This affects the weight, vibration, and spacing of each standard brush.\n *\n * @param {number} _scale - The scaling factor to apply to the brush parameters.\n */\nexport function scaleBrushes(_scale) {\n  for (let s of _standard_brushes) {\n    let params = B.list.get(s[0]).param;\n    (params.weight *= _scale),\n      (params.vibration *= _scale),\n      (params.spacing *= _scale);\n  }\n  _gScale = _scale;\n}\nlet _gScale = 1;\n\n/**\n * Disables the stroke for subsequent drawing operations.\n * This function sets the brush's `isActive` property to false, indicating that no stroke\n * should be applied to the shapes drawn after this method is called.\n */\nexport function noStroke() {\n  B.isActive = false;\n}\n\n/**\n * Retrieves a list of all available brush names from the brush manager.\n * @returns {Array<string>} An array containing the names of all brushes.\n */\nexport function box() {\n  return Array.from(B.list.keys());\n}\n\n/**\n * The B object, representing a brush, contains properties and methods to manipulate\n * the brush's appearance and behavior when drawing on the canvas.\n * @type {Object}\n */\nconst B = {\n  isActive: true, // Indicates if the brush is active.\n  list: new Map(), // Stores brush definitions by name.\n  c: \"#000000\", // Current color of the brush.\n  w: 1, // Current weight (size) of the brush.\n  cr: null, // Clipping region for brush strokes.\n  name: \"HB\", // Name of the current brush.\n\n  /**\n   * Calculates the tip spacing based on the current brush parameters.\n   * @returns {number} The calculated spacing value.\n   */\n  spacing() {\n    this.p = this.list.get(this.name).param;\n    if (this.p.type === \"default\" || this.p.type === \"spray\")\n      return this.p.spacing / this.w;\n    return this.p.spacing;\n  },\n\n  /**\n   * Initializes the drawing state with the given parameters.\n   * @param {number} x - The x-coordinate of the starting point.\n   * @param {number} y - The y-coordinate of the starting point.\n   * @param {number} length - The length of the line to draw.\n   * @param {boolean} flow - Flag indicating if the line should follow the vector-field.\n   * @param {Object|boolean} plot - The shape object to be used for plotting, or false if not plotting a shape.\n   */\n  initializeDrawingState(x, y, length, flow, plot) {\n    this.position = new Position(x, y);\n    this.length = length;\n    this.flow = flow;\n    this.plot = plot;\n    if (plot) plot.calcIndex(0);\n  },\n\n  /**\n   * Executes the drawing operation for lines or shapes.\n   * @param {number} angle_scale - The angle or scale to apply during drawing.\n   * @param {boolean} isPlot - Flag indicating if the operation is plotting a shape.\n   */\n  draw(angle_scale, isPlot) {\n    if (!isPlot) this.dir = angle_scale;\n    this.pushState();\n    const st = this.spacing();\n    const total_steps = isPlot\n      ? Math.round((this.length * angle_scale) / st)\n      : Math.round(this.length / st);\n    for (let steps = 0; steps < total_steps; steps++) {\n      this.tip();\n      if (isPlot) {\n        this.position.plotTo(this.plot, st, st, angle_scale);\n      } else {\n        this.position.moveTo(st, angle_scale, st, this.flow);\n      }\n    }\n    this.popState();\n  },\n\n  /**\n   * Executes the drawing operation for a single tip.\n   * @param {number} pressure - The desired pressure value.\n   */\n  drawTip(pressure) {\n    this.pushState(true);\n    this.tip(pressure);\n    this.popState(true);\n  },\n\n  /**\n   * Sets up the environment for a brush stroke.\n   */\n  pushState(isTip = false) {\n    this.p = this.list.get(this.name).param;\n    // Pressure values for the stroke\n    if (!isTip) {\n      this.a = this.p.pressure.type !== \"custom\" ? R.random(-1, 1) : 0;\n      this.b = this.p.pressure.type !== \"custom\" ? R.random(1, 1.5) : 0;\n      this.cp =\n        this.p.pressure.type !== \"custom\"\n          ? R.random(3, 3.5)\n          : R.random(-0.2, 0.2);\n      const [min, max] = this.p.pressure.min_max;\n      this.min = min;\n      this.max = max;\n    }\n    // Blend Mode\n    this.c = _r.color(this.c);\n    // Select mask buffer for blend mode\n    this.mask = this.p.blend\n      ? this.p.type === \"image\"\n        ? Mix.masks[1]\n        : Mix.masks[0]\n      : Mix.masks[2];\n    Matrix.trans();\n    // Set the blender\n    this.mask.push();\n    this.mask.noStroke();\n    this.p.type === \"image\"\n      ? this.mask.translate(Matrix.translation[0], Matrix.translation[1])\n      : this.mask.translate(\n          Matrix.translation[0] + _r.width / 2,\n          Matrix.translation[1] + _r.height / 2\n        );\n    this.mask.rotate(-Matrix.rotation);\n    this.mask.scale(_curScale);\n    if (this.p.blend) {\n      Mix.watercolor = false;\n      if (this.p.type !== \"image\") Mix.blend(this.c);\n      else Mix.blend(this.c, false, true);\n      if (!isTip) this.markerTip();\n    }\n    this.alpha = this.calculateAlpha(); // Calcula Alpha\n    this.applyColor(this.alpha); // Apply Color\n  },\n\n  /**\n   * Restores the drawing state after a brush stroke is completed.\n   */\n  popState(isTip = false) {\n    if (this.p.blend && !isTip) this.markerTip();\n    this.mask.pop();\n  },\n\n  /**\n   * Draws the tip of the brush based on the current pressure and position.\n   * @param {number} pressure - The desired pressure value.\n   */\n  tip(custom_pressure = false) {\n    let pressure = custom_pressure ? custom_pressure : this.calculatePressure(); // Calculate Pressure\n    if (this.isInsideClippingArea()) {\n      // Check if it's inside clipping area\n      switch (\n        this.p.type // Draw different tip types\n      ) {\n        case \"spray\":\n          this.drawSpray(pressure);\n          break;\n        case \"marker\":\n          this.drawMarker(pressure);\n          break;\n        case \"custom\":\n        case \"image\":\n          this.drawCustomOrImage(pressure, this.alpha);\n          break;\n        default:\n          this.drawDefault(pressure);\n          break;\n      }\n    }\n  },\n\n  /**\n   * Calculates the pressure for the current position in the stroke.\n   * @returns {number} The calculated pressure value.\n   */\n  calculatePressure() {\n    return this.plot\n      ? this.simPressure() * this.plot.pressure(this.position.plotted)\n      : this.simPressure();\n  },\n\n  /**\n   * Simulates brush pressure based on the current position and brush parameters.\n   * @returns {number} The simulated pressure value.\n   */\n  simPressure() {\n    if (this.p.pressure.type === \"custom\") {\n      return R.map(\n        this.p.pressure.curve(this.position.plotted / this.length) + this.cp,\n        0,\n        1,\n        this.min,\n        this.max,\n        true\n      );\n    }\n    return this.gauss();\n  },\n\n  /**\n   * Generates a Gaussian distribution value for the pressure calculation.\n   * @param {number} a - Center of the Gaussian bell curve.\n   * @param {number} b - Width of the Gaussian bell curve.\n   * @param {number} c - Shape of the Gaussian bell curve.\n   * @param {number} min - Minimum pressure value.\n   * @param {number} max - Maximum pressure value.\n   * @returns {number} The calculated Gaussian value.\n   */\n  gauss(\n    a = 0.5 + B.p.pressure.curve[0] * B.a,\n    b = 1 - B.p.pressure.curve[1] * B.b,\n    c = B.cp,\n    min = B.min,\n    max = B.max\n  ) {\n    return R.map(\n      1 /\n        (1 +\n          Math.pow(\n            Math.abs(\n              (this.position.plotted - a * this.length) /\n                ((b * this.length) / 2)\n            ),\n            2 * c\n          )),\n      0,\n      1,\n      min,\n      max\n    );\n  },\n\n  /**\n   * Calculates the alpha (opacity) level for the brush stroke based on pressure.\n   * @param {number} pressure - The current pressure value.\n   * @returns {number} The calculated alpha value.\n   */\n  calculateAlpha() {\n    let opacity =\n      this.p.type !== \"default\" && this.p.type !== \"spray\"\n        ? this.p.opacity / this.w\n        : this.p.opacity;\n    return opacity;\n  },\n\n  /**\n   * Applies the current color and alpha to the renderer.\n   * @param {number} alpha - The alpha (opacity) level to apply.\n   */\n  applyColor(alpha) {\n    if (this.p.blend) {\n      this.mask.fill(255, 0, 0, alpha / 2);\n    } else {\n      this.c.setAlpha(alpha);\n      this.mask.fill(this.c);\n    }\n  },\n\n  /**\n   * Checks if the current brush position is inside the defined clipping area.\n   * @returns {boolean} True if the position is inside the clipping area, false otherwise.\n   */\n  isInsideClippingArea() {\n    if (B.cr)\n      return (\n        this.position.x >= B.cr[0] &&\n        this.position.x <= B.cr[2] &&\n        this.position.y >= B.cr[1] &&\n        this.position.y <= B.cr[3]\n      );\n    else {\n      let w = 0.55 * _r.width,\n        h = 0.55 * _r.height;\n      return (\n        this.position.x >= -w - Matrix.trans()[0] &&\n        this.position.x <= w - Matrix.trans()[0] &&\n        this.position.y >= -h - Matrix.trans()[1] &&\n        this.position.y <= h - Matrix.trans()[1]\n      );\n    }\n  },\n\n  /**\n   * Draws the spray tip of the brush.\n   * @param {number} pressure - The current pressure value.\n   */\n  drawSpray(pressure) {\n    let vibration =\n      this.w * this.p.vibration * pressure +\n      (this.w * R.gaussian() * this.p.vibration) / 3;\n    let sw = this.p.weight * R.random(0.9, 1.1);\n    const iterations = this.p.quality / pressure;\n    for (let j = 0; j < iterations; j++) {\n      let r = R.random(0.9, 1.1);\n      let rX = r * vibration * R.random(-1, 1);\n      let yRandomFactor = R.random(-1, 1);\n      let rVibrationSquared = Math.pow(r * vibration, 2);\n      let sqrtPart = Math.sqrt(rVibrationSquared - Math.pow(rX, 2));\n      this.mask.circle(\n        this.position.x + rX,\n        this.position.y + yRandomFactor * sqrtPart,\n        sw\n      );\n    }\n  },\n\n  /**\n   * Draws the marker tip of the brush.\n   * @param {number} pressure - The current pressure value.\n   * @param {boolean} [vibrate=true] - Whether to apply vibration effect.\n   */\n  drawMarker(pressure, vibrate = true) {\n    let vibration = vibrate ? this.w * this.p.vibration : 0;\n    let rx = vibrate ? vibration * R.random(-1, 1) : 0;\n    let ry = vibrate ? vibration * R.random(-1, 1) : 0;\n    this.mask.circle(\n      this.position.x + rx,\n      this.position.y + ry,\n      this.w * this.p.weight * pressure\n    );\n  },\n\n  /**\n   * Draws the custom or image tip of the brush.\n   * @param {number} pressure - The current pressure value.\n   * @param {number} alpha - The alpha (opacity) level to apply.\n   * @param {boolean} [vibrate=true] - Whether to apply vibration effect.\n   */\n  drawCustomOrImage(pressure, alpha, vibrate = true) {\n    this.mask.push();\n    let vibration = vibrate ? this.w * this.p.vibration : 0;\n    let rx = vibrate ? vibration * R.random(-1, 1) : 0;\n    let ry = vibrate ? vibration * R.random(-1, 1) : 0;\n    this.mask.translate(this.position.x + rx, this.position.y + ry);\n    this.adjustSizeAndRotation(this.w * pressure, alpha);\n    this.p.tip(this.mask);\n    this.mask.pop();\n  },\n\n  /**\n   * Draws the default tip of the brush.\n   * @param {number} pressure - The current pressure value.\n   */\n  drawDefault(pressure) {\n    let vibration =\n      this.w *\n      this.p.vibration *\n      (this.p.definition +\n        ((1 - this.p.definition) *\n          R.gaussian() *\n          this.gauss(0.5, 0.9, 5, 0.2, 1.2)) /\n          pressure);\n    if (R.random(0, this.p.quality * pressure) > 0.4) {\n      this.mask.circle(\n        this.position.x + 0.7 * vibration * R.random(-1, 1),\n        this.position.y + vibration * R.random(-1, 1),\n        pressure * this.p.weight * R.random(0.85, 1.15)\n      );\n    }\n  },\n\n  /**\n   * Adjusts the size and rotation of the brush tip before drawing.\n   * @param {number} pressure - The current pressure value.\n   * @param {number} alpha - The alpha (opacity) level to apply.\n   */\n  adjustSizeAndRotation(pressure, alpha) {\n    this.mask.scale(pressure);\n    if (this.p.type === \"image\")\n      this.p.blend\n        ? this.mask.tint(255, 0, 0, alpha / 2)\n        : this.mask.tint(\n            this.mask.red(this.c),\n            this.mask.green(this.c),\n            this.mask.blue(this.c),\n            alpha\n          );\n    if (this.p.rotate === \"random\") this.mask.rotate(R.randInt(0, 360));\n    else if (this.p.rotate === \"natural\") {\n      let angle =\n        (this.plot ? -this.plot.angle(this.position.plotted) : -this.dir) +\n        (this.flow ? this.position.angle() : 0);\n      this.mask.rotate(angle);\n    }\n  },\n\n  /**\n   * Draws the marker tip with a blend effect.\n   */\n  markerTip() {\n    if (this.isInsideClippingArea()) {\n      let pressure = this.calculatePressure();\n      let alpha = this.calculateAlpha(pressure);\n      this.mask.fill(255, 0, 0, alpha / 1.5);\n      if (B.p.type === \"marker\") {\n        for (let s = 1; s < 5; s++) {\n          this.drawMarker((pressure * s) / 5, false);\n        }\n      } else if (B.p.type === \"custom\" || B.p.type === \"image\") {\n        for (let s = 1; s < 5; s++) {\n          this.drawCustomOrImage((pressure * s) / 5, alpha, false);\n        }\n      }\n    }\n  },\n};\n\n/**\n * Adds a new brush with the specified parameters to the brush list.\n * @param {string} name - The unique name for the new brush.\n * @param {BrushParameters} params - The parameters defining the brush behavior and appearance.\n */\nexport function add(a, b) {\n  const isBlendableType =\n    b.type === \"marker\" || b.type === \"custom\" || b.type === \"image\";\n  if (!isBlendableType && b.type !== \"spray\") b.type = \"default\";\n  if (b.type === \"image\") {\n    T.add(b.image.src);\n    b.tip = () =>\n      B.mask.image(\n        T.tips.get(B.p.image.src),\n        -B.p.weight / 2,\n        -B.p.weight / 2,\n        B.p.weight,\n        B.p.weight\n      );\n  }\n  b.blend = (isBlendableType && b.blend !== false) || b.blend ? true : false;\n  B.list.set(a, { param: b, colors: [], buffers: [] });\n}\n\n/**\n * Sets the current brush with the specified name, color, and weight.\n * @param {string} brushName - The name of the brush to set as current.\n * @param {string|p5.Color} color - The color to set for the brush.\n * @param {number} weight - The weight (size) to set for the brush.\n */\nexport function set(brushName, color, weight = 1) {\n  pick(brushName);\n  B.c = color;\n  B.w = weight;\n  B.isActive = true;\n}\n\n/**\n * Sets only the current brush type based on the given name.\n * @param {string} brushName - The name of the brush to set as current.\n */\nexport function pick(brushName) {\n  B.name = brushName;\n}\n\n/**\n * Sets the color of the current brush.\n * @param {number|string|p5.Color} r - The red component of the color, a CSS color string, or a p5.Color object.\n * @param {number} [g] - The green component of the color.\n * @param {number} [b] - The blue component of the color.\n */\nexport function stroke(r, g, b) {\n  if (arguments.length > 0) B.c = arguments.length < 2 ? r : [r, g, b];\n  B.isActive = true;\n}\n\n/**\n * Sets the weight (size) of the current brush.\n * @param {number} weight - The weight to set for the brush.\n */\nexport function strokeWeight(weight) {\n  B.w = weight;\n}\n\n/**\n * Defines a clipping region for the brush strokes.\n * @param {number[]} clippingRegion - An array defining the clipping region as [x1, y1, x2, y2].\n */\nexport function clip(clippingRegion) {\n  B.cr = clippingRegion;\n}\n\n/**\n * Disables clipping region.\n */\nexport function noClip() {\n  B.cr = null;\n}\n\n/**\n * Draws a line using the current brush from (x1, y1) to (x2, y2).\n * @param {number} x1 - The x-coordinate of the start point.\n * @param {number} y1 - The y-coordinate of the start point.\n * @param {number} x2 - The x-coordinate of the end point.\n * @param {number} y2 - The y-coordinate of the end point.\n */\nexport function line(x1, y1, x2, y2) {\n  _ensureReady();\n  let d = R.dist(x1, y1, x2, y2);\n  if (d == 0) return;\n  B.initializeDrawingState(x1, y1, d, false, false);\n  let angle = _calculateAngle(x1, y1, x2, y2);\n  B.draw(angle, false);\n}\n\n/**\n * Draws a flow line with the current brush from a starting point in a specified direction.\n * @param {number} x - The x-coordinate of the starting point.\n * @param {number} y - The y-coordinate of the starting point.\n * @param {number} length - The length of the line to draw.\n * @param {number} dir - The direction in which to draw the line. Angles measured anticlockwise from the x-axis\n */\nexport function flowLine(x, y, length, dir) {\n  _ensureReady();\n  B.initializeDrawingState(x, y, length, true, false);\n  B.draw(R.toDegrees(dir), false);\n}\n\n/**\n * Draws a predefined shape/plot with a flowing brush stroke.\n * @param {Object} p - An object representing the shape to draw.\n * @param {number} x - The x-coordinate of the starting position to draw the shape.\n * @param {number} y - The y-coordinate of the starting position to draw the shape.\n * @param {number} scale - The scale at which to draw the shape.\n */\nexport function plot(p, x, y, scale) {\n  _ensureReady();\n  B.initializeDrawingState(x, y, p.length, true, p);\n  B.draw(scale, true);\n}\n\n// =============================================================================\n// Section: Loading Custom Image Tips\n// =============================================================================\n/**\n * This section defines the functionality for managing the loading and processing of image tips.\n * Images are loaded from specified source URLs, converted to a white tint for visual effects,\n * and then stored for future use. It includes methods to add new images, convert their color\n * scheme, and integrate them into the p5.js graphics library.\n */\n\n/**\n * A utility object for loading images, converting them to a red tint, and managing their states.\n */\nconst T = {\n  tips: new Map(),\n\n  /**\n   * Adds an image to the tips Map and sets up loading and processing.\n   *\n   * @param {string} src - The source URL of the image to be added and processed.\n   */\n  add(src) {\n    // Initially set the source as not processed\n    this.tips.set(src, false);\n  },\n\n  /**\n   * Converts the given image to a white tint by setting all color channels to white and adjusting the alpha channel.\n   *\n   * @param {Image} image - The image to be converted.\n   */\n  imageToWhite(image) {\n    image.loadPixels();\n    // Modify the image data to create a white tint effect\n    for (let i = 0; i < 4 * image.width * image.height; i += 4) {\n      // Calculate the average for the grayscale value\n      let average =\n        (image.pixels[i] + image.pixels[i + 1] + image.pixels[i + 2]) / 3;\n      // Set all color channels to white\n      image.pixels[i] = image.pixels[i + 1] = image.pixels[i + 2] = 255;\n      // Adjust the alpha channel to the inverse of the average, creating the white tint effect\n      image.pixels[i + 3] = 255 - average;\n    }\n    image.updatePixels();\n  },\n  /**\n   * Loads all processed images into the p5.js environment.\n   * If no images are in the tips Map, logs a warning message.\n   */\n  load() {\n    for (let key of this.tips.keys()) {\n      let _r = _isInstanced ? _inst : window.self;\n      let image = _r.loadImage(key, () => T.imageToWhite(image));\n      this.tips.set(key, image);\n    }\n  },\n};\n\n// =============================================================================\n// Section: Hatching\n// =============================================================================\n/**\n * The Hatching section of the code is responsible for creating and drawing hatching patterns.\n * Hatching involves drawing closely spaced parallel lines.\n */\n\n/**\n * Activates hatching for subsequent geometries, with the given params.\n * @param {number} dist - The distance between hatching lines.\n * @param {number} angle - The angle at which hatching lines are drawn.\n * @param {Object} options - An object containing optional parameters to affect the hatching style:\n *                           - rand: Introduces randomness to the line placement.\n *                           - continuous: Connects the end of a line with the start of the next.\n *                           - gradient: Changes the distance between lines to create a gradient effect.\n *                           Defaults to {rand: false, continuous: false, gradient: false}.\n */\nexport function hatch(\n  dist = 5,\n  angle = 45,\n  options = { rand: false, continuous: false, gradient: false }\n) {\n  H.isActive = true;\n  H.hatchingParams = [dist, angle, options];\n}\n\n/**\n * Sets the brush type, color, and weight for subsequent hatches.\n * If this function is not called, hatches will use the parameters from stroke operations.\n * @param {string} brushName - The name of the brush to set as current.\n * @param {string|p5.Color} color - The color to set for the brush.\n * @param {number} weight - The weight (size) to set for the brush.\n */\nexport function setHatch(brush, color = \"black\", weight = 1) {\n  H.hatchingBrush = [brush, color, weight];\n}\n\n/**\n * Disables hatching for subsequent shapes\n */\nexport function noHatch() {\n  H.isActive = false;\n  H.hatchingBrush = false;\n}\n\n/**\n * Object to hold the current hatch state and to perform hatch calculation\n */\nconst H = {\n  isActive: false,\n  hatchingParams: [5, 45, {}],\n  hatchingBrush: false,\n\n  /**\n   * Creates a hatching pattern across the given polygons.\n   *\n   * @param {Array|Object} polygons - A single polygon or an array of polygons to apply the hatching.\n   */\n  hatch(polygons) {\n    let dist = H.hatchingParams[0];\n    let angle = H.hatchingParams[1];\n    let options = H.hatchingParams[2];\n\n    // Save current stroke state\n    let strokeColor = B.c,\n      strokeBrush = B.name,\n      strokeWeight = B.w,\n      strokeActive = B.isActive;\n    // Change state if hatch has been set to different params than stroke\n    if (H.hatchingBrush)\n      set(H.hatchingBrush[0], H.hatchingBrush[1], H.hatchingBrush[2]);\n\n    // Transform to degrees and between 0-180\n    angle = R.toDegrees(angle) % 180;\n\n    // Calculate the bounding area of the provided polygons\n    let minX = Infinity,\n      maxX = -Infinity,\n      minY = Infinity,\n      maxY = -Infinity;\n    let processPolygonPoints = (p) => {\n      for (let a of p.a) {\n        // (process points of a single polygon to find bounding area)\n        minX = a[0] < minX ? a[0] : minX;\n        maxX = a[0] > maxX ? a[0] : maxX;\n        minY = a[1] < minY ? a[1] : minY;\n        maxY = a[1] > maxY ? a[1] : maxY;\n      }\n    };\n\n    // Ensure polygons is an array and find overall bounding area\n    if (!Array.isArray(polygons)) {\n      polygons = [polygons];\n    }\n    for (let p of polygons) {\n      processPolygonPoints(p);\n    }\n\n    // Create a bounding polygon\n    let ventana = new Polygon([\n      [minX, minY],\n      [maxX, minY],\n      [maxX, maxY],\n      [minX, maxY],\n    ]);\n\n    // Set initial values for line generation\n    let startY = angle <= 90 && angle >= 0 ? minY : maxY;\n    let gradient = options.gradient\n      ? R.map(options.gradient, 0, 1, 1, 1.1, true)\n      : 1;\n    let dots = [];\n    let i = 0;\n    let dist1 = dist;\n    let linea = (i) => {\n      return {\n        point1: {\n          x: minX + dist1 * i * R.cos(-angle + 90),\n          y: startY + dist1 * i * R.sin(-angle + 90),\n        },\n        point2: {\n          x: minX + dist1 * i * R.cos(-angle + 90) + R.cos(-angle),\n          y: startY + dist1 * i * R.sin(-angle + 90) + R.sin(-angle),\n        },\n      };\n    };\n\n    // Generate lines and calculate intersections with polygons\n    // Loop through the lines based on the distance and angle to calculate intersections with the polygons\n    // The loop continues until a line does not intersect with the bounding window polygon\n    // Each iteration accounts for the gradient effect by adjusting the distance between lines\n    while (ventana.intersect(linea(i)).length > 0) {\n      let tempArray = [];\n      for (let p of polygons) {\n        tempArray.push(p.intersect(linea(i)));\n      }\n      dots[i] = tempArray\n        .flat()\n        .sort((a, b) => (a.x === b.x ? a.y - b.y : a.x - b.x));\n      dist1 *= gradient;\n      i++;\n    }\n\n    // Filter out empty arrays to avoid drawing unnecessary lines\n    let gdots = [];\n    for (let dd of dots) {\n      if (typeof dd[0] !== \"undefined\") {\n        gdots.push(dd);\n      }\n    }\n\n    // Draw the hatching lines using the calculated intersections\n    // If the 'rand' option is enabled, add randomness to the start and end points of the lines\n    // If the 'continuous' option is set, connect the end of one line to the start of the next\n    let r = options.rand ? options.rand : 0;\n    for (let j = 0; j < gdots.length; j++) {\n      let dd = gdots[j];\n      let shouldDrawContinuousLine = j > 0 && options.continuous;\n      for (let i = 0; i < dd.length - 1; i += 2) {\n        if (r !== 0) {\n          dd[i].x += r * dist * R.random(-10, 10);\n          dd[i].y += r * dist * R.random(-10, 10);\n          dd[i + 1].x += r * dist * R.random(-10, 10);\n          dd[i + 1].y += r * dist * R.random(-10, 10);\n        }\n        line(dd[i].x, dd[i].y, dd[i + 1].x, dd[i + 1].y);\n        if (shouldDrawContinuousLine) {\n          line(gdots[j - 1][1].x, gdots[j - 1][1].y, dd[i].x, dd[i].y);\n        }\n      }\n    }\n\n    // Change state back to previous\n    set(strokeBrush, strokeColor, strokeWeight);\n    B.isActive = strokeActive;\n  },\n};\n\nexport const hatchArray = H.hatch;\n\n// =============================================================================\n// Section: Polygon management. Basic geometries\n// =============================================================================\n/**\n * This section includes the Polygon class for managing polygons and functions for drawing basic geometries\n * like rectangles and circles. It provides methods for creating, intersecting, drawing, and filling polygons,\n * as well as hatching them with a given distance and angle. Additional functions leverage the Polygon class\n * to draw rectangles with options for randomness and different drawing modes.\n */\n\n/**\n * Represents a polygon with a set of vertices.\n */\nexport class Polygon {\n  /**\n   * Constructs the Polygon object from an array of points.\n   *\n   * @param {Array} pointsArray - An array of points, where each point is an array of two numbers [x, y].\n   */\n  constructor(array, bool = false) {\n    this.a = array;\n    this.vertices = array.map((a) => ({ x: a[0], y: a[1] }));\n    if (bool) this.vertices = array;\n    this.sides = this.vertices.map((v, i, arr) => [\n      v,\n      arr[(i + 1) % arr.length],\n    ]);\n  }\n  /**\n   * Intersects a given line with the polygon, returning all intersection points.\n   *\n   * @param {Object} line - The line to intersect with the polygon, having two properties 'point1' and 'point2'.\n   * @returns {Array} An array of intersection points (each with 'x' and 'y' properties) or an empty array if no intersections.\n   */\n  intersect(line) {\n    // Check if the result has been cached\n    let cacheKey = `${line.point1.x},${line.point1.y}-${line.point2.x},${line.point2.y}`;\n    if (this._intersectionCache && this._intersectionCache[cacheKey]) {\n      return this._intersectionCache[cacheKey];\n    }\n    let points = [];\n    for (let s of this.sides) {\n      let intersection = _intersectLines(line.point1, line.point2, s[0], s[1]);\n      if (intersection !== false) {\n        points.push(intersection);\n      }\n    }\n    // Cache the result\n    if (!this._intersectionCache) this._intersectionCache = {};\n    this._intersectionCache[cacheKey] = points;\n\n    return points;\n  }\n  /**\n   * Draws the polygon by iterating over its sides and drawing lines between the vertices.\n   */\n  draw(_brush = false, _color, _weight) {\n    let curState = B.isActive;\n    if (_brush) set(_brush, _color, _weight);\n    if (B.isActive) {\n      _ensureReady();\n      for (let s of this.sides) {\n        line(s[0].x, s[0].y, s[1].x, s[1].y);\n      }\n    }\n    B.isActive = curState;\n  }\n  /**\n   * Fills the polygon using the current fill state.\n   */\n  fill(_color = false, _opacity, _bleed, _texture, _border, _direction) {\n    let curState = F.isActive;\n    if (_color) {\n      fill(_color, _opacity);\n      bleed(_bleed, _direction);\n      fillTexture(_texture, _border);\n    }\n    if (F.isActive) {\n      _ensureReady();\n      F.fill(this);\n    }\n    F.isActive = curState;\n  }\n  /**\n   * Creates hatch lines across the polygon based on a given distance and angle.\n   */\n  hatch(_dist = false, _angle, _options) {\n    let curState = H.isActive;\n    if (_dist) hatch(_dist, _angle, _options);\n    if (H.isActive) {\n      _ensureReady();\n      H.hatch(this);\n    }\n    H.isActive = curState;\n  }\n\n  erase(c = false, a = E.a) {\n    if (E.isActive || c) {\n      Mix.masks[2].push();\n      Mix.masks[2].noStroke();\n      let ccc = _r.color(c ? c : E.c);\n      ccc.setAlpha(a);\n      Mix.masks[2].fill(ccc);\n      Mix.masks[2].beginShape();\n      for (let p of this.vertices) {\n        Mix.masks[2].vertex(p.x, p.y);\n      }\n      Mix.masks[2].endShape(_r.CLOSE);\n      Mix.masks[2].pop();\n    }\n  }\n\n  show() {\n    this.fill();\n    this.hatch();\n    this.draw();\n    this.erase();\n  }\n}\n\n/**\n * Creates a Polygon from a given array of points and performs drawing and filling\n * operations based on active states.\n *\n * @param {Array} pointsArray - An array of points where each point is an array of two numbers [x, y].\n */\nexport function polygon(pointsArray) {\n  // Create a new Polygon instance\n  let polygon = new Polygon(pointsArray);\n  polygon.show();\n}\n\n/**\n * Draws a rectangle on the canvas and fills it with the current fill color.\n *\n * @param {number} x - The x-coordinate of the rectangle.\n * @param {number} y - The y-coordinate of the rectangle.\n * @param {number} w - The width of the rectangle.\n * @param {number} h - The height of the rectangle.\n * @param {boolean} [mode=CORNER] - If CENTER, the rectangle is drawn centered at (x, y).\n */\nexport function rect(x, y, w, h, mode = _r.CORNER) {\n  if (mode == _r.CENTER) (x = x - w / 2), (y = y - h / 2);\n  if (FF.isActive) {\n    beginShape(0);\n    vertex(x, y);\n    vertex(x + w, y);\n    vertex(x + w, y + h);\n    vertex(x, y + h);\n    endShape(_r.CLOSE);\n  } else {\n    let p = new Polygon([\n      [x, y],\n      [x + w, y],\n      [x + w, y + h],\n      [x, y + h],\n    ]);\n    p.show();\n  }\n}\n\n// =============================================================================\n// Section: Shape, Stroke, and Spline. Plot System\n// =============================================================================\n/**\n * This section defines the functionality for creating and managing plots, which are used to draw complex shapes,\n * strokes, and splines on a canvas. It includes classes and functions to create plots of type \"curve\" or \"segments\",\n * manipulate them with operations like adding segments and applying rotations, and render them as visual elements\n * like polygons or strokes. The spline functionality allows for smooth curve creation using control points with\n * specified curvature, which can be rendered directly or used as part of more complex drawings.\n */\n\n/**\n * The Plot class is central to the plot system, serving as a blueprint for creating and manipulating a variety\n * of shapes and paths. It manages a collection of segments, each defined by an angle, length, and pressure,\n * allowing for intricate designs such as curves and custom strokes. Plot instances can be transformed by rotation,\n * and their visual representation can be controlled through pressure and angle calculations along their length.\n */\nexport class Plot {\n  /**\n   * Creates a new Plot.\n   * @param {string} _type - The type of plot, \"curve\" or \"segments\"\n   */\n  constructor(_type) {\n    (this.segments = []), (this.angles = []), (this.pres = []);\n    this.type = _type;\n    this.dir = 0;\n    this.calcIndex(0);\n    this.pol = false;\n  }\n\n  /**\n   * Adds a segment to the plot with specified angle, length, and pressure.\n   * @param {number} _a - The angle of the segment.\n   * @param {number} _length - The length of the segment.\n   * @param {number} _pres - The pressure of the segment.\n   * @param {boolean} _degrees - Whether the angle is in degrees.\n   */\n  addSegment(_a = 0, _length = 0, _pres = 1, _degrees = false) {\n    // Remove the last angle if the angles array is not empty\n    if (this.angles.length > 0) {\n      this.angles.splice(-1);\n    }\n    // Convert to degrees and normalize between 0 and 360 degrees\n    _a = _degrees ? ((_a % 360) + 360) % 360 : R.toDegrees(_a);\n    // Store the angle, pressure, and segment length\n    this.angles.push(_a);\n    this.pres.push(_pres);\n    this.segments.push(_length);\n    // Calculate the total length of the plot\n    this.length = this.segments.reduce((partialSum, a) => partialSum + a, 0);\n    // Push the angle again to prepare for the next segment\n    this.angles.push(_a);\n  }\n\n  /**\n   * Finalizes the plot by setting the last angle and pressure.\n   * @param {number} _a - The final angle of the plot.\n   * @param {number} _pres - The final pressure of the plot.\n   * @param {boolean} _degrees - Whether the angle is in degrees.\n   */\n  endPlot(_a = 0, _pres = 1, _degrees = false) {\n    // Convert angle to degrees if necessary\n    _a = _degrees ? ((_a % 360) + 360) % 360 : R.toDegrees(_a);\n    // Replace the last angle with the final angle\n    this.angles.splice(-1);\n    this.angles.push(_a);\n    // Store the final pressure\n    this.pres.push(_pres);\n  }\n\n  /**\n   * Rotates the entire plot by a given angle.\n   * @param {number} _a - The angle to rotate the plot.\n   */\n  rotate(_a) {\n    this.dir = R.toDegrees(_a);\n  }\n\n  /**\n   * Calculates the pressure at a given distance along the plot.\n   * @param {number} _d - The distance along the plot.\n   * @returns {number} - The calculated pressure.\n   */\n  pressure(_d) {\n    // If the distance exceeds the plot length, return the last pressure\n    if (_d > this.length) return this.pres[this.pres.length - 1];\n    // Otherwise, calculate the pressure using the curving function\n    return this.curving(this.pres, _d);\n  }\n\n  /**\n   * Calculates the angle at a given distance along the plot.\n   * @param {number} _d - The distance along the plot.\n   * @returns {number} - The calculated angle.\n   */\n  angle(_d) {\n    // If the distance exceeds the plot length, return the last angle\n    if (_d > this.length) return this.angles[this.angles.length - 1];\n    // Calculate the index for the given distance\n    this.calcIndex(_d);\n    // Return the angle, adjusted for the plot type and direction\n    return this.type === \"curve\"\n      ? this.curving(this.angles, _d) + this.dir\n      : this.angles[this.index] + this.dir;\n  }\n\n  /**\n   * Interpolates values between segments for smooth transitions.\n   * @param {Array<number>} array - The array to interpolate within.\n   * @param {number} _d - The distance along the plot.\n   * @returns {number} - The interpolated value.\n   */\n  curving(array, _d) {\n    let map0 = array[this.index];\n    let map1 = array[this.index + 1];\n    if (typeof map1 == \"undefined\") {\n      map1 = map0;\n    }\n    if (Math.abs(map1 - map0) > 180) {\n      if (map1 > map0) {\n        map1 = -(360 - map1);\n      } else {\n        map0 = -(360 - map0);\n      }\n    }\n    return R.map(\n      _d - this.suma,\n      0,\n      this.segments[this.index],\n      map0,\n      map1,\n      true\n    );\n  }\n\n  /**\n   * Calculates the current index of the plot based on the distance.\n   * @param {number} _d - The distance along the plot.\n   */\n  calcIndex(_d) {\n    (this.index = -1), (this.suma = 0);\n    let d = 0;\n    while (d <= _d) {\n      this.suma = d;\n      d += this.segments[this.index + 1];\n      this.index++;\n    }\n    return this.index;\n  }\n\n  /**\n   * Generates a polygon based on the plot.\n   * @param {number} _x - The x-coordinate for the starting point of the polygon.\n   * @param {number} _y - The y-coordinate for the starting point of the polygon.\n   * @returns {Polygon} - The generated polygon.\n   */\n  genPol(_x, _y, _scale = 1, isHatch = false) {\n    _ensureReady(); // Ensure that the drawing environment is prepared\n    const step = 0.5;\n    const vertices = [];\n    const numSteps = Math.round(this.length / step);\n    const pos = new Position(_x, _y);\n    let side = isHatch ? 0.15 : F.bleed_strength * 3;\n    let pside = 0;\n    let prevIdx = 0;\n    for (let i = 0; i < numSteps; i++) {\n      pos.plotTo(this, step, step, 1);\n      let idx = this.calcIndex(pos.plotted);\n      pside += step;\n      if (\n        (pside >= this.segments[idx] * side * R.random(0.7, 1.3) ||\n          idx >= prevIdx) &&\n        pos.x\n      ) {\n        vertices.push([pos.x, pos.y]);\n        pside = 0;\n        if (idx >= prevIdx) prevIdx++;\n      }\n    }\n    return new Polygon(vertices);\n  }\n\n  /**\n   * Draws the plot on the canvas.\n   * @param {number} x - The x-coordinate to draw at.\n   * @param {number} y - The y-coordinate to draw at.\n   * @param {number} scale - The scale to draw with.\n   */\n  draw(x, y, scale) {\n    if (B.isActive) {\n      _ensureReady(); // Ensure that the drawing environment is prepared\n      if (this.origin) (x = this.origin[0]), (y = this.origin[1]), (scale = 1);\n      plot(this, x, y, scale);\n    }\n  }\n\n  /**\n   * Fill the plot on the canvas.\n   * @param {number} x - The x-coordinate to draw at.\n   * @param {number} y - The y-coordinate to draw at.\n   */\n  fill(x, y, scale) {\n    if (F.isActive) {\n      _ensureReady(); // Ensure that the drawing environment is prepared\n      if (this.origin) (x = this.origin[0]), (y = this.origin[1]), (scale = 1);\n      this.pol = this.genPol(x, y, scale);\n      this.pol.fill();\n    }\n  }\n\n  /**\n   * Hatch the plot on the canvas.\n   * @param {number} x - The x-coordinate to draw at.\n   * @param {number} y - The y-coordinate to draw at.\n   */\n  hatch(x, y, scale) {\n    if (H.isActive) {\n      _ensureReady(); // Ensure that the drawing environment is prepared\n      if (this.origin) (x = this.origin[0]), (y = this.origin[1]), (scale = 1);\n      this.pol = this.genPol(x, y, scale, true);\n      this.pol.hatch();\n    }\n  }\n\n  erase(x, y, scale) {\n    if (E.isActive) {\n      if (this.origin) (x = this.origin[0]), (y = this.origin[1]), (scale = 1);\n      this.pol = this.genPol(x, y, scale, true);\n      Mix.masks[2].push();\n      Mix.masks[2].noStroke();\n      let ccc = _r.color(E.c);\n      ccc.setAlpha(E.a);\n      Mix.masks[2].fill(ccc);\n      Mix.masks[2].beginShape();\n      for (let p of this.pol.vertices) {\n        Mix.masks[2].vertex(p.x, p.y);\n      }\n      Mix.masks[2].endShape(_r.CLOSE);\n      Mix.masks[2].pop();\n    }\n  }\n\n  show(x, y, scale = 1) {\n    this.draw(x, y, scale);\n    this.fill(x, y, scale);\n    this.hatch(x, y, scale);\n    this.erase(x, y, scale);\n  }\n}\n\n/**\n * Draws a circle on the canvas and fills it with the current fill color.\n *\n * @param {number} x - The x-coordinate of the center of the circle.\n * @param {number} y - The y-coordinate of the center of the circle.\n * @param {number} radius - The radius of the circle.\n * @param {boolean} [r=false] - If true, applies a random factor to the radius for each segment.\n */\nexport function circle(x, y, radius, r = false) {\n  _ensureReady();\n  // Create a new Plot instance for a curve shape\n  let p = new Plot(\"curve\");\n  // Calculate the length of the arc for each quarter of the circle\n  let l = (Math.PI * radius) / 2;\n  // Initialize the angle for the drawing segments\n  let angle = R.random(0, 360);\n  // Define a function to optionally add randomness to the segment length\n  let rr = () => (r ? R.random(-1, 1) : 0);\n  // Add segments for each quarter of the circle with optional randomness\n  p.addSegment(0 + angle + rr(), l + rr(), 1, true);\n  p.addSegment(-90 + angle + rr(), l + rr(), 1, true);\n  p.addSegment(-180 + angle + rr(), l + rr(), 1, true);\n  p.addSegment(-270 + angle + rr(), l + rr(), 1, true);\n  // Optionally add a random final angle for the last segment\n  let angle2 = r ? R.randInt(-5, 5) : 0;\n  if (r) p.addSegment(0 + angle, angle2 * (Math.PI / 180) * radius, true);\n  // Finalize the plot\n  p.endPlot(angle2 + angle, 1, true);\n  // Fill / hatch / draw\n  let o = [x - radius * R.sin(angle), y - radius * R.cos(-angle)];\n  p.show(o[0], o[1], 1);\n}\n\nexport function arc(x, y, radius, start, end) {\n  _ensureReady();\n  // Create a new Plot instance for a curve shape\n  let p = new Plot(\"curve\");\n  // Calculate start angle and end angle\n  let a1 = 270 - R.toDegrees(start),\n    a2 = 270 - R.toDegrees(end);\n  // Calculate length arc\n  let arcAngle = R.toDegrees(end - start);\n  let l = (Math.PI * radius * arcAngle) / 180;\n  // Add segments to plot\n  p.addSegment(a1, l, 1, true);\n  p.endPlot(a2, 1, true);\n  // Draw from starting point\n  p.draw(x + radius * R.cos(-a1 - 90), y + radius * R.sin(-a1 - 90), 1);\n}\n\n// Holds the array of vertices for the custom shape being defined. Each vertex includes position and optional pressure.\nlet _strokeArray = false;\n// Holds options for the stroke, such as curvature, that can influence the shape's rendering.\nlet _strokeOption;\n\n/**\n * Starts recording vertices for a custom shape. Optionally, a curvature can be defined.\n * @param {number} [curvature] - From 0 to 1. Defines the curvature for the vertices being recorded (optional).\n */\nexport function beginShape(curvature = 0) {\n  _strokeOption = R.constrain(curvature, 0, 1); // Set the curvature option for the shape\n  _strokeArray = []; // Initialize the array to store vertices\n}\n\n/**\n * Records a vertex in the custom shape being defined between beginShape and endShape.\n * @param {number} x - The x-coordinate of the vertex.\n * @param {number} y - The y-coordinate of the vertex.\n * @param {number} [pressure] - The pressure at the vertex (optional).\n */\nexport function vertex(x, y, pressure) {\n  _strokeArray.push([x, y, pressure]); // Add the vertex to the array\n}\n\n/**\n * Finishes recording vertices for a custom shape and either closes it or leaves it open.\n * It also triggers the drawing of the shape with the active stroke(), fill() and hatch() states.\n * @param {string} [a] - An optional argument to close the shape if set to _r.CLOSE.\n */\nexport function endShape(a) {\n  _ensureReady();\n  if (a === _r.CLOSE) {\n    _strokeArray.push(_strokeArray[0]); // Close the shape by connecting the last vertex to the first\n    _strokeArray.push(_strokeArray[1]);\n  }\n  // Create a new Plot with the recorded vertices and curvature option\n  let plot =\n    _strokeOption == 0 && !FF.isActive\n      ? new Polygon(_strokeArray)\n      : _createSpline(\n          _strokeArray,\n          _strokeOption,\n          a === _r.CLOSE ? true : false\n        );\n  plot.show();\n  _strokeArray = false; // Clear the array after the shape has been drawn\n}\n\n/**\n * Begins a new stroke with a given type and starting position. This initializes\n * a new Plot to record the stroke's path.\n * @param {string} type - The type of the stroke, which defines the kind of Plot to create.\n * @param {number} x - The x-coordinate of the starting point of the stroke.\n * @param {number} y - The y-coordinate of the starting point of the stroke.\n */\nexport function beginStroke(type, x, y) {\n  _strokeOption = [x, y]; // Store the starting position for later use\n  _strokeArray = new Plot(type); // Initialize a new Plot with the specified type\n}\n\n/**\n * Adds a segment to the stroke with a given angle, length, and pressure. This function\n * is called between beginStroke and endStroke to define the stroke's path.\n * @param {number} angle - The initial angle of the segment, relative to the canvas.\n * @param {number} length - The length of the segment.\n * @param {number} pressure - The pressure at the start of the segment, affecting properties like width.\n */\nexport function segment(angle, length, pressure) {\n  _strokeArray.addSegment(angle, length, pressure); // Add the new segment to the Plot\n}\n\n/**\n * Completes the stroke path and triggers the rendering of the stroke.\n * @param {number} angle - The angle of the curve at the last point of the stroke path.\n * @param {number} pressure - The pressure at the end of the stroke.\n */\nexport function endStroke(angle, pressure) {\n  _strokeArray.endPlot(angle, pressure); // Finalize the Plot with the end angle and pressure\n  _strokeArray.draw(_strokeOption[0], _strokeOption[1], 1); // Draw the stroke using the stored starting position\n  _strokeArray = false; // Clear the _strokeArray to indicate the end of this stroke\n}\n\n/**\n * Creates a new Plot object.\n * @param {Array<Array<number>>} array_points - An array of points defining the spline curve.\n * @param {number} [curvature=0.5] - The curvature of the spline curve, beterrn 0 and 1. A curvature of 0 will create a series of straight segments.\n */\nfunction _createSpline(array_points, curvature = 0.5, _close = false) {\n  // Initialize the plot type based on curvature\n  let plotType = curvature === 0 ? \"segments\" : \"curve\";\n  let p = new Plot(plotType);\n\n  // Proceed only if there are points provided\n  if (array_points && array_points.length > 0) {\n    // Add each segment to the plot\n    let done = 0;\n    let pep, tep, pep2;\n    for (let i = 0; i < array_points.length - 1; i++) {\n      if (curvature > 0 && i < array_points.length - 2) {\n        // Get the current and next points\n        let p1 = array_points[i],\n          p2 = array_points[i + 1],\n          p3 = array_points[i + 2];\n        // Calculate distances and angles between points\n        let d1 = R.dist(p1[0], p1[1], p2[0], p2[1]),\n          d2 = R.dist(p2[0], p2[1], p3[0], p3[1]);\n        let a1 = _calculateAngle(p1[0], p1[1], p2[0], p2[1]),\n          a2 = _calculateAngle(p2[0], p2[1], p3[0], p3[1]);\n        // Calculate curvature based on the minimum distance\n        let dd = curvature * Math.min(Math.min(d1, d2), 0.5 * Math.min(d1, d2)),\n          dmax = Math.max(d1, d2);\n        let s1 = d1 - dd,\n          s2 = d2 - dd;\n        // If the angles are approximately the same, create a straight segment\n        if (Math.floor(a1) === Math.floor(a2)) {\n          let temp = _close ? (i === 0 ? 0 : d1 - done) : d1 - done;\n          let temp2 = _close ? (i === 0 ? 0 : d2 - pep2) : d2;\n          p.addSegment(a1, temp, p1[2], true);\n          if (i === array_points.length - 3)\n            p.addSegment(a2, temp2, p2[2], true);\n          done = 0;\n          if (i === 0)\n            (pep = d1), (pep2 = dd), (tep = array_points[1]), (done = 0);\n        } else {\n          // If the angles are not the same, create curves, etc (this is a too complex...)\n          let point1 = {\n            x: p2[0] - dd * R.cos(-a1),\n            y: p2[1] - dd * R.sin(-a1),\n          };\n          let point2 = {\n            x: point1.x + dmax * R.cos(-a1 + 90),\n            y: point1.y + dmax * R.sin(-a1 + 90),\n          };\n          let point3 = {\n            x: p2[0] + dd * R.cos(-a2),\n            y: p2[1] + dd * R.sin(-a2),\n          };\n          let point4 = {\n            x: point3.x + dmax * R.cos(-a2 + 90),\n            y: point3.y + dmax * R.sin(-a2 + 90),\n          };\n          let int = _intersectLines(point1, point2, point3, point4, true);\n          let radius = R.dist(point1.x, point1.y, int.x, int.y);\n          let disti = R.dist(point1.x, point1.y, point3.x, point3.y) / 2;\n          let a3 = 2 * Math.asin(disti / radius) * (180 / Math.PI);\n          let s3 = (2 * Math.PI * radius * a3) / 360;\n          let temp = _close ? (i === 0 ? 0 : s1 - done) : s1 - done;\n          let temp2 =\n            i === array_points.length - 3 ? (_close ? pep - dd : s2) : 0;\n          p.addSegment(a1, temp, p1[2], true);\n          p.addSegment(a1, isNaN(s3) ? 0 : s3, p1[2], true);\n          p.addSegment(a2, temp2, p2[2], true);\n          done = dd;\n          if (i === 0) (pep = s1), (pep2 = dd), (tep = [point1.x, point1.y]);\n        }\n        if (i == array_points.length - 3) {\n          p.endPlot(a2, p2[2], true);\n        }\n      } else if (curvature === 0) {\n        // If curvature is 0, simply create segments\n        if (i === 0 && _close) array_points.pop();\n        let p1 = array_points[i],\n          p2 = array_points[i + 1];\n        let d = R.dist(p1[0], p1[1], p2[0], p2[1]);\n        let a = _calculateAngle(p1[0], p1[1], p2[0], p2[1]);\n        p.addSegment(a, d, 1, true);\n        if (i == array_points.length - 2) {\n          p.endPlot(a, 1, true);\n        }\n      }\n    }\n    // Set the origin point from the first point in the array\n    p.origin = _close && curvature !== 0 ? tep : array_points[0];\n  }\n  return p;\n}\n\n/**\n * Creates and draws a spline curve with the given points and curvature.\n * @param {Array<Array<number>>} array_points - An array of points defining the spline curve.\n * @param {number} [curvature=0.5] - The curvature of the spline curve, between 0 and 1. A curvature of 0 will create a series of straight segments.\n */\nexport function spline(array_points, curvature = 0.5) {\n  let p = _createSpline(array_points, curvature); // Create a new Plot-spline instance\n  p.draw(); // Draw the Plot\n}\n\n// =============================================================================\n// Section: Fill Management\n// =============================================================================\n/**\n * The Fill Management section contains functions and classes dedicated to handling\n * the fill properties of shapes within the drawing context. It supports complex fill\n * operations with effects such as bleeding to simulate watercolor-like textures. The\n * methods provided allow for setting the fill color with opacity, controlling the\n * intensity of the bleed effect, and enabling or disabling the fill operation.\n *\n * The watercolor effect implementation is inspired by Tyler Hobbs' generative art\n * techniques for simulating watercolor paints.\n */\n\n// No docs for now\nconst E = {};\nexport function erase(color = \"white\", alpha = 255) {\n  E.isActive = true;\n  E.c = color;\n  E.a = alpha;\n}\nexport function noErase() {\n  E.isActive = false;\n}\n\n/**\n * Sets the fill color and opacity for subsequent drawing operations.\n * @param {number|p5.Color} a - The red component of the color or grayscale value, a CSS color string, or a p5.Color object.\n * @param {number} [b] - The green component of the color or the grayscale opacity if two arguments.\n * @param {number} [c] - The blue component of the color.\n * @param {number} [d] - The opacity of the color.\n */\nexport function fill(a, b, c, d) {\n  _ensureReady();\n  F.opacity = arguments.length < 4 ? (arguments.length < 3 ? b : 1) : d;\n  F.color = arguments.length < 3 ? _r.color(a) : _r.color(a, b, c);\n  F.isActive = true;\n}\n\n/**\n * Sets the bleed and texture levels for the fill operation, simulating a watercolor effect.\n * @param {number} _i - The intensity of the bleed effect, capped at 0.5.\n * @param {number} _texture - The texture of the watercolor effect, from 0 to 1.\n */\nexport function bleed(_i, _direction = \"out\") {\n  _ensureReady();\n  F.bleed_strength = R.constrain(_i, 0, 0.6);\n  F.direction = _direction;\n}\n\nexport function fillTexture(_texture = 0.4, _border = 0.4) {\n  _ensureReady();\n  F.texture_strength = R.constrain(_texture, 0, 1);\n  F.border_strength = R.constrain(_border, 0, 1);\n}\n\nexport function gravity(x, y) {\n  _ensureReady();\n  F.light_source = { x: x, y: y };\n}\nexport function noGravity() {\n  F.light_source = false;\n}\n\n/**\n * Disables the fill for subsequent drawing operations.\n */\nexport function noFill() {\n  F.isActive = false;\n}\n\n/**\n * Disables some operations in order to guarantee a consistent bleed efect for animations (at different bleed levels)\n */\nexport function fillAnimatedMode(bool) {\n  F.isAnimated = bool;\n}\n\n/**\n * Object representing the fill state and operations for drawing.\n * @property {boolean} isActive - Indicates if the fill operation is active.\n * @property {boolean} isAnimated - Enable or disable animation-mode\n * @property {Array} v - Array of p5.Vector representing vertices of the polygon to fill.\n * @property {Array} m - Array of multipliers for the bleed effect on each vertex.\n * @property {p5.Color} color - Current fill color.\n * @property {p5.Color} opacity - Current fill opacity.\n * @property {number} bleed_strength - Base value for bleed effect.\n * @property {number} texture_strength - Base value for texture strength.\n * @property {number} border_strength - Base value for border strength.\n * @property {function} fill - Method to fill a polygon with a watercolor effect.\n * @property {function} calcCenter - Method to calculate the centroid of the polygon.\n */\nconst F = {\n  isActive: false,\n  isAnimated: false,\n  color: \"#002185\",\n  opacity: 80,\n  bleed_strength: 0.07,\n  texture_strength: 0.4,\n  border_strength: 0.4,\n\n  /**\n   * Fills the given polygon with a watercolor effect.\n   * @param {Object} polygon - The polygon to fill.\n   */\n  fill(polygon) {\n    // Store polygon\n    this.polygon = polygon;\n    // Map polygon vertices to p5.Vector objects\n    this.v = [...polygon.vertices];\n    // Calculate fluidity once, outside the loop\n    const fluid = this.v.length * R.random(0.4);\n    // Map vertices to bleed multipliers with more intense effect on 'fluid' vertices\n    F.m = this.v.map((_, i) => {\n      let multiplier = R.random(0.8, 1.2) * this.bleed_strength;\n      return i < fluid ? R.constrain(multiplier * 2, 0, 0.9) : multiplier;\n    });\n    // Shift vertices randomly to create a more natural watercolor edge\n    let shift = R.randInt(0, this.v.length);\n    // If light source, look for closest\n    if (F.light_source) {\n      for (let i = 0; i < this.v.length; i++) {\n        if (\n          R.dist(this.v[i].x, this.v[i].y, F.light_source.x, F.light_source.y) <\n          R.dist(\n            this.v[shift].x,\n            this.v[shift].y,\n            F.light_source.x,\n            F.light_source.y\n          )\n        )\n          shift = i;\n      }\n    }\n    this.v = [...this.v.slice(shift), ...this.v.slice(0, shift)];\n    // Create and fill the polygon with the calculated bleed effect\n    let pol = new FillPolygon(this.v, this.m, this.calcCenter(), [], true);\n    pol.fill(\n      this.color,\n      Math.floor(R.map(this.opacity, 0, 155, 0, 20, true)),\n      this.texture_strength\n    );\n  },\n\n  /**\n   * Calculates the center point of the polygon based on the vertices.\n   * @returns {p5.Vector} A vector representing the centroid of the polygon.\n   */\n  calcCenter() {\n    let midx = 0,\n      midy = 0;\n    for (let i = 0; i < this.v.length; ++i) {\n      midx += this.v[i].x;\n      midy += this.v[i].y;\n    }\n    (midx /= this.v.length), (midy /= this.v.length);\n    return { x: midx, y: midy };\n  },\n};\n\nfunction _rotate(cx, cy, x, y, angle) {\n  let cos = R.cos(angle),\n    sin = R.sin(angle),\n    nx = cos * (x - cx) + sin * (y - cy) + cx,\n    ny = cos * (y - cy) - sin * (x - cx) + cy;\n  return { x: nx, y: ny };\n}\n\n/**\n * The FillPolygon class is used to create and manage the properties of the polygons that produces\n * the watercolor effect. It includes methods to grow (expand) the polygon and apply layers\n * of color with varying intensity and erase parts to simulate a natural watercolor bleed.\n * The implementation follows Tyler Hobbs' guide to simulating watercolor:\n * https://tylerxhobbs.com/essays/2017/a-generative-approach-to-simulating-watercolor-paints\n */\nclass FillPolygon {\n  /**\n   * The constructor initializes the polygon with a set of vertices, multipliers for the bleed effect, and a center point.\n   * @param {p5.Vector[]} _v - An array of p5.Vector objects representing the vertices of the polygon.\n   * @param {number[]} _m - An array of numbers representing the multipliers for the bleed effect at each vertex.\n   * @param {p5.Vector} _center - A p5.Vector representing the calculated center point of the polygon.\n   * @param {boolean[]} dir - An array of booleans representing the bleed direction.\n   * @param {boolean} isFirst - Boolean = true for initial fill polygon\n   */\n  constructor(_v, _m, _center, dir, isFirst = false) {\n    this.pol = new Polygon(_v, true);\n    this.v = _v;\n    this.dir = dir;\n    this.m = _m;\n    this.midP = _center;\n    this.size = -Infinity;\n    for (let v of this.v) {\n      let temp_size = R.dist(this.midP.x, this.midP.y, v.x, v.y);\n      if (temp_size > this.size) this.size = temp_size;\n    }\n    // This calculates the bleed direction for the initial shape, for each of the vertices.\n    if (isFirst) {\n      for (let i = 0; i < this.v.length; i++) {\n        const v1 = this.v[i];\n        const v2 = this.v[(i + 1) % this.v.length];\n        const side = { x: v2.x - v1.x, y: v2.y - v1.y };\n        const rt = _rotate(0, 0, side.x, side.y, 90);\n        let linea = {\n          point1: { x: v1.x + side.x / 2, y: v1.y + side.y / 2 },\n          point2: { x: v1.x + side.x / 2 + rt.x, y: v1.y + side.y / 2 + rt.y },\n        };\n        const isLeft = (a, b, c) => {\n          return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x) > 0.01;\n        };\n        let d1 = 0;\n        for (let int of F.polygon.intersect(linea)) {\n          if (isLeft(v1, v2, int)) d1++;\n        }\n        this.dir[i] = d1 % 2 === 0 ? true : false;\n      }\n    }\n  }\n\n  trim(factor) {\n    let v = [...this.v],\n      m = [...this.m],\n      dir = [...this.dir];\n    if (this.v.length > 10 && factor >= 0.2) {\n      let numTrim = ~~((1 - factor) * this.v.length);\n      let sp = ~~this.v.length / 2 - ~~numTrim / 2;\n      v.splice(sp, numTrim);\n      m.splice(sp, numTrim);\n      dir.splice(sp, numTrim);\n    }\n    return { v: v, m: m, dir: dir };\n  }\n\n  /**\n   * Grows the polygon's vertices outwards to simulate the spread of watercolor.\n   * Optionally, can also shrink (degrow) the polygon's vertices inward.\n   * @param {number} _a - The growth factor.\n   * @param {boolean} [degrow=false] - If true, vertices will move inwards.\n   * @returns {FillPolygon} A new `FillPolygon` object with adjusted vertices.\n   */\n  grow(growthFactor, degrow = false) {\n    const newVerts = [];\n    const newMods = [];\n    const newDirs = [];\n    // Determine the length of vertices to process based on growth factor\n    let tr = this.trim(growthFactor);\n    // Pre-compute values that do not change within the loop\n    const modAdjustment = degrow ? -0.5 : 1;\n    // Inline changeModifier to reduce function calls\n    const changeModifier = (modifier) => {\n      const gaussianVariation = R.gaussian(0.5, 0.1);\n      return modifier + (gaussianVariation - 0.5) * 0.1;\n    };\n    // Loop through each vertex to calculate the new position based on growth\n    for (let i = 0; i < tr.v.length; i++) {\n      const currentVertex = tr.v[i];\n      const nextVertex = tr.v[(i + 1) % tr.v.length];\n      // Determine the growth modifier\n      let mod =\n        growthFactor === 0.1\n          ? F.bleed_strength <= 0.1\n            ? 0.25\n            : 0.75\n          : tr.m[i];\n      mod *= modAdjustment;\n      // Add the current vertex and its modified value\n      newVerts.push(currentVertex);\n      newMods.push(changeModifier(mod));\n\n      // Calculate side\n      let side = {\n        x: nextVertex.x - currentVertex.x,\n        y: nextVertex.y - currentVertex.y,\n      };\n\n      // Make sure that we always bleed in the selected direction\n      let dir = tr.dir[i];\n      let bleed = F.direction == \"out\" ? -90 : 90;\n      let rotationDegrees = (dir ? bleed : -bleed) + R.gaussian(0, 0.4) * 45;\n\n      // Calculate the middle vertex position\n      let lerp = R.constrain(R.gaussian(0.5, 0.2), 0.1, 0.9);\n      let newVertex = {\n        x: currentVertex.x + side.x * lerp,\n        y: currentVertex.y + side.y * lerp,\n      };\n\n      // Calculate the new vertex position\n      let mult = R.gaussian(0.5, 0.2) * R.random(0.6, 1.4) * mod;\n      let direction = _rotate(0, 0, side.x, side.y, rotationDegrees);\n      newVertex.x += direction.x * mult;\n      newVertex.y += direction.y * mult;\n\n      // Add the new vertex and its modifier\n      newVerts.push(newVertex);\n      newMods.push(changeModifier(mod));\n      newDirs.push(dir, dir);\n    }\n    return new FillPolygon(newVerts, newMods, this.midP, newDirs);\n  }\n\n  /**\n   * Fills the polygon with the specified color and intensity.\n   * It uses layered growth to simulate watercolor paper absorption and drying patterns.\n   * @param {p5.Color|string} color - The fill color.\n   * @param {number} intensity - The opacity of the color layers.\n   */\n  fill(color, intensity, tex) {\n    let bleed = R.map(F.bleed_strength, 0, 0.15, 0.6, 1, true);\n    // Precalculate stuff\n    const numLayers = 24 * bleed;\n    const intensityThird = intensity / 5 + (tex * intensity) / 6;\n    const intensityQuarter = intensity / 4 + (tex * intensity) / 3;\n    const intensityFifth = intensity / 7 + (tex * intensity) / 3;\n    const intensityHalf = intensity / 5;\n    const texture = tex * 3;\n\n    // Perform initial setup only once\n    Mix.watercolor = true;\n    Matrix.trans();\n    Mix.blend(color, false, false, true);\n    Mix.masks[0].push();\n    Mix.masks[0].noStroke();\n    Mix.masks[0].translate(\n      Matrix.translation[0] + _r.width / 2,\n      Matrix.translation[1] + _r.height / 2\n    );\n    Mix.masks[0].rotate(Matrix.rotation);\n    Mix.masks[0].scale(_curScale);\n\n    // Set the different polygons for texture\n    let pol = this.grow();\n    let pol2 = pol.grow().grow(0.9);\n    let pol3 = pol2.grow(0.75);\n    let pol4 = this.grow(0.6);\n\n    for (let i = 0; i < numLayers; i++) {\n      if (\n        i === Math.floor(numLayers / 4) ||\n        i === Math.floor(numLayers / 2) ||\n        i === Math.floor((3 * numLayers) / 4)\n      ) {\n        // Grow the polygon objects once per fourth of the process\n        pol = pol.grow();\n        // Grow the texture polygons if conditions are met\n        if (bleed === 1 || i === Math.floor(numLayers / 2)) {\n          pol2 = pol2.grow(0.75);\n          pol3 = pol3.grow(0.75);\n          pol4 = pol4.grow(0.1, true);\n        }\n      }\n      // Draw layers\n      pol.grow().layer(i, intensityHalf);\n      pol4.grow(0.1, true).grow(0.1).layer(i, intensityFifth, false);\n      pol2.grow(0.1).grow(0.1).layer(i, intensityQuarter, false);\n      pol3.grow(0.8).grow(0.1).layer(i, intensityThird, false);\n      // Erase after each set of layers is drawn\n      if (texture !== 0) pol.erase(texture, intensity);\n    }\n    Mix.masks[0].pop();\n  }\n\n  /**\n   * Adds a layer of color to the polygon with specified opacity.\n   * It also sets a stroke to outline the layer edges.\n   * @param {number} _nr - The layer number, affecting the stroke and opacity mapping.\n   * @param {number} _alpha - The opacity of the layer.\n   * @param {boolean} [bool=true] - If true, adds a stroke to the layer.\n   */\n  layer(_nr, _alpha, bool = true) {\n    // Set fill and stroke properties once\n    Mix.masks[0].fill(255, 0, 0, _alpha);\n    if (bool) {\n      Mix.masks[0].stroke(255, 0, 0, 0.5 + 1.5 * F.border_strength);\n      Mix.masks[0].strokeWeight(R.map(_nr, 0, 24, 6, 0.5));\n    } else {\n      Mix.masks[0].noStroke();\n    }\n    Mix.masks[0].beginShape();\n    for (let v of this.v) {\n      Mix.masks[0].vertex(v.x, v.y);\n    }\n    Mix.masks[0].endShape(_r.CLOSE);\n  }\n\n  /**\n   * Erases parts of the polygon to create a more natural, uneven watercolor texture.\n   * Uses random placement and sizing of circles to simulate texture.\n   */\n  erase(texture, intensity) {\n    const numCircles = R.random(130, 200);\n    const halfSize = this.size / 2;\n    const minSizeFactor = 0.025 * this.size;\n    const maxSizeFactor = 0.19 * this.size;\n    Mix.masks[0].erase(\n      3.5 * texture - R.map(intensity, 80, 120, 0.3, 1, true),\n      0\n    );\n    for (let i = 0; i < numCircles; i++) {\n      const x = this.midP.x + R.gaussian(0, halfSize);\n      const y = this.midP.y + R.gaussian(0, halfSize);\n      const size = R.random(minSizeFactor, maxSizeFactor);\n      Mix.masks[0].circle(x, y, size);\n    }\n    Mix.masks[0].noErase();\n  }\n}\n\n// =============================================================================\n// Section: Standard Brushes\n// =============================================================================\n\n/**\n * Defines a set of standard brushes with specific characteristics. Each brush is defined\n * with properties such as weight, vibration, definition, quality, opacity, spacing, and\n * pressure sensitivity. Some brushes have additional properties like type, tip, and rotate.\n */\nconst _vals = [\n  \"weight\",\n  \"vibration\",\n  \"definition\",\n  \"quality\",\n  \"opacity\",\n  \"spacing\",\n  \"pressure\",\n  \"type\",\n  \"tip\",\n  \"rotate\",\n];\nconst _standard_brushes = [\n  // Define each brush with a name and a set of parameters\n  // For example, the \"pen\" brush has a weight of 0.35, a vibration of 0.12, etc.\n  // The \"marker2\" brush has a custom tip defined by a function that draws rectangles.\n  [\n    \"pen\",\n    [0.35, 0.12, 0.5, 8, 200, 0.3, { curve: [0.15, 0.2], min_max: [1.4, 0.9] }],\n  ],\n  [\n    \"rotring\",\n    [0.2, 0.05, 1, 3, 250, 0.15, { curve: [0.05, 0.2], min_max: [1.7, 0.8] }],\n  ],\n  [\n    \"2B\",\n    [0.35, 0.5, 0.1, 8, 180, 0.2, { curve: [0.15, 0.2], min_max: [1.3, 1] }],\n  ],\n  [\n    \"HB\",\n    [0.3, 0.5, 0.4, 4, 180, 0.25, { curve: [0.15, 0.2], min_max: [1.2, 0.9] }],\n  ],\n  [\n    \"2H\",\n    [0.2, 0.4, 0.3, 2, 150, 0.2, { curve: [0.15, 0.2], min_max: [1.2, 0.9] }],\n  ],\n  [\n    \"cpencil\",\n    [0.4, 0.6, 0.8, 7, 120, 0.15, { curve: [0.15, 0.2], min_max: [0.95, 1.2] }],\n  ],\n  [\n    \"charcoal\",\n    [0.5, 2, 0.8, 300, 110, 0.06, { curve: [0.15, 0.2], min_max: [1.3, 0.8] }],\n  ],\n  [\n    \"hatch_brush\",\n    [0.2, 0.4, 0.3, 2, 150, 0.15, { curve: [0.5, 0.7], min_max: [1, 1.5] }],\n  ],\n  [\n    \"spray\",\n    [\n      0.3,\n      12,\n      15,\n      40,\n      80,\n      0.65,\n      { curve: [0, 0.1], min_max: [0.15, 1.2] },\n      \"spray\",\n    ],\n  ],\n  [\n    \"marker\",\n    [\n      2.5,\n      0.12,\n      null,\n      null,\n      25,\n      0.4,\n      { curve: [0.35, 0.25], min_max: [1.5, 1] },\n      \"marker\",\n    ],\n  ],\n  [\n    \"marker2\",\n    [\n      2.5,\n      0.12,\n      null,\n      null,\n      25,\n      0.35,\n      { curve: [0.35, 0.25], min_max: [1.3, 0.95] },\n      \"custom\",\n      function (t) {\n        let scale = _gScale;\n        t.rect(-1.5 * scale, -1.5 * scale, 3 * scale, 3 * scale);\n        t.rect(1 * scale, 1 * scale, 1 * scale, 1 * scale);\n      },\n      \"natural\",\n    ],\n  ],\n];\n/**\n * Iterates through the list of standard brushes and adds each one to the brush manager.\n * The brush manager is assumed to be a global object `B` that has an `add` method.\n */\nfor (let s of _standard_brushes) {\n  let obj = {};\n  for (let i = 0; i < s[1].length; i++) obj[_vals[i]] = s[1][i];\n  add(s[0], obj);\n}\n", "\nexport function _prng_restore(prng, xg, opts) {\n  let state = opts && opts.state;\n  if (state) {\n    if (typeof(state) == 'object') xg.copy(state, xg);\n    prng.state = () => xg.copy(xg, {});\n  }\n}\n\nexport function _prng_xor_core(xg, opts) {\n  let prng = () => (xg.next() >>> 0) / 0x100000000;\n\n  prng.double = () => {\n    let top, bot, result\n    do {\n      top = xg.next() >>> 11;\n      bot = (xg.next() >>> 0) / 0x100000000;\n      result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n\n  prng.int32 = () => xg.next() | 0;\n\n  prng.quick = prng;\n\n  _prng_restore(prng, xg, opts);\n  return prng;\n}\n", "// A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010\n// http://baagoe.com/en/RandomMusings/javascript/\n// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror\n// Original work is under MIT license -\n\n// Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {_prng_restore} from './_common.mjs'\n\nexport default prng_alea;\nexport function prng_alea(seed, opts) {\n  let xg = new AleaGen(seed);\n\n  let prng = () => xg.next();\n\n  prng.double = () =>\n    prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53\n\n  prng.int32 = () => (xg.next() * 0x100000000) | 0;\n\n  prng.quick = prng;\n\n  _prng_restore(prng, xg, opts);\n  return prng\n}\n\nclass AleaGen {\n  constructor(seed) {\n    if (seed == null) seed = +(new Date);\n\n    let n = 0xefc8249d;\n\n    // Apply the seeding algorithm from Baagoe.\n    this.c = 1;\n    this.s0 = mash(' ');\n    this.s1 = mash(' ');\n    this.s2 = mash(' ');\n    this.s0 -= mash(seed);\n    if (this.s0 < 0) { this.s0 += 1; }\n    this.s1 -= mash(seed);\n    if (this.s1 < 0) { this.s1 += 1; }\n    this.s2 -= mash(seed);\n    if (this.s2 < 0) { this.s2 += 1; }\n\n    function mash(data) {\n      data = String(data);\n      for (let i = 0; i < data.length; i++) {\n        n += data.charCodeAt(i);\n        let h = 0.02519603282416938 * n;\n        n = h >>> 0;\n        h -= n;\n        h *= n;\n        n = h >>> 0;\n        h -= n;\n        n += h * 0x100000000; // 2^32\n      }\n      return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n    }\n  }\n\n  next() {\n    let {c,s0,s1,s2} = this\n    let t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32\n    this.s0 = s1;\n    this.s1 = s2;\n    return this.s2 = t - (this.c = t | 0);\n  }\n\n  copy(f, t) {\n    t.c = f.c;\n    t.s0 = f.s0;\n    t.s1 = f.s1;\n    t.s2 = f.s2;\n    return t;\n  }\n}\n", "// A Javascript implementaion of the \"xor128\" prng algorithm by\n// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper\n\nimport {_prng_xor_core} from './_common.mjs'\n\nexport default prng_xor128;\nexport function prng_xor128(seed, opts) {\n  let xg = new Xor128Gen(seed);\n  return _prng_xor_core(xg, opts);\n}\n\nclass Xor128Gen {\n  constructor(seed) {\n    if (seed == null) seed = +(new Date);\n\n    let strseed = '';\n\n    this.x = 0;\n    this.y = 0;\n    this.z = 0;\n    this.w = 0;\n\n    if (seed === (seed | 0)) {\n      // Integer seed.\n      this.x = seed;\n    } else {\n      // String seed.\n      strseed += seed;\n    }\n\n    // Mix in string seed, then discard an initial batch of 64 values.\n    for (let k = 0; k < strseed.length + 64; k++) {\n      this.x ^= strseed.charCodeAt(k) | 0;\n      this.next();\n    }\n  }\n\n  next() {\n    let {x,y,z,w} = this\n    let t = x ^ (x << 11);\n    this.x = y;\n    this.y = z;\n    this.z = w;\n    return this.w = w ^ ((w >>> 19) ^ t ^ (t >>> 8));\n  };\n\n  copy(f, t) {\n    t.x = f.x;\n    t.y = f.y;\n    t.z = f.z;\n    t.w = f.w;\n    return t;\n  }\n}\n\n", "// A Javascript implementaion of the \"xorwow\" prng algorithm by\n// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper\n\nimport {_prng_xor_core} from './_common.mjs'\n\nexport default prng_xorwow\nexport function prng_xorwow(seed, opts) {\n  let xg = new XorWowGen(seed);\n  return _prng_xor_core(xg, opts);\n}\n\nclass XorWowGen {\n  constructor(seed) {\n    if (seed == null) seed = +(new Date);\n\n    let strseed = '';\n\n    this.x = 0;\n    this.y = 0;\n    this.z = 0;\n    this.w = 0;\n    this.v = 0;\n\n    if (seed === (seed | 0)) {\n      // Integer seed.\n      this.x = seed;\n    } else {\n      // String seed.\n      strseed += seed;\n    }\n\n    // Mix in string seed, then discard an initial batch of 64 values.\n    for (let k = 0; k < strseed.length + 64; k++) {\n      this.x ^= strseed.charCodeAt(k) | 0;\n      if (k == strseed.length) {\n        this.d = this.x << 10 ^ this.x >>> 4;\n      }\n      this.next();\n    }\n  }\n\n  next() {\n    let {x,y,z,w,v,d} = this\n    let t = (x ^ (x >>> 2));\n    this.x = y;\n    this.y = z;\n    this.z = w;\n    this.w = v;\n    return (this.d = (d + 362437 | 0)) +\n       (this.v = (v ^ (v << 4)) ^ (t ^ (t << 1))) | 0;\n  };\n\n  copy(f, t) {\n    t.x = f.x;\n    t.y = f.y;\n    t.z = f.z;\n    t.w = f.w;\n    t.v = f.v;\n    t.d = f.d;\n    return t;\n  }\n}\n", "// A Javascript implementaion of the \"xorshift7\" algorithm by\n// Franois Panneton and Pierre L'ecuyer:\n// \"On the Xorgshift Random Number Generators\"\n// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf\n\nimport {_prng_xor_core} from './_common.mjs'\n\nexport default prng_xorshift7\nexport function prng_xorshift7(seed, opts) {\n  let xg = new XorShift7Gen(seed);\n  return _prng_xor_core(xg, opts);\n}\n\n\nclass XorShift7Gen {\n  constructor(seed) {\n    if (seed == null) seed = +(new Date);\n\n    var j, w, x = [];\n\n    if (seed === (seed | 0)) {\n      // Seed state array using a 32-bit integer.\n      w = x[0] = seed;\n    } else {\n      // Seed state using a string.\n      seed = '' + seed;\n      for (j = 0; j < seed.length; ++j) {\n        x[j & 7] = (x[j & 7] << 15) ^\n            (seed.charCodeAt(j) + x[(j + 1) & 7] << 13);\n      }\n    }\n\n    // Enforce an array length of 8, not all zeroes.\n    while (x.length < 8) x.push(0);\n    for (j = 0; j < 8 && x[j] === 0; ++j);\n    if (j == 8) w = x[7] = -1; else w = x[j];\n\n    this.x = x;\n    this.i = 0;\n\n    // Discard an initial 256 values.\n    for (j = 256; j > 0; --j) {\n      this.next();\n    }\n  }\n\n  next() {\n    // Update xor generator.\n    let t, v, w, {x,i} = this\n    t = x[i]; t ^= (t >>> 7); v = t ^ (t << 24);\n    t = x[(i + 1) & 7]; v ^= t ^ (t >>> 10);\n    t = x[(i + 3) & 7]; v ^= t ^ (t >>> 3);\n    t = x[(i + 4) & 7]; v ^= t ^ (t << 7);\n    t = x[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);\n    x[i] = v;\n    this.i = (i + 1) & 7;\n    return v;\n  };\n\n  copy(f, t) {\n    t.x = [... f.x];\n    t.i = f.i;\n    return t;\n  }\n}\n", "// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.\n//\n// This fast non-cryptographic random number generator is designed for\n// use in Monte-Carlo algorithms. It combines a long-period xorshift\n// generator with a Weyl generator, and it passes all common batteries\n// of stasticial tests for randomness while consuming only a few nanoseconds\n// for each prng generated.  For background on the generator, see Brent's\n// paper: \"Some long-period random number generators using shifts and xors.\"\n// http://arxiv.org/pdf/1004.3115v1.pdf\n//\n// For nonzero numeric keys, this impelementation provides a sequence\n// identical to that by Brent's xorgens 3 implementaion in C.  This\n// implementation also provides for initalizing the generator with\n// string seeds, or for saving and restoring the state of the generator.\n//\n// On Chrome, this prng benchmarks about 2.1 times slower than\n// Javascript's built-in Math.random().\n\nimport {_prng_xor_core} from './_common.mjs'\n\nexport default prng_xor4096\nexport function prng_xor4096(seed, opts) {\n  let xg = new Xor4096Gen(seed);\n  return _prng_xor_core(xg, opts);\n}\n\n\nclass Xor4096Gen {\n  constructor(seed) {\n    if (seed == null) seed = +(new Date);\n\n    let t, v, i, j, w, X = [], limit = 128;\n    if (seed === (seed | 0)) {\n      // Numeric seeds initialize v, which is used to generates X.\n      v = seed;\n      seed = null;\n    } else {\n      // String seeds are mixed into v and X one character at a time.\n      seed = seed + '\\0';\n      v = 0;\n      limit = Math.max(limit, seed.length);\n    }\n    // Initialize circular array and weyl value.\n    for (i = 0, j = -32; j < limit; ++j) {\n      // Put the unicode characters into the array, and shuffle them.\n      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);\n      // After 32 shuffles, take v as the starting w value.\n      if (j === 0) w = v;\n      v ^= v << 10;\n      v ^= v >>> 15;\n      v ^= v << 4;\n      v ^= v >>> 13;\n      if (j >= 0) {\n        w = (w + 0x61c88647) | 0;     // Weyl.\n        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.\n        i = (0 == t) ? i + 1 : 0;     // Count zeroes.\n      }\n    }\n    // We have detected all zeroes; make the key nonzero.\n    if (i >= 128) {\n      X[(seed && seed.length || 0) & 127] = -1;\n    }\n    // Run the generator 512 times to further mix the state before using it.\n    // Factoring this as a function slows the main generator, so it is just\n    // unrolled here.  The weyl generator is not advanced while warming up.\n    i = 127;\n    for (j = 4 * 128; j > 0; --j) {\n      v = X[(i + 34) & 127];\n      t = X[i = ((i + 1) & 127)];\n      v ^= v << 13;\n      t ^= t << 17;\n      v ^= v >>> 15;\n      t ^= t >>> 12;\n      X[i] = v ^ t;\n    }\n    // Storing state as object members is faster than using closure variables.\n    this.w = w;\n    this.X = X;\n    this.i = i;\n  }\n\n  next() {\n    let t, v, {w, X, i} = this\n    // Update Weyl generator.\n    this.w = w = (w + 0x61c88647) | 0;\n    // Update xor generator.\n    v = X[(i + 34) & 127];\n    t = X[i = ((i + 1) & 127)];\n    v ^= v << 13;\n    t ^= t << 17;\n    v ^= v >>> 15;\n    t ^= t >>> 12;\n    // Update Xor generator array state.\n    v = X[i] = v ^ t;\n    this.i = i;\n    // Result is the combination.\n    return (v + (w ^ (w >>> 16))) | 0;\n  }\n\n  copy(f, t) {\n    t.i = f.i;\n    t.w = f.w;\n    t.X = [... f.X]\n    return t;\n  }\n}\n", "// A Javascript implementaion of the \"Tyche-i\" prng algorithm by\n// Samuel Neves and Filipe Araujo.\n// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf\n\nimport {_prng_xor_core} from './_common.mjs'\n\nexport default prng_tychei\nexport function prng_tychei(seed, opts) {\n  let xg = new TycheiGen(seed);\n  return _prng_xor_core(xg, opts);\n}\n\nclass TycheiGen {\n  constructor(seed) {\n    if (seed == null) seed = +(new Date);\n\n    let strseed = '';\n\n    this.a = 0;\n    this.b = 0;\n    this.c = 2654435769 | 0;\n    this.d = 1367130551;\n\n    if (seed === Math.floor(seed)) {\n      // Integer seed.\n      this.a = (seed / 0x100000000) | 0;\n      this.b = seed | 0;\n    } else {\n      // String seed.\n      strseed += seed;\n    }\n\n    // Mix in string seed, then discard an initial batch of 64 values.\n    for (let k = 0; k < strseed.length + 20; k++) {\n      this.b ^= strseed.charCodeAt(k) | 0;\n      this.next();\n    }\n  }\n\n  next() {\n    let {a,b,c,d} = this\n    b = (b << 25) ^ (b >>> 7) ^ c;\n    c = (c - d) | 0;\n    d = (d << 24) ^ (d >>> 8) ^ a;\n    a = (a - b) | 0;\n    this.b = b = (b << 20) ^ (b >>> 12) ^ c;\n    this.c = c = (c - d) | 0;\n    this.d = (d << 16) ^ (c >>> 16) ^ a;\n    return this.a = (a - b) | 0;\n  };\n\n  copy(f, t) {\n    t.a = f.a;\n    t.b = f.b;\n    t.c = f.c;\n    t.d = f.d;\n    return t;\n  }\n}\n\n\n/* The following is non-inverted tyche, which has better internal\n * bit diffusion, but which is about 25% slower than tyche-i in JS.\n *\n\nclass TycheiGenAlt extends TycheiGen {\n  next() {\n    let {a,b,c,d} = this\n    a = (a + b | 0) >>> 0;\n    d = d ^ a; d = d << 16 ^ d >>> 16;\n    c = c + d | 0;\n    b = b ^ c; b = b << 12 ^ d >>> 20;\n    this.a = a = a + b | 0;\n    d = d ^ a; this.d = d = d << 8 ^ d >>> 24;\n    this.c = c = c + d | 0;\n    b = b ^ c;\n    return this.b = (b << 7 ^ b >>> 25);\n  }\n}\n*/\n", "/*\nCopyright 2019 David Bau.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\nimport {_prng_restore} from './_common.mjs'\n\nexport default prng_arc4;\nexport function prng_arc4(seed, opts) {\n  let xg = new ARC4Gen(seed);\n  let prng = () => xg.next();\n\n  prng.double = prng;\n\n  prng.int32 = () => xg.g(4) | 0;\n\n  prng.quick = () => xg.g(4) / 0x100000000;\n\n  _prng_restore(prng, xg, opts);\n  return prng\n}\n\n\n//\n// ARC4\n//\n// An ARC4 implementation.  The constructor takes a key in the form of\n// an array of at most (width) integers that should be 0 <= x < (width).\n//\n// The g(count) method returns a pseudorandom integer that concatenates\n// the next (count) outputs from ARC4.  Its return value is a number x\n// that is in the range 0 <= x < (width ^ count).\n//\n\n//\n// The following constants are related to IEEE 754 limits.\n//\n\n// const width = 256 // each RC4 output is 0 <= x < 256\n// const chunks = 6 // at least six RC4 outputs for each double\nconst _arc4_startdenom = 281474976710656     // 256 ** 6 == width ** chunks\nconst _arc4_significance = 4503599627370496  // 2 ** 52 significant digits in a double\nconst _arc4_overflow = 9007199254740992      // 2 ** 53 == significance * 2\n\n\nclass ARC4Gen {\n  constructor(seed) {\n    if (seed == null) seed = +(new Date);\n\n    let key = this.mixkey(seed, [])\n    let i,j,t, S=[], keylen = key.length\n    this.i = this.j = i = j = 0\n    this.S = S\n\n    // The empty key [] is treated as [0].\n    if (!keylen) { key = [keylen++]; }\n\n    // Set up S using the standard key scheduling algorithm.\n    while (i <= 0xff) {\n      S[i] = i++;\n    }\n    for (i = 0; i <= 0xff; i++) {\n      S[i] = S[j = 0xff & (j + key[i % keylen] + (t = S[i]))];\n      S[j] = t;\n    }\n\n    // For robust unpredictability, the function call below automatically\n    // discards an initial batch of values.  This is called RC4-drop[256].\n    // See http://google.com/search?q=rsa+fluhrer+response&btnI\n    this.g(256)\n  }\n\n  next() {\n    // This function returns a random double in [0, 1) that contains\n    // randomness in every bit of the mantissa of the IEEE 754 value.\n\n    let n = this.g(6);                  // Start with a numerator n < 2 ^ 48\n    let d = _arc4_startdenom;           //   and denominator d = 2 ^ 48.\n    let x = 0;                          //   and no 'extra last byte'.\n\n    while (n < _arc4_significance) {    // Fill up all significant digits (2 ** 52)\n      n = (n + x) * 256;                //   by shifting numerator and\n      d *= 256;                         //   denominator and generating a\n      x = this.g(1);                    //   new least-significant-byte.\n    }\n    while (n >= _arc4_overflow) {       // To avoid rounding past overflow, before adding\n      n /= 2;                           //   last byte, shift everything\n      d /= 2;                           //   right using integer math until\n      x >>>= 1;                         //   we have exactly the desired bits.\n    }\n    return (n + x) / d;                 // Form the number within [0, 1).\n  }\n\n  g(count) {\n    // The \"g\" method returns the next (count) outputs as one number.\n    let t, r = 0, {i,j,S} = this;\n    while (count--) {\n      t = S[i = 0xff & (i + 1)];\n      r = r * 256 + S[0xff & ((S[i] = S[j = 0xff & (j + t)]) + (S[j] = t))];\n    }\n    this.i = i;\n    this.j = j;\n    return r;\n  }\n\n  copy(f, t) {\n    t.i = f.i;\n    t.j = f.j;\n    t.S = [... f.S]\n    return t;\n  }\n\n  mixkey(seed, key) {\n    seed = seed + ''\n    let smear=0, j=0;\n    while (j < seed.length) {\n      key[0xff & j] =\n        0xff & ((smear ^= key[0xff & j] * 19) + seed.charCodeAt(j++));\n    }\n    return key\n  }\n}\n"],
  "mappings": "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",
  "names": ["seed", "field", "plot", "scale", "_r", "brush", "strokeWeight", "i", "line", "polygon", "bleed"]
}
