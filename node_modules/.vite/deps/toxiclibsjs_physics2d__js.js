import {
  require_GravityBehavior,
  require_behaviors
} from "./chunk-U2CYC5IP.js";
import {
  require_Circle,
  require_Ray2D,
  require_Rect,
  require_Spline2D
} from "./chunk-EOWBUYU7.js";
import {
  require_Vec2D,
  require_has,
  require_internals
} from "./chunk-HPGC77CE.js";
import {
  __commonJS,
  init_buffer,
  init_process
} from "./chunk-PO7TFOVG.js";

// node_modules/toxiclibsjs/physics2d/VerletParticle2D.js
var require_VerletParticle2D = __commonJS({
  "node_modules/toxiclibsjs/physics2d/VerletParticle2D.js"(exports, module) {
    init_process();
    init_buffer();
    var internals = require_internals();
    var Vec2D = require_Vec2D();
    var VerletParticle2D = function(x, y, w) {
      this.force = new Vec2D();
      if (internals.has.XY(x)) {
        if (internals.is.VerletParticle2D(x)) {
          y = x.y;
          w = x.weight;
          x = x.x;
          this.isLocked = x.isLocked;
        } else if (y === void 0) {
          y = x.y;
          w = 1;
          x = x.x;
        } else {
          w = y;
          y = x.y;
          x = x.x;
        }
      }
      Vec2D.call(this, x, y);
      this.isLocked = false;
      this.prev = new Vec2D(this);
      this.temp = new Vec2D();
      w = w || 1;
      this.setWeight(w);
    };
    internals.extend(VerletParticle2D, Vec2D);
    VerletParticle2D.prototype.addBehavior = function(behavior, timeStep) {
      if (this.behaviors === void 0) {
        this.behaviors = [];
      }
      if (behavior === void 0) {
        throw new Error("behavior was undefined");
      }
      timeStep = timeStep === void 0 ? 1 : timeStep;
      behavior.configure(timeStep);
      this.behaviors.push(behavior);
      return this;
    };
    VerletParticle2D.prototype.addConstraint = function(c) {
      if (this.constraints === void 0) {
        this.constraints = [];
      }
      this.constraints.push(c);
      return this;
    };
    VerletParticle2D.prototype.addForce = function(f) {
      this.force.addSelf(f);
      return this;
    };
    VerletParticle2D.prototype.addVelocity = function(v) {
      this.prev.subSelf(v);
      return this;
    };
    VerletParticle2D.prototype.applyBehaviors = function() {
      if (this.behaviors !== void 0) {
        var i = 0, len = this.behaviors.length;
        for (i = 0; i < len; i++) {
          this.behaviors[i].applyBehavior(this);
        }
      }
    };
    VerletParticle2D.prototype.applyConstraints = function() {
      if (this.constraints !== void 0) {
        var i = 0, len = this.constraints.length;
        for (i = 0; i < len; i++) {
          this.constraints[i].applyConstraint(this);
        }
      }
    };
    VerletParticle2D.prototype.clearForce = function() {
      this.force.clear();
      return this;
    };
    VerletParticle2D.prototype.clearVelocity = function() {
      this.prev.set(this);
      return this;
    };
    VerletParticle2D.prototype.getInvWeight = function() {
      return this.invWeight;
    };
    VerletParticle2D.prototype.getPreviousPosition = function() {
      return this.prev;
    };
    VerletParticle2D.prototype.getVelocity = function() {
      return this.sub(this.prev);
    };
    VerletParticle2D.prototype.getWeight = function() {
      return this.weight;
    };
    VerletParticle2D.prototype.lock = function() {
      this.isLocked = true;
      return this;
    };
    VerletParticle2D.prototype.removeAllBehaviors = function() {
      this.behaviors = [];
      return this;
    };
    VerletParticle2D.prototype.removeAllConstraints = function() {
      this.constraints = [];
      return this;
    };
    VerletParticle2D.prototype.removeBehavior = function(b) {
      return internals.removeItemFrom(b, this.behaviors);
    };
    VerletParticle2D.prototype.removeConstraint = function(c) {
      return internals.removeItemFrom(c, this.constraints);
    };
    VerletParticle2D.prototype.scaleVelocity = function(scl) {
      this.prev.interpolateToSelf(this, 1 - scl);
      return this;
    };
    VerletParticle2D.prototype.setPreviousPosition = function(p) {
      this.prev.set(p);
      return this;
    };
    VerletParticle2D.prototype.setWeight = function(w) {
      this.weight = w;
      this.invWeight = w !== 0 ? 1 / w : 0;
    };
    VerletParticle2D.prototype.unlock = function() {
      this.clearVelocity();
      this.isLocked = false;
      return this;
    };
    VerletParticle2D.prototype.update = function() {
      if (!this.isLocked) {
        this.applyBehaviors();
        this.temp.set(this);
        this.addSelf(this.sub(this.prev).addSelf(this.force.scale(this.weight)));
        this.prev.set(this.temp);
        this.force.clear();
        this.applyConstraints();
      }
    };
    module.exports = VerletParticle2D;
  }
});

// node_modules/toxiclibsjs/physics2d/ParticlePath2D.js
var require_ParticlePath2D = __commonJS({
  "node_modules/toxiclibsjs/physics2d/ParticlePath2D.js"(exports, module) {
    init_process();
    init_buffer();
    var internals = require_internals();
    var Spline2D = require_Spline2D();
    var VerletParticle2D = require_VerletParticle2D();
    var ParticlePath2D = function(points) {
      Spline2D.call(this, points);
      this.particles = [];
    };
    internals.extend(ParticlePath2D, Spline2D);
    ParticlePath2D.prototype.createParticles = function(physics, subDiv, step, mass) {
      this.particles = [];
      this.computeVertices(subDiv);
      var i = 0;
      var dv = this.getDecimatedVertices(step, true);
      for (i = 0; i < dv.length; i++) {
        var v = dv[i];
        var p = new VerletParticle2D(v, mass);
        this.particles.push(p);
        physics.addParticle(p);
      }
      return this.particles;
    };
    module.exports = ParticlePath2D;
  }
});

// node_modules/toxiclibsjs/physics2d/VerletSpring2D.js
var require_VerletSpring2D = __commonJS({
  "node_modules/toxiclibsjs/physics2d/VerletSpring2D.js"(exports, module) {
    init_process();
    init_buffer();
    var VerletSpring2D = function(a, b, len, str) {
      this.a = a;
      this.b = b;
      this.restLength = len;
      this.strength = str;
    };
    VerletSpring2D.EPS = 1e-6;
    VerletSpring2D.prototype = {
      getRestLength: function() {
        return this.restLength;
      },
      getStrength: function() {
        return this.strength;
      },
      lockA: function(s) {
        this.isALocked = s;
        return this;
      },
      lockB: function(s) {
        this.isBLocked = s;
        return this;
      },
      setRestLength: function(len) {
        this.restLength = len;
        this.restLengthSquared = len * len;
        return this;
      },
      setStrength: function(strength) {
        this.strength = strength;
        return this;
      },
      update: function(applyConstraints) {
        var delta = this.b.sub(this.a);
        var dist = delta.magnitude() + VerletSpring2D.EPS;
        var normDistStrength = (dist - this.restLength) / (dist * (this.a.invWeight + this.b.invWeight)) * this.strength;
        if (!this.a.isLocked && !this.isALocked) {
          this.a.addSelf(
            delta.scale(normDistStrength * this.a.invWeight)
          );
          if (applyConstraints) {
            this.a.applyConstraints();
          }
        }
        if (!this.b.isLocked && !this.isBLocked) {
          this.b.addSelf(
            delta.scale(-normDistStrength * this.b.invWeight)
          );
          if (applyConstraints) {
            this.b.applyConstraints();
          }
        }
      }
    };
    module.exports = VerletSpring2D;
  }
});

// node_modules/toxiclibsjs/physics2d/ParticleString2D.js
var require_ParticleString2D = __commonJS({
  "node_modules/toxiclibsjs/physics2d/ParticleString2D.js"(exports, module) {
    init_process();
    init_buffer();
    var VerletParticle2D = require_VerletParticle2D();
    var VerletSpring2D = require_VerletSpring2D();
    var ParticleString2D = function() {
      var opts = {
        physics: void 0,
        plist: void 0,
        pos: void 0,
        step: void 0,
        num: void 0,
        mass: void 0,
        strength: void 0
      }, is6ParamConstructor = false;
      if (arguments.length === 0) {
        throw new Error("Incorrect Parameters");
      } else if (arguments.length == 1) {
        var arg = arguments[0];
        for (var prop in arg) {
          opts[prop] = arg[prop];
        }
      } else {
        opts.physics = arguments[0];
        if (arguments.length == 6) {
          opts.pos = arguments[1];
          opts.step = arguments[2];
          opts.num = arguments[3];
          opts.mass = arguments[4];
          opts.strength = arguments[5];
        } else {
          opts.plist = arguments[1];
          opts.strength = arguments[2];
        }
      }
      if (opts.num !== void 0 && opts.pos !== void 0 && opts.step !== void 0 && opts.mass !== void 0) {
        is6ParamConstructor = true;
      }
      if (!is6ParamConstructor && opts.plist === void 0) {
        throw new Error("Incorrect Parameters, please supply plist or num, pos, step & mass");
      }
      this.physics = opts.physics;
      this.links = [];
      var prev, p, s, strength, i = 0;
      if (is6ParamConstructor) {
        var pos = opts.pos.copy(), step = opts.step, mass = opts.mass, len = step.magnitude();
        this.particles = [];
        strength = opts.strength;
        for (i = 0; i < opts.num; i++) {
          p = new VerletParticle2D(pos.copy(), mass);
          this.particles.push(p);
          this.physics.particles.push(p);
          if (prev !== void 0) {
            s = this.createSpring(prev, p, len, strength);
            this.links.push(s);
            this.physics.addSpring(s);
          }
          prev = p;
          pos.addSelf(step);
        }
      } else {
        strength = opts.strength;
        this.particles = opts.plist || [];
        for (i = 0; i < this.particles.length; i++) {
          p = this.particles[i];
          this.physics.addParticle(p);
          if (prev !== void 0) {
            s = this.createSpring(prev, p, prev.distanceTo(p), strength);
            this.links.push(s);
            this.physics.addSpring(s);
          }
          prev = p;
        }
      }
    };
    ParticleString2D.prototype = {
      clear: function() {
        for (var i = 0, len = this.links.length; i < len; i++) {
          this.physics.removeSpringElements(this.links[i]);
        }
        this.particles = [];
        this.links = [];
      },
      createSpring: function(a, b, len, strength) {
        return new VerletSpring2D(a, b, len, strength);
      },
      getHead: function() {
        return this.particles[0];
      },
      getNumParticles: function() {
        return this.particles.length;
      },
      getTail: function() {
        return this.particles[this.particles.length - 1];
      }
    };
    module.exports = ParticleString2D;
  }
});

// node_modules/toxiclibsjs/physics2d/PullBackString2D.js
var require_PullBackString2D = __commonJS({
  "node_modules/toxiclibsjs/physics2d/PullBackString2D.js"(exports, module) {
    init_process();
    init_buffer();
    var internals = require_internals();
    var VerletSpring2D = require_VerletSpring2D();
    var PullBackString2D = function(a, b, strength) {
      VerletSpring2D.apply(this, [a, b, 0, strength]);
      a.lock();
      this.setRestLength(0.5);
    };
    internals.extend(PullBackString2D, VerletSpring2D);
    PullBackString2D.prototype.update = function(applyConstraints) {
      if (this.b.distanceToSquared(this.a) > this.restLengthSquared) {
        this.parent.update.call(this, applyConstraints);
      }
    };
    module.exports = PullBackString2D;
  }
});

// node_modules/toxiclibsjs/physics2d/VerletConstrainedSpring2D.js
var require_VerletConstrainedSpring2D = __commonJS({
  "node_modules/toxiclibsjs/physics2d/VerletConstrainedSpring2D.js"(exports, module) {
    init_process();
    init_buffer();
    var internals = require_internals();
    var VerletSpring2D = require_VerletSpring2D();
    var VerletConstrainedSpring2D = function(particleA, particleB, len, str, limit) {
      VerletSpring2D.call(this, particleA, particleB, len, str);
      this.limit = limit === void 0 ? Number.MAX_VALUE : limit;
    };
    internals.extend(VerletConstrainedSpring2D, VerletSpring2D);
    VerletConstrainedSpring2D.update = function(applyConstraints) {
      var delta = this.b.sub(this.a);
      var dist = delta.magnitude() + VerletSpring2D.EPS;
      var normDistStrength = (dist - this.restLength) / (dist * (this.a.invWeight + this.b.invWeight)) * this.strength;
      if (!this.a.isLocked && !this.isALocked) {
        this.a.addSelf(delta.scale(normDistStrength * this.a.invWeight).limit(this.limit));
        if (applyConstraints) {
          this.a.applyConstraints();
        }
      }
      if (!this.b.isLocked && !this.isBLocked) {
        this.b.subSelf(delta.scale(normDistStrength * this.b.invWeight).limit(this.limit));
        if (applyConstraints) {
          this.b.applyConstraints();
        }
      }
    };
    module.exports = VerletConstrainedSpring2D;
  }
});

// node_modules/toxiclibsjs/physics2d/VerletMinDistanceSpring2D.js
var require_VerletMinDistanceSpring2D = __commonJS({
  "node_modules/toxiclibsjs/physics2d/VerletMinDistanceSpring2D.js"(exports, module) {
    init_process();
    init_buffer();
    var internals = require_internals();
    var VerletSpring2D = require_VerletSpring2D();
    var VerletMinDistanceSpring2D = function(particleA, particleB, len, str) {
      VerletSpring2D.call(this, particleA, particleB, len, str);
      this.setRestLength(len);
    };
    internals.extend(VerletMinDistanceSpring2D, VerletSpring2D);
    VerletMinDistanceSpring2D.prototype.update = function(applyConstraints) {
      if (this.b.distanceToSquared(this.a) < this.restLengthSquared) {
        this.parent.update.call(this, applyConstraints);
      }
    };
    module.exports = VerletMinDistanceSpring2D;
  }
});

// node_modules/toxiclibsjs/physics2d/VerletPhysics2D.js
var require_VerletPhysics2D = __commonJS({
  "node_modules/toxiclibsjs/physics2d/VerletPhysics2D.js"(exports, module) {
    init_process();
    init_buffer();
    var internals = require_internals();
    var GravityBehavior = require_GravityBehavior();
    var Rect = require_Rect();
    var Vec2D = require_Vec2D();
    var id = 0;
    var VerletPhysics2D = function(gravity, numIterations, drag, timeStep) {
      var opts = {
        numIterations: 50,
        drag: 0,
        timeStep: 1
      };
      var a;
      if (arguments.length == 1 && (arguments[0].gravity || arguments[0].numIterations || arguments[0].timeStep || arguments[0].drag)) {
        a = arguments[0];
        opts.gravity = a.gravity;
        opts.numIterations = a.numIterations || opts.numIterations;
        opts.drag = a.drag || opts.drag;
        opts.timeStep = a.timeStep || opts.timeStep;
      } else if (arguments.length == 1) {
        opts.gravity = gravity;
      } else if (arguments.length == 4) {
        opts.gravity = gravity;
        opts.numIterations = numIterations;
        opts.drag = drag;
        opts.timeStep = timeStep;
      }
      this.behaviors = [];
      this.particles = [];
      this.springs = [];
      this.numIterations = opts.numIterations;
      this.timeStep = opts.timeStep;
      this.setDrag(opts.drag);
      if (opts.gravity) {
        if (internals.has.XY(opts.gravity)) {
          opts.gravity = new GravityBehavior(new Vec2D(opts.gravity));
        }
        this.addBehavior(opts.gravity);
      }
      this.id = id++;
    };
    VerletPhysics2D.addConstraintToAll = function(c, list) {
      for (var i = 0; i < list.length; i++) {
        list[i].addConstraint(c);
      }
    };
    VerletPhysics2D.removeConstraintFromAll = function(c, list) {
      for (var i = 0; i < list.length; i++) {
        list[i].removeConstraint(c);
      }
    };
    VerletPhysics2D.prototype = {
      addBehavior: function(behavior) {
        behavior.configure(this.timeStep);
        this.behaviors.push(behavior);
      },
      addParticle: function(p) {
        this.particles.push(p);
        return this;
      },
      addSpring: function(s) {
        if (this.getSpring(s.a, s.b) === void 0) {
          this.springs.push(s);
        }
        return this;
      },
      clear: function() {
        this.particles = [];
        this.springs = [];
        return this;
      },
      constrainToBounds: function() {
        var p, i = 0, len = this.particles.length;
        for (i = 0; i < len; i++) {
          p = this.particles[i];
          if (p.bounds !== void 0) {
            p.constrain(p.bounds);
          }
        }
        if (this.worldBounds !== void 0) {
          for (i = 0; i < len; i++) {
            p = this.particles[i];
            p.constrain(this.worldBounds);
          }
        }
      },
      getCurrentBounds: function() {
        var min = new Vec2D(Number.MAX_VALUE, Number.MAX_VALUE);
        var max = new Vec2D(Number.MIN_VALUE, Number.MIN_VALUE);
        var i = 0, pLen = this.particles.length, p;
        for (; i < pLen; i++) {
          p = this.particles[i];
          min.minSelf(p);
          max.maxSelf(p);
        }
        return new Rect(min, max);
      },
      getDrag: function() {
        return 1 - this.drag;
      },
      getNumIterations: function() {
        return this.numIterations;
      },
      getSpring: function(a, b) {
        var i = 0, sLen = this.springs.length;
        for (; i < sLen; i++) {
          var s = this.springs[i];
          if (s.a === a && s.b === b || s.a === b && s.b === b) {
            return s;
          }
        }
        return void 0;
      },
      getTimeStep: function() {
        return this.timeStep;
      },
      getWorldBounds: function() {
        return this.worldBounds;
      },
      removeBehavior: function(c) {
        return internals.removeItemFrom(c, this.behaviors);
      },
      removeParticle: function(p) {
        return internals.removeItemFrom(p, this.particles);
      },
      removeSpring: function(s) {
        return internals.removeItemFrom(s, this.springs);
      },
      removeSpringElements: function(s) {
        if (this.removeSpring(s) !== void 0) {
          return this.removeParticle(s.a) && this.removeParticle(s.b);
        }
        return false;
      },
      setDrag: function(drag) {
        this.drag = 1 - drag;
      },
      setNumIterations: function(numIterations) {
        this.numIterations = numIterations;
      },
      setTimeStep: function(timeStep) {
        this.timeStep = timeStep;
        var i = 0, l = this.behaviors.length;
        for (; i < l; i++) {
          this.behaviors[i].configure(timeStep);
        }
      },
      setWorldBounds: function(world) {
        this.worldBounds = world;
        return this;
      },
      update: function() {
        this.updateParticles();
        this.updateSprings();
        this.constrainToBounds();
        return this;
      },
      updateParticles: function() {
        var i = 0, j = 0, bLen = this.behaviors.length, pLen = this.particles.length, b, p;
        for (; i < bLen; i++) {
          b = this.behaviors[i];
          for (j = 0; j < pLen; j++) {
            b.applyBehavior(this.particles[j]);
          }
        }
        for (j = 0; j < pLen; j++) {
          p = this.particles[j];
          p.scaleVelocity(this.drag);
          p.update();
        }
      },
      updateSprings: function() {
        var i = this.numIterations, sLen = this.springs.length, j = 0;
        for (; i > 0; i--) {
          for (j = 0; j < sLen; j++) {
            this.springs[j].update(i === 1);
          }
        }
      }
    };
    module.exports = VerletPhysics2D;
  }
});

// node_modules/toxiclibsjs/physics2d/constraints/AngularConstraint.js
var require_AngularConstraint = __commonJS({
  "node_modules/toxiclibsjs/physics2d/constraints/AngularConstraint.js"(exports, module) {
    init_process();
    init_buffer();
    var Vec2D = require_Vec2D();
    var AngularConstraint = function(theta_p, theta) {
      if (arguments.length > 1) {
        this.theta = theta;
        this.rootPos = new Vec2D(theta_p);
      } else {
        this.rootPos = new Vec2D();
        this.theta = theta_p;
      }
    };
    AngularConstraint.prototype.applyConstraint = function(p) {
      var delta = p.sub(this.rootPos);
      var heading = Math.floor(delta.heading() / this.theta) * this.theta;
      p.set(this.rootPos.add(Vec2D.fromTheta(heading).scaleSelf(delta.magnitude())));
    };
    module.exports = AngularConstraint;
  }
});

// node_modules/toxiclibsjs/physics2d/constraints/AxisConstraint.js
var require_AxisConstraint = __commonJS({
  "node_modules/toxiclibsjs/physics2d/constraints/AxisConstraint.js"(exports, module) {
    init_process();
    init_buffer();
    var AxisConstraint = function(axis, constraintAmount) {
      this.axis = axis;
      this.constraint = constraintAmount;
    };
    AxisConstraint.prototype.applyConstraint = function(p) {
      p.setComponent(this.axis, this.constraint);
    };
    module.exports = AxisConstraint;
  }
});

// node_modules/toxiclibsjs/physics2d/constraints/CircularConstraint.js
var require_CircularConstraint = __commonJS({
  "node_modules/toxiclibsjs/physics2d/constraints/CircularConstraint.js"(exports, module) {
    init_process();
    init_buffer();
    var Circle = require_Circle();
    var CircularConstraint = function(a, b) {
      if (arguments.length == 1) {
        this.circle = a;
      } else {
        this.circle = new Circle(a, b);
      }
    };
    CircularConstraint.prototype.applyConstraint = function(p) {
      if (this.circle.containsPoint(p)) {
        p.set(this.circle.add(p.sub(this.circle).normalizeTo(this.circle.getRadius())));
      }
    };
    module.exports = CircularConstraint;
  }
});

// node_modules/toxiclibsjs/physics2d/constraints/MaxConstraint.js
var require_MaxConstraint = __commonJS({
  "node_modules/toxiclibsjs/physics2d/constraints/MaxConstraint.js"(exports, module) {
    init_process();
    init_buffer();
    var MaxConstraint = function(axis, threshold) {
      this.axis = axis;
      this.threshold = threshold;
    };
    MaxConstraint.prototype.applyConstraint = function(p) {
      if (p.getComponent(this.axis) > this.threshold) {
        p.setComponent(this.axis, this.threshold);
      }
    };
    module.exports = MaxConstraint;
  }
});

// node_modules/toxiclibsjs/physics2d/constraints/MinConstraint.js
var require_MinConstraint = __commonJS({
  "node_modules/toxiclibsjs/physics2d/constraints/MinConstraint.js"(exports, module) {
    init_process();
    init_buffer();
    var MinConstraint = function(axis, threshold) {
      this.axis = axis;
      this.threshold = threshold;
    };
    MinConstraint.prototype.applyConstraint = function(p) {
      if (p.getComponent(this.axis) < this.threshold) {
        p.setComponent(this.axis, this.threshold);
      }
    };
    module.exports = MinConstraint;
  }
});

// node_modules/toxiclibsjs/physics2d/constraints/RectConstraint.js
var require_RectConstraint = __commonJS({
  "node_modules/toxiclibsjs/physics2d/constraints/RectConstraint.js"(exports, module) {
    init_process();
    init_buffer();
    var Vec2D = require_Vec2D();
    var has = require_has();
    var Ray2D = require_Ray2D();
    var Rect = require_Rect();
    var RectConstraint = function(a, b) {
      if (arguments.length == 1) {
        if (typeof a.copy === "function") {
          this.rect = a.copy();
        } else if (has.XYWidthHeight(a)) {
          this.rect = new Rect(a);
        }
      } else if (arguments.length > 1) {
        this.rect = new Rect(a, b);
      }
      if (!this.rect) {
        throw new Error("Received Incorrect arguments");
      }
      this.intersectRay = new Ray2D(this.rect.getCentroid(), new Vec2D());
    };
    RectConstraint.prototype = {
      applyConstraint: function(p) {
        if (this.rect.containsPoint(p)) {
          p.set(this.rect.intersectsRay(this.intersectRay.setDirection(this.intersectRay.sub(p)), 0, Number.MAX_VALUE));
        }
      },
      getBox: function() {
        return this.rect.copy();
      },
      setBox: function(rect) {
        this.rect = rect.copy();
        this.intersectRay.set(this.rect.getCentroid());
      }
    };
    module.exports = RectConstraint;
  }
});

// node_modules/toxiclibsjs/physics2d/constraints.js
var require_constraints = __commonJS({
  "node_modules/toxiclibsjs/physics2d/constraints.js"(exports) {
    init_process();
    init_buffer();
    var AngularConstraint = require_AngularConstraint();
    var AxisConstraint = require_AxisConstraint();
    var CircularConstraint = require_CircularConstraint();
    var MaxConstraint = require_MaxConstraint();
    var MinConstraint = require_MinConstraint();
    var RectConstraint = require_RectConstraint();
    exports.AngularConstraint = AngularConstraint;
    exports.AxisConstraint = AxisConstraint;
    exports.CircularConstraint = CircularConstraint;
    exports.MaxConstraint = MaxConstraint;
    exports.MinConstraint = MinConstraint;
    exports.RectConstraint = RectConstraint;
  }
});

// node_modules/toxiclibsjs/physics2d.js
var require_physics2d = __commonJS({
  "node_modules/toxiclibsjs/physics2d.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = {
      ParticlePath2D: require_ParticlePath2D(),
      ParticleString2D: require_ParticleString2D(),
      PullBackString2D: require_PullBackString2D(),
      VerletConstrainedSpring2D: require_VerletConstrainedSpring2D(),
      VerletMinDistanceSpring2D: require_VerletMinDistanceSpring2D(),
      VerletParticle2D: require_VerletParticle2D(),
      VerletPhysics2D: require_VerletPhysics2D(),
      VerletSpring2D: require_VerletSpring2D()
    };
    module.exports.behaviors = require_behaviors();
    module.exports.constraints = require_constraints();
  }
});
export default require_physics2d();
//# sourceMappingURL=toxiclibsjs_physics2d__js.js.map
