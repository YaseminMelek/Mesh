import {
  require_AABB,
  require_BernsteinPolynomial,
  require_Circle,
  require_Ellipse,
  require_Face,
  require_IsectData3D,
  require_Line2D,
  require_Line3D,
  require_Matrix4x4,
  require_Polygon2D,
  require_Quaternion,
  require_Ray2D,
  require_Ray3D,
  require_Rect,
  require_Sphere,
  require_Spline2D,
  require_Triangle3D,
  require_TriangleMesh,
  require_Vec3D,
  require_Vertex,
  require_meshCommon
} from "./chunk-EOWBUYU7.js";
import {
  require_Iterator,
  require_Vec2D,
  require_has,
  require_internals,
  require_is,
  require_mathUtils,
  require_vectors
} from "./chunk-HPGC77CE.js";
import {
  __commonJS,
  init_buffer,
  init_process
} from "./chunk-PO7TFOVG.js";

// node_modules/toxiclibsjs/geom/mesh/BezierPatch.js
var require_BezierPatch = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/BezierPatch.js"(exports, module) {
    init_process();
    init_buffer();
    var Vec3D = require_Vec3D();
    var TriangleMesh = require_TriangleMesh();
    var is = require_is();
    var BezierPatch = function(points) {
      if (is.Array(points)) {
        this.points = points;
      } else {
        this.points = [];
        for (var i = 0; i < 4; i++) {
          this.points[i] = this.points[i] || [];
          for (var j = 0; j < 4; j++) {
            this.points[i][j] = new Vec3D();
          }
        }
      }
    };
    BezierPatch.prototype = {
      computePointAt: function(u, v) {
        return BezierPatch.computePointAt(u, v, this.points);
      },
      set: function(x, y, p) {
        this.points[y][x].set(p);
        return this;
      },
      toMesh: function(mesh_or_res, _res) {
        var mesh, res;
        if (_res === void 0) {
          mesh = new TriangleMesh();
          res = mesh_or_res;
        } else {
          mesh = mesh_or_res;
          res = _res;
        }
        var curr = new Array(res + 1), prev = new Array(res + 1);
        var r1 = 1 / res;
        for (var y = 0; y <= res; y++) {
          for (var x = 0; x <= res; x++) {
            var p = this.computePointAt(x * r1, y * r1, this.points);
            if (x > 0 && y > 0) {
              mesh.addFace(p, curr[x - 1], prev[x - 1]);
              mesh.addFace(p, prev[x - 1], prev[x]);
            }
            curr[x] = p;
          }
          var tmp = prev;
          prev = curr;
          curr = tmp;
        }
        return mesh;
      }
    };
    BezierPatch.computePointAt = function(u, v, points) {
      var u1 = 1 - u;
      var u1squared = u1 * u1 * 3 * u, u1cubed = u1 * u1 * u1, usquared = u * u, v1 = 1 - v, vsquared = v * v * 3, v1squared = v1 * v1 * 3, v1cubed = v1 * v1 * v1, vcubed = v * v * v, u1usq = u1 * usquared * 3, usqu = u * usquared, v1vsq = v1 * vsquared, v1sqv = v1squared * v;
      var p0 = points[0];
      var p1 = points[1];
      var p2 = points[2];
      var p3 = points[3];
      var x = u1cubed * (p0[0].x * v1cubed + p0[1].x * v1sqv + p0[2].x * v1vsq + p0[3].x * vcubed) + u1squared * (p1[0].x * v1cubed + p1[1].x * v1sqv + p1[2].x * v1vsq + p1[3].x * vcubed) + u1usq * (p2[0].x * v1cubed + p2[1].x * v1sqv + p2[2].x * v1vsq + p2[3].x * vcubed) + usqu * (p3[0].x * v1cubed + p3[1].x * v1sqv + p3[2].x * v1vsq + p3[3].x * vcubed);
      var y = u1cubed * (p0[0].y * v1cubed + p0[1].y * v1sqv + p0[2].y * v1vsq + p0[3].y * vcubed) + u1squared * (p1[0].y * v1cubed + p1[1].y * v1sqv + p1[2].y * v1vsq + p1[3].y * vcubed) + u1usq * (p2[0].y * v1cubed + p2[1].y * v1sqv + p2[2].y * v1vsq + p2[3].y * vcubed) + usqu * (p3[0].y * v1cubed + p3[1].y * v1sqv + p3[2].y * v1vsq + p3[3].y * vcubed);
      var z = u1cubed * (p0[0].z * v1cubed + p0[1].z * v1sqv + p0[2].z * v1vsq + p0[3].z * vcubed) + u1squared * (p1[0].z * v1cubed + p1[1].z * v1sqv + p1[2].z * v1vsq + p1[3].z * vcubed) + u1usq * (p2[0].z * v1cubed + p2[1].z * v1sqv + p2[2].z * v1vsq + p2[3].z * vcubed) + usqu * (p3[0].z * v1cubed + p3[1].z * v1sqv + p3[2].z * v1vsq + p3[3].z * vcubed);
      return new Vec3D(x, y, z);
    };
    module.exports = BezierPatch;
  }
});

// node_modules/toxiclibsjs/geom/mesh/VertexSelector.js
var require_VertexSelector = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/VertexSelector.js"(exports, module) {
    init_process();
    init_buffer();
    var VertexSelector = function(mesh) {
      this.mesh = mesh;
      this.selection = [];
    };
    VertexSelector.prototype = {
      /**
          * Adds all vertices selected by the given selector to the current
          * selection. The other selector needs to be assigned to the same mesh
          * instance.
          * @param sel2 other selector
          * @return itself
          */
      addSelection: function(sel2) {
        this.checkMeshIdentity(sel2.getMesh());
        this.selection = this.selection.concat(sel2.getSelection());
        return this;
      },
      /**
          * Utility function to check if the given mesh is the same instance as ours.
          * @param mesh2
          */
      checkMeshIdentity: function(mesh2) {
        if (mesh2 != this.mesh) {
          throw new Error("The given selector is not using the same mesh instance");
        }
      },
      clearSelection: function() {
        this.selection = [];
        return this;
      },
      getMesh: function() {
        return this.mesh;
      },
      getSelection: function() {
        return this.selection;
      },
      /**
       * Creates a new selection of all vertices NOT currently selected.
       * @return itself
       */
      invertSelection: function() {
        var newSel = [];
        var vertices2 = this.mesh.getVertices();
        var l = vertices2.length;
        for (var i = 0; i < l; i++) {
          var v = vertices2[i];
          if (this.selection.indexOf(v) < 0) {
            newSel.push(v);
          }
        }
        this.selection = newSel;
        return this;
      },
      /**
          * Selects vertices identical or closest to the ones given in the list of
          * points.
          * @param points
          * @return itself
          */
      selectSimilar: function(points) {
        var l = points.length;
        for (var i = 0; i < l; i++) {
          var v = points[i];
          this.selection.push(this.mesh.getClosestVertexToPoint(v));
        }
        return this;
      },
      /**
      * Selects vertices using an implementation specific method. This is the
      * only method which needs to be implemented by any selector subclass.
      * @return itself
      */
      selectVertices: function() {
        return this;
      },
      setMesh: function(mesh) {
        this.mesh = mesh;
        this.clearSelection();
      },
      size: function() {
        return this.selection.length;
      },
      /**
          * Removes all vertices selected by the given selector from the current
          * selection. The other selector needs to be assigned to the same mesh
          * instance.
          * @param sel2 other selector
          * @return itself
          */
      subtractSelection: function(sel2) {
        this.checkMeshIdentity(sel2.getMesh());
        var removeThese = sel2.getSelection();
        var i, l = removeThese.length;
        for (i = 0; i < l; i++) {
          this.selection.splice(this.selection.indexOf(removeThese[i]), 1);
        }
        return this;
      }
    };
    module.exports = VertexSelector;
  }
});

// node_modules/toxiclibsjs/geom/mesh/BoxSelector.js
var require_BoxSelector = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/BoxSelector.js"(exports, module) {
    init_process();
    init_buffer();
    var extend = require_internals().extend;
    var VertexSelector = require_VertexSelector();
    var BoxSelector = function(mesh, box) {
      VertexSelector.apply(this, [mesh]);
      this.box = box;
    };
    extend(BoxSelector, VertexSelector);
    BoxSelector.prototype.selectVertices = function() {
      this.clearSelection();
      var verts = this.mesh.getVertices();
      var l = verts.length;
      for (var i = 0; i < l; i++) {
        var v = verts[i];
        if (this.box.containsPoint(v)) {
          this.selection.add(v);
        }
      }
      return this;
    };
    module.exports = BoxSelector;
  }
});

// node_modules/toxiclibsjs/geom/mesh/DefaultSelector.js
var require_DefaultSelector = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/DefaultSelector.js"(exports, module) {
    init_process();
    init_buffer();
    var extend = require_internals().extend;
    var VertexSelector = require_VertexSelector();
    var DefaultSelector = function(mesh) {
      VertexSelector.call(this, mesh);
    };
    extend(DefaultSelector, VertexSelector);
    DefaultSelector.prototype.selectVertices = function() {
      this.clearSelection();
      this.selection = this.selection.concat(this.mesh.getVertices());
      return this;
    };
    module.exports = DefaultSelector;
  }
});

// node_modules/toxiclibsjs/geom/mesh/OBJWriter.js
var require_OBJWriter = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/OBJWriter.js"(exports, module) {
    init_process();
    init_buffer();
    var internals = require_internals();
    var StringBuffer = function() {
      this.buffer = [];
    };
    StringBuffer.prototype.append = function(string) {
      this.buffer.push(string);
      return this;
    };
    StringBuffer.prototype.toString = function() {
      return this.buffer.join("");
    };
    var OBJWriter = function() {
      this.VERSION = "0.3";
      this.__stringBuffer = new StringBuffer();
      this.objStream = void 0;
      this.__filename = "objwriter.obj";
      this._numVerticesWritten = 0;
      this._numNormalsWritten = 0;
    };
    OBJWriter.prototype = {
      /**
       * begin saving
       * @param {WritableStream | String} [stream] stream can be a node.js WritableStream, or it can be a filename or undefined
       */
      beginSave: function(stream) {
        if (typeof stream == "string") {
        } else if (internals.hasProperties(stream, ["write", "end", "writable"] && stream.writable)) {
          this.objStream = stream;
        } else {
        }
        this._handleBeginSave();
      },
      endSave: function() {
        if (this.objStream !== void 0) {
          try {
            this.objStream.destroy();
          } catch (e) {
          }
        }
      },
      face: function(a, b, c) {
        this.__stringBuffer.append("f " + a + " " + b + " " + c + "\n");
      },
      faceList: function() {
        this.__stringBuffer.append("s off \n");
      },
      faceWithNormals: function(a, b, c, na, nb, nc) {
        this.__stringBuffer.append("f " + a + "//" + na + " " + b + "//" + nb + " " + c + "//" + nc + "\n");
      },
      getCurrNormalOffset: function() {
        return this._numNormalsWritten;
      },
      getCurrVertexOffset: function() {
        return this._numVerticesWritten;
      },
      //not in java version
      getOutput: function() {
        return this.__stringBuffer.toString();
      },
      _handleBeginSave: function() {
        this.numVerticesWritten = 0;
        this.numNormalsWrittern = 0;
        this.__stringBuffer.append("# generated by OBJExport (js) v" + this.VERSION + "\n");
      },
      newObject: function(name) {
        this.__stringBuffer.append("o " + name + "\n");
      },
      normal: function(vecN) {
        this.__stringBuffer.append("vn " + vecN.x + " " + vecN.y + " " + vecN.z + "\n");
        this._numNormalsWritten++;
      },
      vertex: function(vecV) {
        this.__stringBuffer.append("v " + vecV.x + " " + vecV.y + " " + vecV.z + "\n");
        this._numVerticesWritten++;
      }
    };
    module.exports = OBJWriter;
  }
});

// node_modules/toxiclibsjs/geom/mesh/PlaneSelector.js
var require_PlaneSelector = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/PlaneSelector.js"(exports, module) {
    init_process();
    init_buffer();
    var extend = require_internals().extend;
    var VertexSelector = require_VertexSelector();
    var PlaneSelector = function(mesh, plane, classifier, tolerance) {
      VertexSelector.apply(this, [mesh]);
      this.plane = plane;
      this.classifier = classifier;
      this.tolerances = tolerance === void 0 ? 1e-4 : tolerance;
    };
    extend(PlaneSelector, VertexSelector);
    PlaneSelector.prototype.selectVertices = function() {
      this.clearSelection();
      var verts = this.mesh.getVertices();
      var l = verts.length;
      for (var i = 0; i < l; i++) {
        var v = verts[i];
        if (this.plane.classifyPoint(v, this.tolerance) == this.classifier) {
          this.selection.add(v);
        }
      }
      return this;
    };
    module.exports = PlaneSelector;
  }
});

// node_modules/toxiclibsjs/geom/mesh/SphereFunction.js
var require_SphereFunction = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/SphereFunction.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_Sphere().SphereFunction;
  }
});

// node_modules/toxiclibsjs/geom/mesh/SphericalHarmonics.js
var require_SphericalHarmonics = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/SphericalHarmonics.js"(exports, module) {
    init_process();
    init_buffer();
    var mathUtils = require_mathUtils();
    var SphericalHarmonics = function(m) {
      this.m = m;
    };
    SphericalHarmonics.prototype = {
      // toxiclibs - FIXME check where flipped vertex order is coming from sometimes
      computeVertexFor: function(p, phi, theta) {
        var r = 0;
        r += Math.pow(mathUtils.sin(this.m[0] * theta), this.m[1]);
        r += Math.pow(mathUtils.cos(this.m[2] * theta), this.m[3]);
        r += Math.pow(mathUtils.sin(this.m[4] * phi), this.m[5]);
        r += Math.pow(mathUtils.cos(this.m[6] * phi), this.m[7]);
        var sinTheta = mathUtils.sin(theta);
        p.x = r * sinTheta * mathUtils.cos(phi);
        p.y = r * mathUtils.cos(theta);
        p.z = r * sinTheta * mathUtils.sin(phi);
        return p;
      },
      getPhiRange: function() {
        return mathUtils.TWO_PI;
      },
      getPhiResolutionLimit: function(res) {
        return res;
      },
      getThetaRange: function() {
        return mathUtils.PI;
      },
      getThetaResolutionLimit: function(res) {
        return res;
      }
    };
    module.exports = SphericalHarmonics;
  }
});

// node_modules/toxiclibsjs/geom/mesh/SurfaceMeshBuilder.js
var require_SurfaceMeshBuilder = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/SurfaceMeshBuilder.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_meshCommon().SurfaceMeshBuilder;
  }
});

// node_modules/toxiclibsjs/geom/mesh/SuperEllipsoid.js
var require_SuperEllipsoid = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/SuperEllipsoid.js"(exports, module) {
    init_process();
    init_buffer();
    var mathUtils = require_mathUtils();
    var TriangleMesh = require_TriangleMesh();
    var SuperEllipsoid = function(n1, n2) {
      this.p1 = n1;
      this.p2 = n2;
    };
    SuperEllipsoid.prototype = {
      computeVertexFor: function(p, phi, theta) {
        phi -= mathUtils.HALF_PI;
        var cosPhi = mathUtils.cos(phi), cosTheta = mathUtils.cos(theta), sinPhi = mathUtils.sin(phi), sinTheta = mathUtils.sin(theta);
        var t = mathUtils.sign(cosPhi) * Math.pow(mathUtils.abs(cosPhi), this.p1);
        p.x = t * mathUtils.sign(cosTheta) * Math.pow(Math.abs(cosTheta), this.p2);
        p.y = mathUtils.sign(sinPhi) * Math.pow(Math.abs(sinPhi), this.p1);
        p.z = t * mathUtils.sign(sinTheta) * Math.pow(mathUtils.abs(sinTheta), this.p2);
        return p;
      },
      getPhiRange: function() {
        return mathUtils.TWO_PI;
      },
      getPhiResolutionLimit: function(res) {
        return res / 2;
      },
      getThetaRange: function() {
        return mathUtils.TWO_PI;
      },
      getThetaResolutionLimit: function(res) {
        return res;
      }
    };
    module.exports = SuperEllipsoid;
  }
});

// node_modules/toxiclibsjs/geom/mesh/Terrain.js
var require_Terrain = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/Terrain.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_meshCommon().Terrain;
  }
});

// node_modules/toxiclibsjs/geom/mesh/WETriangleMesh.js
var require_WETriangleMesh = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/WETriangleMesh.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_meshCommon().WETriangleMesh;
  }
});

// node_modules/toxiclibsjs/geom/mesh.js
var require_mesh = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh.js"(exports) {
    init_process();
    init_buffer();
    exports.TriangleMesh = require_TriangleMesh();
    exports.BezierPatch = require_BezierPatch();
    exports.BoxSelector = require_BoxSelector();
    exports.DefaultSelector = require_DefaultSelector();
    exports.Face = require_Face();
    exports.OBJWriter = require_OBJWriter();
    exports.PlaneSelector = require_PlaneSelector();
    exports.SphereFunction = require_SphereFunction();
    exports.SphericalHarmonics = require_SphericalHarmonics();
    exports.SurfaceMeshBuilder = require_SurfaceMeshBuilder();
    exports.SuperEllipsoid = require_SuperEllipsoid();
    exports.Terrain = require_Terrain();
    exports.TriangleMesh = require_TriangleMesh();
    exports.Vertex = require_Vertex();
    exports.VertexSelector = require_VertexSelector();
    exports.WETriangleMesh = require_WETriangleMesh();
  }
});

// node_modules/toxiclibsjs/geom/CircleIntersector.js
var require_CircleIntersector = __commonJS({
  "node_modules/toxiclibsjs/geom/CircleIntersector.js"(exports, module) {
    init_process();
    init_buffer();
    var CircleIntersector = function(circle2) {
      this.circle = circle2;
      this.isec = void 0;
    };
    CircleIntersector.prototype = {
      getIntersectionData: function() {
        return this.isec;
      },
      intersectsRay: function(ray) {
        this.isec.clear();
        var q = circle.sub(ray), distSquared = q.magSquared(), v = q.dot(ray.getDirection()), r = circle.getRadius(), d = r * r - (distSquared - v * v);
        if (d >= 0) {
          this.isec.isIntersection = true;
          this.isec.dist = v - Math.sqrt(d);
          this.isec.pos = ray.getPointAtDistance(isec.dist);
          this.isec.normal = this.isec.pos.sub(this.circle).normalize();
        }
        return this.isec.isIntersection;
      }
    };
    module.exports = CircleIntersector;
  }
});

// node_modules/toxiclibsjs/geom/Cone.js
var require_Cone = __commonJS({
  "node_modules/toxiclibsjs/geom/Cone.js"(exports, module) {
    init_process();
    init_buffer();
    var extend = require_internals().extend;
    var Vec3D = require_Vec3D();
    var TriangleMesh = require_TriangleMesh();
    function err(param) {
      throw Error("Missing parameter: " + param);
    }
    var Cone = function(pos, dir, rNorth, rSouth, len) {
      var self = this;
      if (typeof pos === "object" && arguments.length === 1) {
        process(
          pos.pos || pos.position || new Vec3D(),
          pos.dir || pos.direction || err("direction"),
          pos.rNorth || pos.radiusNorth || err("radiusNorth"),
          pos.rSouth || pos.radiusSouth || err("radiusSouth"),
          pos.len || pos.length || err("length")
        );
      } else {
        process(pos, dir, rNorth, rSouth, len);
      }
      function process(pos2, dir2, radiusNorth, radiusSouth, length) {
        Vec3D.apply(self, [pos2]);
        self.dir = dir2.getNormalized();
        self.radiusNorth = radiusNorth;
        self.radiusSouth = radiusSouth;
        self.length = length;
      }
    };
    extend(Cone, Vec3D);
    Cone.prototype.toMesh = function(args) {
      var opts = {
        mesh: void 0,
        steps: NaN,
        thetaOffset: 0,
        topClosed: true,
        bottomClosed: true
      };
      if (arguments.length == 1) {
        if (typeof arguments[0] == "object") {
          var optionsObject = arguments[0];
          opts.mesh = optionsObject.mesh;
          opts.steps = optionsObject.steps || optionsObject.resolution || optionsObject.res;
          opts.thetaOffset = optionsObject.thetaOffset || opts.thetaOffset;
          opts.topClosed = optionsObject.topClosed || opts.topClosed;
          opts.bottomClosed = optionsObject.bottomClosed || opts.bottomClosed;
        } else {
          opts.steps = arguments[0];
        }
      } else if (arguments.length == 2) {
        opts.steps = arguments[0];
        opts.thetaOffset = arguments[1];
      } else if (arguments.length == 5) {
        opts.mesh = arguments[0];
        opts.steps = arguments[1];
        opts.thetaOffset = arguments[2];
        opts.topClosed = arguments[3];
        opts.bottomClosed = arguments[4];
      }
      var c = this.add(0.01, 0.01, 0.01), n = c.cross(this.dir.getNormalized()).normalize(), halfAxis = this.dir.scale(this.length * 0.5), p = this.sub(halfAxis), q = this.add(halfAxis), south = [], north = [], phi = Math.PI * 2 / opts.steps;
      var i = 0, j = 1;
      for (i = 0; i < opts.steps; i++) {
        var theta = i * phi + opts.thetaOffset;
        var nr = n.getRotatedAroundAxis(this.dir, theta);
        south[i] = nr.scale(this.radiusSouth).addSelf(p);
        north[i] = nr.scale(this.radiusNorth).addSelf(q);
      }
      var numV = opts.steps * 2 + 2, numF = opts.steps * 2 + (opts.topClosed ? opts.steps : 0) + (opts.bottomClosed ? opts.steps : 0), mesh = opts.mesh || new TriangleMesh("cone", numV, numF);
      for (i = 0; i < opts.steps; i++, j++) {
        if (j == opts.steps) {
          j = 0;
        }
        mesh.addFace(south[i], north[i], south[j], void 0, void 0, void 0, void 0);
        mesh.addFace(south[j], north[i], north[j], void 0, void 0, void 0, void 0);
        if (opts.bottomClosed) {
          mesh.addFace(p, south[i], south[j], void 0, void 0, void 0, void 0);
        }
        if (opts.topClosed) {
          mesh.addFace(north[i], q, north[j], void 0, void 0, void 0, void 0);
        }
      }
      return mesh;
    };
    module.exports = Cone;
  }
});

// node_modules/toxiclibsjs/geom/ConvexPolygonClipper.js
var require_ConvexPolygonClipper = __commonJS({
  "node_modules/toxiclibsjs/geom/ConvexPolygonClipper.js"(exports, module) {
    init_process();
    init_buffer();
    var Line2D = require_Line2D();
    var Polygon2D = require_Polygon2D();
    var ConvexPolygonClipper = function(polygonBounds) {
      this.setBounds(polygonBounds);
    };
    ConvexPolygonClipper.prototype = {
      constructor: ConvexPolygonClipper,
      clipPolygon: function(poly) {
        var points = poly.vertices.slice(0), clipped, boundsEdges = this.bounds.getEdges(), clipEdge, i = 0, j = 0, _tmp, sign, p, q;
        points.push(points[0]);
        for (i = 0; i < boundsEdges.length; i++) {
          clipEdge = boundsEdges[i];
          clipped = [];
          sign = clipEdge.classifyPoint(this.boundsCentroid);
          for (j = 0; j < points.length - 1; j++) {
            p = points[j];
            q = points[j + 1];
            if (clipEdge.classifyPoint(p) === sign) {
              if (clipEdge.classifyPoint(q) === sign) {
                clipped.push(q.copy());
              } else {
                clipped.push(this._getClippedPosOnEdge(clipEdge, p, q));
              }
              continue;
            }
            if (clipEdge.classifyPoint(q) === sign) {
              clipped.push(this._getClippedPosOnEdge(clipEdge, p, q));
              clipped.push(q.copy());
            }
          }
          if (clipped.length > 0 && clipped[0] !== clipped[clipped.length - 1]) {
            clipped.push(clipped[0]);
          }
          _tmp = points;
          points = clipped;
          clipped = _tmp;
        }
        return new Polygon2D(points).removeDuplicates(1e-3);
      },
      getBounds: function() {
        return this.bounds;
      },
      _getClippedPosOnEdge: function(clipEdge, p, q) {
        return clipEdge.intersectLine(new Line2D(p, q)).getPos();
      },
      //unused but included to match, source
      _isKnownVertex: function(list, q) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i].equalsWitTolerance(q, 1e-3)) {
            return true;
          }
        }
        return false;
      },
      setBounds: function(bounds) {
        this.bounds = bounds;
        this.boundsCentroid = this.bounds.getCentroid();
      }
    };
    module.exports = ConvexPolygonClipper;
  }
});

// node_modules/toxiclibsjs/geom/IsectData2D.js
var require_IsectData2D = __commonJS({
  "node_modules/toxiclibsjs/geom/IsectData2D.js"(exports, module) {
    init_process();
    init_buffer();
    var Vec2D = require_Vec2D();
    var IsectData2D = function(isec2) {
      if (isec2 !== void 0) {
        this.isIntersection = isec2.isIntersection;
        this.dist = isec2.dist;
        this.pos = isec2.pos.copy();
        this.dir = isec2.dir.copy();
        this.normal = isec2.normal.copy();
      } else {
        this.clear();
      }
    };
    IsectData2D.prototype = {
      clear: function() {
        this.isIntersection = false;
        this.dist = 0;
        this.pos = new Vec2D();
        this.dir = new Vec2D();
        this.normal = new Vec2D();
      },
      toString: function() {
        var s = "isec: " + this.isIntersection;
        if (this.isIntersection) {
          s += " at:" + this.pos + " dist:" + this.dist + " normal:" + this.normal;
        }
        return s;
      }
    };
    module.exports = IsectData2D;
  }
});

// node_modules/toxiclibsjs/geom/LineStrip3D.js
var require_LineStrip3D = __commonJS({
  "node_modules/toxiclibsjs/geom/LineStrip3D.js"(exports, module) {
    init_process();
    init_buffer();
    var Vec3D = require_vectors().Vec3D;
    var Line3D = require_Line3D();
    var hasXYZ = require_has().XYZ;
    var Iterator = require_Iterator();
    var LineStrip3D = function(vertices2) {
      this.vertices = vertices2 || [];
    };
    LineStrip3D.prototype = {
      constructor: LineStrip3D,
      /**
      * add a vector to the line-strip, it will always be a copy
      * @param {Vec3D | Number } x either a Vec3D or an x coordinate
      * @param {Number} [y]
      * @param {Number} [z]
      * @return itself
      */
      add: function(x, y, z) {
        if (hasXYZ(x)) {
          this.vertices.push(new Vec3D(x));
        } else {
          this.vertices.push(new Vec3D(x, y, z));
        }
        return this;
      },
      get: function(i) {
        if (i < 0) {
          i += this.vertices.length;
        }
        return this.vertices[i];
      },
      /**
      * Computes a list of points along the spline which are uniformly separated
      * by the given step distance.
      *
      * @param {Number} step
      * @param {Boolean} [doAddFinalVertex] true by default
      * @return {Vec3D[]} point list
      */
      getDecimatedVertices: function(step, doAddFinalVertex) {
        if (doAddFinalVertex !== false) {
          doAddFinalVertex = true;
        }
        var uniform = [];
        if (this.vertices.length < 3) {
          if (this.vertices.length === 2) {
            new Line3D(this.vertices[0], this.vertices[1]).splitIntoSegments(uniform, step, true);
            if (!doAddFinalVertex) {
              uniform.pop();
            }
          } else {
            return;
          }
        }
        var arcLen = this.getEstimatedArcLength(), delta = step / arcLen, currIdx = 0, currT, t, p, q, frac, i;
        for (t = 0; t < 1; t += delta) {
          currT = t * arcLen;
          while (currT >= this.arcLenIndex[currIdx]) {
            currIdx++;
          }
          p = this.get(currIdx - 1);
          q = this.get(currIdx);
          frac = (currT - this.arcLenIndex[currIdx - 1]) / (this.arcLenIndex[currIdx] - this.arcLenIndex[currIdx - 1]);
          i = p.interpolateTo(q, frac);
          uniform.push(i);
        }
        if (doAddFinalVertex) {
          uniform.push(this.get(-1).copy());
        }
        return uniform;
      },
      getEstimatedArcLength: function() {
        if (this.arcLenIndex === void 0 || this.arcLenIndex.length !== this.vertices.length) {
          this.arcLenIndex = [0];
        }
        var arcLen = 0, p, q;
        for (var i = 1, l = this.vertices.length; i < l; i++) {
          p = this.vertices[i - 1];
          q = this.vertices[i];
          arcLen += p.distanceTo(q);
          this.arcLenIndex[i] = arcLen;
        }
        return arcLen;
      },
      getSegments: function() {
        var i = 1, num = this.vertices.length, segments = [];
        for (; i < num; i++) {
          segments.push(new Line3D(this.get(i - 1), this.get(i)));
        }
        return segments;
      },
      getVertices: function() {
        return vertices;
      },
      iterator: function() {
        return new Iterator(this.vertices);
      },
      setVertices: function(vertices2) {
        this.vertices = vertices2;
      }
    };
    module.exports = LineStrip3D;
  }
});

// node_modules/toxiclibsjs/geom/Plane.js
var require_Plane = __commonJS({
  "node_modules/toxiclibsjs/geom/Plane.js"(exports, module) {
    init_process();
    init_buffer();
    var extend = require_internals().extend;
    var mathUtils = require_mathUtils();
    var Ray3D = require_Ray3D();
    var vectors = require_vectors();
    var Vec3D = vectors.Vec3D;
    var Vec2D = vectors.Vec2D;
    var TriangleMesh = require_TriangleMesh();
    var Plane = function(tri_or_origin, norm) {
      var origin, normal;
      if (arguments.length === 0) {
        origin = new Vec3D();
        normal = Vec3D.Y_AXIS.copy();
      } else if (arguments.length == 1) {
        origin = arguments[0].computeCentroid();
        normal = arguments[0].computeNormal();
      } else {
        origin = arguments[0];
        normal = arguments[1].getNormalized();
      }
      Vec3D.apply(this, [origin]);
      this.normal = normal;
    };
    extend(Plane, Vec3D);
    Plane.Classifier = {
      FRONT: "front",
      BACK: "back",
      ON_PLANE: "on plane"
    };
    Plane.XY = new Plane(new Vec3D(), Vec3D.Z_AXIS);
    Plane.XZ = new Plane(new Vec3D(), Vec3D.Y_AXIS);
    Plane.YZ = new Plane(new Vec3D(), Vec3D.X_AXIS);
    Plane.prototype.classifyPoint = function(p, tolerance) {
      var d = this.sub(p).normalize().dot(this.normal);
      if (d < -tolerance) {
        return Plane.Classifier.FRONT;
      } else if (d > tolerance) {
        return Plane.Classifier.BACK;
      }
      return Plane.Classifier.ON_PLANE;
    };
    Plane.prototype.containsPoint = function(p) {
      return this.classifyPoint(p, mathUtils.EPS) == Plane.Classifier.ON_PLANE;
    };
    Plane.prototype.getDistanceToPoint = function(p) {
      var sn = this.normal.dot(p.sub(this)), sd = this.normal.magSquared(), isec2 = p.add(this.normal.scale(sn / sd));
      return isec2.distanceTo(p);
    };
    Plane.prototype.getIntersectionWithRay = function(r) {
      var denom = this.normal.dot(r.getDirection()), u;
      if (denom > mathUtils.EPS) {
        u = this.normal.dot(this.sub(r)) / denom;
        return r.getPointAtDistance(u);
      } else {
        return void 0;
      }
    };
    Plane.prototype.getProjectedPoint = function(p) {
      var dir, proj;
      if (this.normal.dot(this.sub(p)) < 0) {
        dir = this.normal.getInverted();
      } else {
        dir = this.normal;
      }
      proj = new Ray3D(p, dir).getPointAtDistance(this.getDistanceToPoint(p));
      return proj;
    };
    Plane.prototype.intersectRayDistance = function(ray) {
      var d = this.normal.dot(this), numer = this.normal.dot(ray) + d, denom = this.normal.dot(ray.dir);
      if (mathUtils.abs(denom) < mathUtils.EPS) {
        return -1;
      }
      return -(numer / denom);
    };
    Plane.prototype.toMesh = function(mesh, size) {
      if (arguments.length === 1 && typeof arguments[0] == "number") {
        size = mesh;
        mesh = null;
      }
      mesh = mesh || new TriangleMesh("plane", 4, 2);
      var p = this.equalsWithTolerance(Vec3D.ZERO, 0.01) ? this.add(0.01, 0.01, 0.01) : this;
      size *= 0.5;
      var n = p.cross(this.normal).normalizeTo(size), m = n.cross(this.normal).normalizeTo(size), a = this.add(n).addSelf(m), b = this.add(n).subSelf(m), c = this.sub(n).subSelf(m), d = this.sub(n).addSelf(m);
      mesh.addFace(a, d, b, void 0, void 0, void 0, void 0);
      mesh.addFace(b, d, c, void 0, void 0, void 0, void 0);
      return mesh;
    };
    module.exports = Plane;
  }
});

// node_modules/toxiclibsjs/geom/Ray3DIntersector.js
var require_Ray3DIntersector = __commonJS({
  "node_modules/toxiclibsjs/geom/Ray3DIntersector.js"(exports, module) {
    init_process();
    init_buffer();
    var IsectData3D = require_IsectData3D();
    var mathUtils = require_mathUtils();
    var Ray3DIntersector;
    Ray3DIntersector = function(ray) {
      this.ray = ray;
      this.isec = new IsectData3D();
    };
    Ray3DIntersector.prototype = {
      getIntersectionData: function() {
        return this.isec;
      },
      intersectsRay: function(other) {
        var n = this.ray.dir.cross(other.dir);
        var sr = this.ray.sub(other);
        var absX = mathUtils.abs(n.x);
        var absY = mathUtils.abs(n.y);
        var absZ = mathUtils.abs(n.z);
        var t;
        if (absZ > absX && absZ > absY) {
          t = (sr.x * other.dir.y - sr.y * other.dir.x) / n.z;
        } else if (absX > absY) {
          t = (sr.y * other.dir.z - sr.z * other.dir.y) / n.x;
        } else {
          t = (sr.z * other.dir.x - sr.x * other.dir.z) / n.y;
        }
        this.isec.isIntersection = t <= mathUtils.EPS && !isFinite(t);
        this.isec.pos = this.ray.getPointAtDistance(-t);
        return this.isec.isIntersection;
      }
    };
    module.exports = Ray3DIntersector;
  }
});

// node_modules/toxiclibsjs/geom/Spline3D.js
var require_Spline3D = __commonJS({
  "node_modules/toxiclibsjs/geom/Spline3D.js"(exports, module) {
    init_process();
    init_buffer();
    var Vec3D = require_Vec3D();
    var is = require_is();
    var BernsteinPolynomial = require_BernsteinPolynomial();
    var Spline3D = function(points, bernsteinPoly, tightness) {
      if (arguments.length === 1 && !is.Array(points) && is.Object(points)) {
        bernsteinPoly = bernsteinPoly || points.bernsteinPoly;
        tightness = tightness || points.tightness;
        points = points.points;
      }
      var i = 0, l;
      this.pointList = [];
      if (typeof tightness !== "number") {
        tightness = Spline3D.DEFAULT_TIGHTNESS;
      }
      this.setTightness(tightness);
      this.bernstein = bernsteinPoly;
      if (points !== void 0) {
        for (i = 0, l = points.length; i < l; i++) {
          this.add(points[i].copy());
        }
      }
      this.coeffA = [];
      this.delta = [];
      this.bi = [];
      for (i = 0; i < this.numP; i++) {
        this.coeffA[i] = new Vec3D();
        this.delta[i] = new Vec3D();
        this.bi[i] = 0;
      }
      this.bi = [];
    };
    Spline3D.prototype = {
      add: function(p) {
        this.pointList.push(p.copy());
        this.numP = this.pointList.length;
        return this;
      },
      computeVertices: function(res) {
        this.updateCoefficients();
        if (res < 1) {
          res = 1;
        }
        res++;
        if (this.bernstein === void 0 || this.bernstein.resolution != res) {
          this.bernstein = new BernsteinPolynomial(res);
        }
        var bst = this.bernstein;
        this.vertices = [];
        this.findCPoints();
        var deltaP = new Vec3D();
        var deltaQ = new Vec3D();
        res--;
        for (var i = 0; i < this.numP - 1; i++) {
          var p = this.points[i];
          var q = this.points[i + 1];
          deltaP.set(this.delta[i]).addSelf(p);
          deltaQ.set(q).subSelf(this.delta[i + 1]);
          for (var k = 0; k < res; k++) {
            var x = p.x * bst.b0[k] + deltaP.x * bst.b1[k] + deltaQ.x * bst.b2[k] + q.x * bst.b3[k];
            var y = p.y * bst.b0[k] + deltaP.y * bst.b1[k] + deltaQ.y * bst.b2[k] + q.y * bst.b3[k];
            var z = p.z * bst.b0[k] + deltaP.z * bst.b1[k] + deltaQ.z * bst.b2[k] + q.z * bst.b3[k];
            this.vertices.push(new Vec3D(x, y, z));
          }
        }
        this.vertices.push(this.points[this.points.length - 1].copy());
        return this.vertices;
      },
      findCPoints: function() {
        this.bi[1] = -0.25;
        var i, p0, p2, d0;
        p0 = this.pointList[0];
        p2 = this.pointList[2];
        d0 = this.delta[0];
        this.coeffA[1].set(
          (p2.x - p0.x - d0.x) * this.tightness,
          //x
          (p2.y - p0.y - d0.y) * this.tightness,
          //y
          (p2.z - p0.z - d0.z) * this.tightness
          //z
        );
        for (i = 2; i < this.numP - 1; i++) {
          this.bi[i] = -1 / (this.invTightness + this.bi[i - 1]);
          this.coeffA[i].set(
            -(this.points[i + 1].x - this.points[i - 1].x - this.coeffA[i - 1].x) * this.bi[i],
            -(this.points[i + 1].y - this.points[i - 1].y - this.coeffA[i - 1].y) * this.bi[i],
            -(this.points[i + 1].z - this.points[i - 1].z - this.coeffA[i - 1].z) * this.bi[i]
          );
        }
        for (i = this.numP - 2; i > 0; i--) {
          this.delta[i].set(
            this.coeffA[i].x + this.delta[i + 1].x * this.bi[i],
            this.coeffA[i].y + this.delta[i + 1].y * this.bi[i],
            this.coeffA[i].z + this.delta[i + 1].z * this.bi[i]
          );
        }
      },
      getDecimatedVertices: function(step, doAddFinalVertex) {
        if (doAddFinalVertex === void 0) doAddFinalVertex = true;
        if (this.vertices === void 0 || this.vertices.length < 2) {
          this.computeVertices(Spline3D.DEFAULT_RES);
        }
        var arcLen = this.getEstimatedArcLength();
        var uniform = [];
        var delta = step / arcLen;
        var currIdx = 0;
        for (var t = 0; t < 1; t += delta) {
          var currT = t * arcLen;
          while (currT >= this.arcLenIndex[currIdx]) {
            currIdx++;
          }
          var p = this.vertices[currIdx - 1];
          var q = this.vertices[currIdx];
          var frac = (currT - this.arcLenIndex[currIdx - 1]) / (this.arcLenIndex[currIdx] - this.arcLenIndex[currIdx - 1]);
          var i = p.interpolateTo(q, frac);
          uniform.push(i);
        }
        if (doAddFinalVertex) {
          uniform.push(this.vertices[this.vertices.length - 1]);
        }
        return uniform;
      },
      getEstimatedArcLength: function() {
        var len;
        var arcLen = 0;
        if (this.arcLenIndex === void 0 || this.arcLenIndex !== void 0 && this.arcLenIndex.length != this.vertices.length) {
          this.arcLenIndex = [0];
          len = this.vertices.length;
        } else {
          len = this.arcLenIndex.length;
        }
        for (var i = 1; i < len; i++) {
          var p = this.vertices[i - 1];
          var q = this.vertices[i];
          arcLen += p.distanceTo(q);
          this.arcLenIndex[i] = arcLen;
        }
        return arcLen;
      },
      getNumPoints: function() {
        return this.numP;
      },
      getPointList: function() {
        return this.pointList;
      },
      getTightness: function() {
        return this.tightness;
      },
      setPointList: function(plist) {
        this.pointList = plist.slice(0);
        return this;
      },
      setTightness: function(tight) {
        this.tightness = tight;
        this.invTightness = 1 / this.tightness;
        return this;
      },
      updateCoefficients: function() {
        this.numP = this.pointList.length;
        if (this.points === void 0 || this.points !== void 0 && this.points.length != this.numP) {
          this.coeffA = [];
          this.delta = [];
          this.bi = [];
          for (var i = 0; i < this.numP; i++) {
            this.coeffA[i] = new Vec3D();
            this.delta[i] = new Vec3D();
          }
          this.setTightness(this.tightness);
        }
        this.points = this.pointList.slice(0);
      }
    };
    Spline3D.DEFAULT_TIGHTNESS = 0.25;
    Spline3D.DEFAULT_RES = 16;
    module.exports = Spline3D;
  }
});

// node_modules/toxiclibsjs/geom/SutherlandHodgemanClipper.js
var require_SutherlandHodgemanClipper = __commonJS({
  "node_modules/toxiclibsjs/geom/SutherlandHodgemanClipper.js"(exports, module) {
    init_process();
    init_buffer();
    var Polygon2D = require_Polygon2D();
    var Vec2D = require_vectors().Vec2D;
    var clippedPos = {
      0: function(b, p1, p2) {
        var x = p1.x + (b.y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);
        return new Vec2D(x, b.y);
      },
      1: function(b, p1, p2) {
        var bx = b.x + b.width;
        var y = p1.y + (bx - p1.x) * (p2.y - p1.y) / (p2.x - p1.x);
        return new Vec2D(bx, y);
      },
      2: function(b, p1, p2) {
        var by = b.y + b.height;
        var x = p1.x + (by - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);
        return new Vec2D(x, by);
      },
      3: function(b, p1, p2) {
        var y = p1.y + (b.x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x);
        return new Vec2D(b.x, y);
      }
    };
    var getClippedPosOnEdge = function(bounds, edgeID, p1, p2) {
      return clippedPos[edgeID](bounds, p1, p2);
    };
    var insideEdgeConditions = {
      0: function(bounds, p) {
        return p.y >= bounds.y;
      },
      1: function(bounds, p) {
        return p.x < bounds.x + bounds.width;
      },
      2: function(bounds, p) {
        return p.y < bounds.y + bounds.height;
      },
      3: function(bounds, p) {
        return p.x >= bounds.x;
      }
    };
    var isInsideEdge = function(bounds, p, edgeID) {
      return insideEdgeConditions[edgeID](bounds, p);
    };
    var SutherlandHodgemanClipper = function(bounds) {
      this.bounds = bounds;
    };
    SutherlandHodgemanClipper.prototype = {
      constructor: SutherlandHodgemanClipper,
      clipPolygon: function(poly) {
        var points = poly.vertices.slice(0), clipped, edgeID = 0, i = 0, num = points.length - 1, p, q;
        points.push(points[0]);
        for (; edgeID < 4; edgeID++) {
          i = 0;
          num = points.length - 1;
          clipped = [];
          for (; i < num; i++) {
            p = points[i];
            q = points[i + 1];
            if (isInsideEdge(this.bounds, p, edgeID)) {
              if (isInsideEdge(this.bounds, q, edgeID)) {
                clipped.push(q.copy());
              } else {
                clipped.push(getClippedPosOnEdge(this.bounds, edgeID, p, q));
              }
              continue;
            }
            if (isInsideEdge(this.bounds, q, edgeID)) {
              clipped.push(getClippedPosOnEdge(this.bounds, edgeID, p, q));
              clipped.push(q.copy());
            }
          }
          if (clipped.length > 0 && clipped[0] !== clipped[clipped.length - 1]) {
            clipped.push(clipped[0]);
          }
          points = clipped;
        }
        return new Polygon2D(points).removeDuplicates(1e-3);
      },
      getBounds: function() {
        return this.bounds;
      },
      //protected + unused in java
      isKnownVertex: function(list, q) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i].equalsWithTolerance(q, 1e-4)) {
            return true;
          }
        }
        return false;
      },
      setBounds: function(bounds) {
        this.bounds = bounds;
      }
    };
    module.exports = SutherlandHodgemanClipper;
  }
});

// node_modules/toxiclibsjs/geom/Triangle2D.js
var require_Triangle2D = __commonJS({
  "node_modules/toxiclibsjs/geom/Triangle2D.js"(exports, module) {
    init_process();
    init_buffer();
    var Vec2D = require_Vec2D();
    var Line2D = require_Line2D();
    var Rect = require_Rect();
    var Circle = require_Circle();
    var Polygon2D = require_Polygon2D();
    var mathUtils = require_mathUtils();
    var Triangle2D = function(_a, _b, _c) {
      if (arguments.length === 3) {
        this.a = _a.copy();
        this.b = _b.copy();
        this.c = _c.copy();
      }
    };
    Triangle2D.createEquilateralFrom = function(a, b) {
      var c = a.interpolateTo(b, 0.5), dir = a.sub(b), n = dir.getPerpendicular();
      c.addSelf(n.normalizeTo(dir.magnitude() * mathUtils.SQRT3 / 2));
      return new Triangle2D(a, b, c);
    };
    Triangle2D.isClockwise = function(a, b, c) {
      var determ = (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
      return determ < 0;
    };
    Triangle2D.prototype = {
      adjustTriangleSizeBy: function(offAB, offBC, offCA) {
        if (arguments.length == 1) {
          offBC = offAB;
          offCA = offAB;
        }
        this.computeCentroid();
        var ab = new Line2D(this.a.copy(), this.b.copy()).offsetAndGrowBy(offAB, 1e5, this.centroid);
        var bc = new Line2D(this.b.copy(), this.c.copy()).offsetAndGrowBy(offBC, 1e5, this.centroid);
        var ca = new Line2D(this.c.copy(), this.a.copy()).offsetAndGrowBy(offCA, 1e5, this.centroid);
        this.a = ab.intersectLine(ca).getPos();
        this.b = ab.intersectLine(bc).getPos();
        this.c = bc.intersectLine(ca).getPos();
        this.computeCentroid();
        return this;
      },
      computeCentroid: function() {
        this.centroid = this.a.add(this.b).addSelf(this.c).scaleSelf(1 / 3);
        return this.centroid;
      },
      /**
          * Checks if point vector is inside the triangle created by the points a, b
          * and c. These points will create a plane and the point checked will have
          * to be on this plane in the region between a,b,c.
          * 
          * Note: The triangle must be defined in clockwise order a,b,c
          * 
          * @return true, if point is in triangle.
          */
      containsPoint: function(_p) {
        var v1 = _p.sub(this.a).normalize(), v2 = _p.sub(this.b).normalize(), v3 = _p.sub(this.c).normalize(), totalAngles = Math.acos(v1.dot(v2));
        totalAngles += Math.acos(v2.dot(v3));
        totalAngles += Math.acos(v3.dot(v1));
        return mathUtils.abs(totalAngles - mathUtils.TWO_PI) <= 0.01;
      },
      copy: function() {
        return new Triangle2D(this.a.copy(), this.b.copy(), this.c.copy());
      },
      flipVertexOrder: function() {
        var t = this.a;
        this.a = this.c;
        this.c = t;
        return this;
      },
      getArea: function() {
        return this.b.sub(this.a).cross(this.c.sub(this.a)) * 0.5;
      },
      getBounds: function() {
        return new Rect(Vec2D.min(Vec2D.min(this.a, this.b), this.c), Vec2D.max(Vec2D.max(this.a, this.b), this.c));
      },
      getCircumCircle: function() {
        var cr = this.a.bisect(this.b).cross(this.b.bisect(this.c)), circa = new Vec2D(cr.x / cr.z, cr.y / cr.z), sa = this.a.distanceTo(this.b), sb = this.b.distanceTo(this.c), sc = this.c.distanceTo(this.a);
        var radius = sa * sb * sc / Math.sqrt((sa + sb + sc) * (-sa + sb + sc) * (sa - sb + sc) * (sa + sb - sc));
        return new Circle(circa, radius);
      },
      getCircumference: function() {
        return this.a.distanceTo(this.b) + this.b.distanceTo(this.c) + this.c.distanceTo(this.a);
      },
      getClosestPointTo: function(_p) {
        var edge = new Line2D(this.a, this.b), Rab = edge.closestPointTo(_p), Rbc = edge.set(this.b, this.c).closestPointTo(_p), Rca = edge.set(this.c, this.a).closestPointTo(_p), dAB = _p.sub(Rab).magSquared(), dBC = _p.sub(Rbc).magSquared(), dCA = _p.sub(Rca).magSquared(), min = dAB, result = Rab;
        if (dBC < min) {
          min = dBC;
          result = Rbc;
        }
        if (dCA < min) {
          result = Rca;
        }
        return result;
      },
      intersectsTriangle: function(tri) {
        if (this.containsPoint(tri.a) || this.containsPoint(tri.b) || this.containsPoint(tri.c)) {
          return true;
        }
        if (tri.containsPoint(this.a) || tri.containsPoint(this.b) || tri.containsPoint(this.c)) {
          return true;
        }
        var ea = [
          new Line2D(this.a, this.b),
          new Line2D(this.b, this.c),
          new Line2D(this.c, this.a)
        ];
        var eb = [
          new Line2D(tri.a, tri.b),
          new Line2D(tri.b, tri.c),
          new Line2D(tri.c, tri.a)
        ];
        for (var i = 0, eaLen = ea.length; i < eaLen; i++) {
          var la = ea[i];
          for (var j = 0, ebLen = eb.length; j < ebLen; j++) {
            var lb = eb[j];
            var type = la.intersectLine(lb).getType();
            if (type != Line2D.LineIntersection.Type.NON_INTERSECTING && type != Line2D.LineIntersection.Type.PARALLEL) {
              return true;
            }
          }
        }
        return false;
      },
      isClockwise: function() {
        return Triangle2D.isClockwise(this.a, this.b, this.c);
      },
      set: function(a2, b2, c2) {
        this.a = a2;
        this.b = b2;
        this.c = c2;
      },
      toPolygon2D: function() {
        var poly = new Polygon2D();
        poly.add(this.a.copy());
        poly.add(this.b.copy());
        poly.add(this.c.copy());
        return poly;
      },
      toString: function() {
        return "Triangle2D: " + this.a + "," + this.b + "," + this.c;
      }
    };
    module.exports = Triangle2D;
  }
});

// node_modules/toxiclibsjs/geom/AxisAlignedCylinder.js
var require_AxisAlignedCylinder = __commonJS({
  "node_modules/toxiclibsjs/geom/AxisAlignedCylinder.js"(exports, module) {
    init_process();
    init_buffer();
    var Cone = require_Cone();
    var AxisAlignedCylinder = function(pos, radius, length) {
      this.pos = pos === void 0 ? void 0 : pos.copy();
      this.setRadius(radius);
      this.setLength(length);
    };
    AxisAlignedCylinder.prototype = {
      /**
      Checks if the given point is inside the cylinder. 
      @param p
      @return true, if inside
      */
      containsPoint: function(p) {
        throw Error("AxisAlignedCylinder.containsPoint(): not implmented");
      },
      /**
      @return the length
      */
      getLength: function() {
        return this.length;
      },
      /**
      @return the cylinder's orientation axis
      */
      getMajorAxis: function() {
        throw Error("AxisAlignedCylinder.getMajorAxis(): not implemented");
      },
      /**
      Returns the cylinder's position (centroid).
      @return the pos
      */
      getPosition: function() {
        return this.pos.copy();
      },
      /**
      @return the cylinder radius
      */
      getRadius: function() {
        return this.radius;
      },
      /**
      @param length the length to set
      */
      setLength: function(length) {
        this.length = length;
      },
      /**
      @param pos the pos to set
      */
      setPosition: function(pos) {
        this.pos.set(pos);
      },
      setRadius: function(radius) {
        this.radius = radius;
        this.radiusSquared = radius * radius;
      },
      /**
      Builds a TriangleMesh representation of the cylinder at a default
      resolution 30 degrees. 
      @return mesh instance
      */
      toMesh: function(a, b, c) {
        var opts = {
          mesh: void 0,
          steps: 12,
          thetaOffset: 0
        };
        if (arguments.length == 1 && typeof arguments[0] == "object") {
          for (var prop in arguments[0]) {
            opts[prop] = arguments[0][prop];
          }
        } else if (arguments.length == 2) {
          opts.steps = arguments[0];
          opts.thetaOffset = arguments[1];
        }
        var cone = new Cone(this.pos, this.getMajorAxis().getVector(), this.radius, this.radius, this.length);
        return cone.toMesh(opts.mesh, opts.steps, opts.thetaOffset, true, true);
      }
    };
    module.exports = AxisAlignedCylinder;
  }
});

// node_modules/toxiclibsjs/geom/XAxisCylinder.js
var require_XAxisCylinder = __commonJS({
  "node_modules/toxiclibsjs/geom/XAxisCylinder.js"(exports, module) {
    init_process();
    init_buffer();
    var extend = require_internals().extend;
    var mathUtils = require_mathUtils();
    var Vec3D = require_Vec3D();
    var AxisAlignedCylinder = require_AxisAlignedCylinder();
    var XAxisCylinder = function(pos, radius, length) {
      AxisAlignedCylinder.apply(this, [pos, radius, length]);
    };
    extend(XAxisCylinder, AxisAlignedCylinder);
    XAxisCylinder.prototype.containsPoint = function(p) {
      if (mathUtils.abs(p.x - this.pos.x) < this.length * 0.5) {
        var dy = p.y - this.pos.y;
        var dz = p.z - this.pos.z;
        if (Math.abs(dz * dz + dy * dy) < this.radiusSquared) {
          return true;
        }
      }
      return false;
    };
    XAxisCylinder.prototype.getMajorAxis = function() {
      return Vec3D.Axis.X;
    };
    module.exports = XAxisCylinder;
  }
});

// node_modules/toxiclibsjs/geom/YAxisCylinder.js
var require_YAxisCylinder = __commonJS({
  "node_modules/toxiclibsjs/geom/YAxisCylinder.js"(exports, module) {
    init_process();
    init_buffer();
    var extend = require_internals().extend;
    var mathUtils = require_mathUtils();
    var Vec3D = require_Vec3D();
    var AxisAlignedCylinder = require_AxisAlignedCylinder();
    var YAxisCylinder = function(pos, radius, length) {
      AxisAlignedCylinder.apply(this, [pos, radius, length]);
    };
    extend(YAxisCylinder, AxisAlignedCylinder);
    YAxisCylinder.prototype.containsPoint = function(p) {
      if (mathUtils.abs(p.y - this.pos.y) < this.length * 0.5) {
        var dx = p.x - this.pos.x;
        var dz = p.z - this.pos.z;
        if (Math.abs(dz * dz + dx * dx) < this.radiusSquared) {
          return true;
        }
      }
      return false;
    };
    YAxisCylinder.prototype.getMajorAxis = function() {
      return Vec3D.Axis.Y;
    };
    module.exports = YAxisCylinder;
  }
});

// node_modules/toxiclibsjs/geom/ZAxisCylinder.js
var require_ZAxisCylinder = __commonJS({
  "node_modules/toxiclibsjs/geom/ZAxisCylinder.js"(exports, module) {
    init_process();
    init_buffer();
    var extend = require_internals().extend;
    var mathUtils = require_mathUtils();
    var Vec3D = require_Vec3D();
    var AxisAlignedCylinder = require_AxisAlignedCylinder();
    var ZAxisCylinder = function(pos, radius, length) {
      AxisAlignedCylinder.apply(this, [pos, radius, length]);
    };
    extend(ZAxisCylinder, AxisAlignedCylinder);
    ZAxisCylinder.prototype.containsPoint = function(p) {
      if (mathUtils.abs(p.z - this.pos.z) < this.length * 0.5) {
        var dx = p.x - this.pos.x;
        var dy = p.y - this.pos.y;
        if (Math.abs(dx * dx + dy * dy) < this.radiusSquared) {
          return true;
        }
      }
      return false;
    };
    ZAxisCylinder.prototype.getMajorAxis = function() {
      return Vec3D.Axis.Z;
    };
    module.exports = ZAxisCylinder;
  }
});

// node_modules/toxiclibsjs/geom.js
var require_geom = __commonJS({
  "node_modules/toxiclibsjs/geom.js"(exports) {
    init_process();
    init_buffer();
    exports.AABB = require_AABB();
    exports.mesh = require_mesh();
    exports.BernsteinPolynomial = require_BernsteinPolynomial();
    exports.Circle = require_Circle();
    exports.CircleIntersector = require_CircleIntersector();
    exports.Cone = require_Cone();
    exports.ConvexPolygonClipper = require_ConvexPolygonClipper();
    exports.Ellipse = require_Ellipse();
    exports.IsectData2D = require_IsectData2D();
    exports.IsectData3D = require_IsectData3D();
    exports.Line2D = require_Line2D();
    exports.Line3D = require_Line3D();
    exports.LineStrip3D = require_LineStrip3D();
    exports.Matrix4x4 = require_Matrix4x4();
    exports.Plane = require_Plane();
    exports.Polygon2D = require_Polygon2D();
    exports.Quaternion = require_Quaternion();
    exports.Ray2D = require_Ray2D();
    exports.Ray3D = require_Ray3D();
    exports.Ray3DIntersector = require_Ray3DIntersector();
    exports.Rect = require_Rect();
    exports.Sphere = require_Sphere();
    exports.Spline2D = require_Spline2D();
    exports.Spline3D = require_Spline3D();
    exports.SutherlandHodgemanClipper = require_SutherlandHodgemanClipper();
    exports.Triangle2D = require_Triangle2D();
    exports.Triangle3D = require_Triangle3D();
    exports.Vec2D = require_Vec2D();
    exports.Vec3D = require_Vec3D();
    exports.XAxisCylinder = require_XAxisCylinder();
    exports.YAxisCylinder = require_YAxisCylinder();
    exports.ZAxisCylinder = require_ZAxisCylinder();
  }
});

export {
  require_geom
};
//# sourceMappingURL=chunk-KORU4FH2.js.map
