import {
  require_Vec2D,
  require_extend,
  require_has,
  require_internals,
  require_is,
  require_mathUtils,
  require_vectors
} from "./chunk-HPGC77CE.js";
import {
  __commonJS,
  init_buffer,
  init_process
} from "./chunk-PO7TFOVG.js";

// node_modules/toxiclibsjs/geom/Vec3D.js
var require_Vec3D = __commonJS({
  "node_modules/toxiclibsjs/geom/Vec3D.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_vectors().Vec3D;
  }
});

// node_modules/toxiclibsjs/geom/Matrix4x4.js
var require_Matrix4x4 = __commonJS({
  "node_modules/toxiclibsjs/geom/Matrix4x4.js"(exports, module) {
    init_process();
    init_buffer();
    var mathUtils = require_mathUtils();
    var internals = require_internals();
    var Vec3D = require_Vec3D();
    var Matrix4x4 = function(v11, v12, v13, v14, v21, v22, v23, v24, v31, v32, v33, v34, v41, v42, v43, v44) {
      this.temp = [];
      this.matrix = [];
      var self = this;
      if (arguments.length === 0) {
        this.matrix[0] = [1, 0, 0, 0];
        this.matrix[1] = [0, 1, 0, 0];
        this.matrix[2] = [0, 0, 1, 0];
        this.matrix[3] = [0, 0, 0, 1];
      } else if (typeof v11 == "number") {
        var m1 = [v11, v12, v13, v14];
        var m2 = [v21, v22, v23, v24];
        var m3 = [v31, v32, v33, v34];
        var m4 = [v41, v42, v43, v44];
        this.matrix = [m1, m2, m3, m4];
      } else if (internals.is.Array(v11)) {
        var array = v11;
        if (array.length != 9 && array.length != 16) {
          throw new Error("Matrix4x4: Array length must == 9 or 16");
        }
        if (array.length == 16) {
          this.matrix = [];
          this.matrix[0] = array.slice(0, 4);
          this.matrix[1] = array.slice(4, 8);
          this.matrix[2] = array.slice(8, 12);
          this.matrix[3] = array.slice(12);
        } else {
          this.matrix[0] = array.slice(0, 3);
          this.matrix[0][3] = NaN;
          this.matrix[1] = array.slice(3, 6);
          this.matrix[1][3] = NaN;
          this.matrix[2] = array.slice(6, 9);
          this.matrix[2][3] = NaN;
          this.matrix[3] = [NaN, NaN, NaN, NaN];
        }
      } else if (internals.is.Matrix4x4(v11)) {
        var m = v11, i2 = 0, j = 0, lenM, lenMM;
        if (m.matrix.length == 16) {
          for (i2 = 0; i2 < 4; i2++) {
            this.matrix[i2] = [m.matrix[i2][0], m.matrix[i2][1], m.matrix[i2][2], m.matrix[i2][3]];
          }
        } else {
          if (m.matrix.length == 4) {
            lenM = m.matrix.length;
            for (i2 = 0; i2 < lenM; i2++) {
              lenMM = m.matrix[i2].length;
              self.matrix[i2] = [];
              for (j = 0; j < lenMM; j++) {
                self.matrix[i2][j] = m.matrix[i2][j];
              }
            }
          }
        }
      } else {
        console.error("Matrix4x4: incorrect parameters used to construct new instance");
      }
    };
    Matrix4x4.prototype = {
      add: function(rhs) {
        var result = new Matrix4x4(this);
        return result.addSelf(rhs);
      },
      addSelf: function(m) {
        for (var i2 = 0; i2 < 4; i2++) {
          var mi = this.matrix[i2];
          var rhsm = m.matrix[i2];
          mi[0] += rhsm[0];
          mi[1] += rhsm[1];
          mi[2] += rhsm[2];
          mi[3] += rhsm[3];
        }
        return this;
      },
      /**
       * Creates a copy of the given vector, transformed by this matrix.
       *
       * @param v
       * @return transformed vector
       */
      applyTo: function(v2) {
        return this.applyToSelf(new Vec3D(v2));
      },
      applyToSelf: function(v2) {
        for (var i2 = 0; i2 < 4; i2++) {
          var m = this.matrix[i2];
          this.temp[i2] = v2.x * m[0] + v2.y * m[1] + v2.z * m[2] + m[3];
        }
        v2.set(this.temp[0], this.temp[1], this.temp[2]).scaleSelf(1 / this.temp[3]);
        return v2;
      },
      copy: function() {
        return new Matrix4x4(this);
      },
      getInverted: function() {
        return new Matrix4x4(this).invert();
      },
      getRotatedAroundAxis: function(axis, theta) {
        return new Matrix4x4(this).rotateAroundAxis(axis, theta);
      },
      getRotatedX: function(theta) {
        return new Matrix4x4(this).rotateX(theta);
      },
      getRotatedY: function(theta) {
        return new Matrix4x4(this).rotateY(theta);
      },
      getRotatedZ: function(theta) {
        return new Matrix4x4(this).rotateZ(theta);
      },
      getTransposed: function() {
        return new Matrix4x4(this).transpose();
      },
      identity: function() {
        var m = this.matrix[0];
        m[1] = m[2] = m[3] = 0;
        m = this.matrix[1];
        m[0] = m[2] = m[3] = 0;
        m = this.matrix[2];
        m[0] = m[1] = m[3] = 0;
        m = this.matrix[3];
        m[0] = m[1] = m[2] = 0;
        this.matrix[0][0] = 1;
        this.matrix[1][1] = 1;
        this.matrix[2][2] = 1;
        this.matrix[3][3] = 1;
        return this;
      },
      /**
       * Matrix Inversion using Cramer's Method Computes Adjoint matrix divided by
       * determinant Code modified from
       * http://www.intel.com/design/pentiumiii/sml/24504301.pdf
       *
       * @return itself
       */
      invert: function() {
        var tmp = [], src = [], dst = [], mat = this.toArray(), i2 = 0;
        for (i2 = 0; i2 < 4; i2++) {
          var i4 = i2 << 2;
          src[i2] = mat[i4];
          src[i2 + 4] = mat[i4 + 1];
          src[i2 + 8] = mat[i4 + 2];
          src[i2 + 12] = mat[i4 + 3];
        }
        tmp[0] = src[10] * src[15];
        tmp[1] = src[11] * src[14];
        tmp[2] = src[9] * src[15];
        tmp[3] = src[11] * src[13];
        tmp[4] = src[9] * src[14];
        tmp[5] = src[10] * src[13];
        tmp[6] = src[8] * src[15];
        tmp[7] = src[11] * src[12];
        tmp[8] = src[8] * src[14];
        tmp[9] = src[10] * src[12];
        tmp[10] = src[8] * src[13];
        tmp[11] = src[9] * src[12];
        var src0 = src[0], src1 = src[1], src2 = src[2], src3 = src[3], src4 = src[4], src5 = src[5], src6 = src[6], src7 = src[7];
        dst[0] = tmp[0] * src5 + tmp[3] * src6 + tmp[4] * src7;
        dst[0] -= tmp[1] * src5 + tmp[2] * src6 + tmp[5] * src7;
        dst[1] = tmp[1] * src4 + tmp[6] * src6 + tmp[9] * src7;
        dst[1] -= tmp[0] * src4 + tmp[7] * src6 + tmp[8] * src7;
        dst[2] = tmp[2] * src4 + tmp[7] * src5 + tmp[10] * src7;
        dst[2] -= tmp[3] * src4 + tmp[6] * src5 + tmp[11] * src7;
        dst[3] = tmp[5] * src4 + tmp[8] * src5 + tmp[11] * src6;
        dst[3] -= tmp[4] * src4 + tmp[9] * src5 + tmp[10] * src6;
        dst[4] = tmp[1] * src1 + tmp[2] * src2 + tmp[5] * src3;
        dst[4] -= tmp[0] * src1 + tmp[3] * src2 + tmp[4] * src3;
        dst[5] = tmp[0] * src0 + tmp[7] * src2 + tmp[8] * src3;
        dst[5] -= tmp[1] * src0 + tmp[6] * src2 + tmp[9] * src3;
        dst[6] = tmp[3] * src0 + tmp[6] * src1 + tmp[11] * src3;
        dst[6] -= tmp[2] * src0 + tmp[7] * src1 + tmp[10] * src3;
        dst[7] = tmp[4] * src0 + tmp[9] * src1 + tmp[10] * src2;
        dst[7] -= tmp[5] * src0 + tmp[8] * src1 + tmp[11] * src2;
        tmp[0] = src2 * src7;
        tmp[1] = src3 * src6;
        tmp[2] = src1 * src7;
        tmp[3] = src3 * src5;
        tmp[4] = src1 * src6;
        tmp[5] = src2 * src5;
        tmp[6] = src0 * src7;
        tmp[7] = src3 * src4;
        tmp[8] = src0 * src6;
        tmp[9] = src2 * src4;
        tmp[10] = src0 * src5;
        tmp[11] = src1 * src4;
        src0 = src[8];
        src1 = src[9];
        src2 = src[10];
        src3 = src[11];
        src4 = src[12];
        src5 = src[13];
        src6 = src[14];
        src7 = src[15];
        dst[8] = tmp[0] * src5 + tmp[3] * src6 + tmp[4] * src7;
        dst[8] -= tmp[1] * src5 + tmp[2] * src6 + tmp[5] * src7;
        dst[9] = tmp[1] * src4 + tmp[6] * src6 + tmp[9] * src7;
        dst[9] -= tmp[0] * src4 + tmp[7] * src6 + tmp[8] * src7;
        dst[10] = tmp[2] * src4 + tmp[7] * src5 + tmp[10] * src7;
        dst[10] -= tmp[3] * src4 + tmp[6] * src5 + tmp[11] * src7;
        dst[11] = tmp[5] * src4 + tmp[8] * src5 + tmp[11] * src6;
        dst[11] -= tmp[4] * src4 + tmp[9] * src5 + tmp[10] * src6;
        dst[12] = tmp[2] * src2 + tmp[5] * src3 + tmp[1] * src1;
        dst[12] -= tmp[4] * src3 + tmp[0] * src1 + tmp[3] * src2;
        dst[13] = tmp[8] * src3 + tmp[0] * src0 + tmp[7] * src2;
        dst[13] -= tmp[6] * src2 + tmp[9] * src3 + tmp[1] * src0;
        dst[14] = tmp[6] * src1 + tmp[11] * src3 + tmp[3] * src0;
        dst[14] -= tmp[10] * src3 + tmp[2] * src0 + tmp[7] * src1;
        dst[15] = tmp[10] * src2 + tmp[4] * src0 + tmp[9] * src1;
        dst[15] -= tmp[8] * src1 + tmp[11] * src2 + tmp[5] * src0;
        var det = 1 / (src[0] * dst[0] + src[1] * dst[1] + src[2] * dst[2] + src[3] * dst[3]);
        for (i2 = 0, k = 0; i2 < 4; i2++) {
          var m = this.matrix[i2];
          for (var j = 0; j < 4; j++) {
            m[j] = dst[k++] * det;
          }
        }
        return this;
      },
      multiply: function(a2) {
        if (typeof a2 == "number") {
          return new Matrix4x4(this).multiply(a2);
        }
        return new Matrix4x4(this).multiplySelf(a2);
      },
      multiplySelf: function(a2) {
        var i2 = 0, m;
        if (typeof a2 == "number") {
          for (i2 = 0; i2 < 4; i2++) {
            m = this.matrix[i2];
            m[0] *= a2;
            m[1] *= a2;
            m[2] *= a2;
            m[3] *= a2;
          }
          return this;
        }
        var mm0 = a2.matrix[0], mm1 = a2.matrix[1], mm2 = a2.matrix[2], mm3 = a2.matrix[3];
        for (i2 = 0; i2 < 4; i2++) {
          m = this.matrix[i2];
          for (var j = 0; j < 4; j++) {
            this.temp[j] = m[0] * mm0[j] + m[1] * mm1[j] + m[2] * mm2[j] + m[3] * mm3[j];
          }
          m[0] = this.temp[0];
          m[1] = this.temp[1];
          m[2] = this.temp[2];
          m[3] = this.temp[3];
        }
        return this;
      },
      /**
       * Applies rotation about arbitrary axis to matrix
       *
       * @param axis
       * @param theta
       * @return rotation applied to this matrix
       */
      rotateAroundAxis: function(axis, theta) {
        var x2, y2, z2, s, c2, t, tx, ty;
        x2 = axis.x;
        y2 = axis.y;
        z2 = axis.z;
        s = Math.sin(theta);
        c2 = Math.cos(theta);
        t = 1 - c2;
        tx = t * x2;
        ty = t * y2;
        _TEMP.set(
          tx * x2 + c2,
          tx * y2 + s * z2,
          tx * z2 - s * y2,
          0,
          tx * y2 - s * z2,
          ty * y2 + c2,
          ty * z2 + s * x2,
          0,
          tx * z2 + s * y2,
          ty * z2 - s * x2,
          t * z2 * z2 + c2,
          0,
          0,
          0,
          0,
          1
        );
        return this.multiplySelf(_TEMP);
      },
      /**
       * Applies rotation about X to this matrix.
       *
       * @param theta
       *            rotation angle in radians
       * @return itself
       */
      rotateX: function(theta) {
        _TEMP.identity();
        _TEMP.matrix[1][1] = _TEMP.matrix[2][2] = Math.cos(theta);
        _TEMP.matrix[2][1] = Math.sin(theta);
        _TEMP.matrix[1][2] = -_TEMP.matrix[2][1];
        return this.multiplySelf(_TEMP);
      },
      /**
       * Applies rotation about Y to this matrix.
       *
       * @param theta
       *            rotation angle in radians
       * @return itself
       */
      rotateY: function(theta) {
        _TEMP.identity();
        _TEMP.matrix[0][0] = _TEMP.matrix[2][2] = Math.cos(theta);
        _TEMP.matrix[0][2] = Math.sin(theta);
        _TEMP.matrix[2][0] = -_TEMP.matrix[0][2];
        return this.multiplySelf(_TEMP);
      },
      // Apply Rotation about Z to Matrix
      rotateZ: function(theta) {
        _TEMP.identity();
        _TEMP.matrix[0][0] = _TEMP.matrix[1][1] = Math.cos(theta);
        _TEMP.matrix[1][0] = Math.sin(theta);
        _TEMP.matrix[0][1] = -_TEMP.matrix[1][0];
        return this.multiplySelf(_TEMP);
      },
      scale: function(a2, b2, c2) {
        return new Matrix4x4(this).scaleSelf(a2, b2, c2);
      },
      scaleSelf: function(a2, b2, c2) {
        if (internals.has.XYZ(a2)) {
          b2 = a2.y;
          c2 = a2.z;
          a2 = a2.x;
        } else if (b2 === void 0 || c2 === void 0) {
          b2 = a2;
          c2 = a2;
        }
        _TEMP.identity();
        _TEMP.matrix[0][0] = a2;
        _TEMP.matrix[1][1] = b2;
        _TEMP.matrix[2][2] = c2;
        return this.multiplySelf(_TEMP);
      },
      set: function(a2, b2, c2, d, e, f2, g, h, i2, j, k2, l2, m, n, o, p) {
        var mat;
        if (typeof a2 == "number") {
          mat = this.matrix[0];
          mat[0] = a2;
          mat[1] = b2;
          mat[2] = c2;
          mat[3] = d;
          mat = this.matrix[1];
          mat[0] = e;
          mat[1] = f2;
          mat[2] = g;
          mat[3] = h;
          mat = this.matrix[2];
          mat[0] = i2;
          mat[1] = j;
          mat[2] = k2;
          mat[3] = l2;
          mat = this.matrix[3];
          mat[0] = m;
          mat[1] = n;
          mat[2] = o;
          mat[3] = p;
        } else {
          for (var it_n = 0; it_n < 4; it_n++) {
            mat = this.matrix[it_n];
            var mat_n = mat.matrix[it_n];
            mat[0] = mat_n[0];
            mat[1] = mat_n[1];
            mat[2] = mat_n[2];
            mat[3] = mat_n[3];
          }
        }
        return this;
      },
      setFrustrum: function(left, right, top, bottom, near, far) {
        var rl = right - left, tb = top - bottom, fn = far - near;
        return this.set(
          2 * near / rl,
          0,
          (left + right) / rl,
          0,
          0,
          2 * near / tb,
          (top + bottom) / tb,
          0,
          0,
          0,
          -(near + far) / fn,
          -2 * near * far / fn,
          0,
          0,
          -1,
          0
        );
      },
      setOrtho: function(left, right, top, bottom, near, far) {
        var mat = [
          2 / (right - left),
          0,
          0,
          (left + right) / (right - left),
          0,
          2 / (top - bottom),
          0,
          (top + bottom) / (top - bottom),
          0,
          0,
          -2 / (far - near),
          (far + near) / (far - near),
          0,
          0,
          0,
          1
        ];
        return this.set.apply(this, mat);
      },
      setPerspective: function(fov, aspect, near, far) {
        var y2 = near * Math.tan(0.5 * mathUtils.radians(fov)), x2 = aspect * y2;
        return this.setFrustrum(-x2, x2, y2, -y2, near, far);
      },
      setPosition: function(x2, y2, z2) {
        this.matrix[0][3] = x2;
        this.matrix[1][3] = y2;
        this.matrix[2][3] = z2;
        return this;
      },
      setScale: function(sX, sY, sZ) {
        this.matrix[0][0] = sX;
        this.matrix[1][1] = sY;
        this.matrix[2][2] = sZ;
        return this;
      },
      sub: function(m) {
        return new Matrix4x4(this).subSelf(m);
      },
      subSelf: function(mat) {
        for (var i2 = 0; i2 < 4; i2++) {
          var m = this.matrix[i2];
          var n = mat.matrix[i2];
          m[0] -= n[0];
          m[1] -= n[1];
          m[2] -= n[2];
          m[3] -= n[3];
        }
        return this;
      },
      /**
       * Copies all matrix elements into an linear array.
       *
       * @param result
       *            array (or null to create a new one)
       * @return matrix as 16 element array
       */
      toArray: function(result) {
        if (result === void 0) {
          result = [];
        }
        for (var i2 = 0, k2 = 0; i2 < 4; i2++) {
          var m = this.matrix[i2];
          for (var j = 0; j < 4; j++) {
            result[k2++] = m[j];
          }
        }
        return result;
      },
      toFloatArray: function(result) {
        return new Float32Array(this.toArray(result));
      },
      /*
       * (non-Javadoc)
       *
       * @see java.lang.Object#toString()
       */
      toString: function() {
        return "| " + this.matrix[0][0] + " " + this.matrix[0][1] + " " + this.matrix[0][2] + " " + this.matrix[0][3] + " |\n| " + this.matrix[1][0] + " " + this.matrix[1][1] + " " + this.matrix[1][2] + " " + this.matrix[1][3] + " |\n| " + this.matrix[2][0] + " " + this.matrix[2][1] + " " + this.matrix[2][2] + " " + this.matrix[2][3] + " |\n| " + this.matrix[3][0] + " " + this.matrix[3][1] + " " + this.matrix[3][2] + " " + this.matrix[3][3] + " |";
      },
      toTransposedFloatArray: function(result) {
        if (result === void 0) {
          result = [];
        }
        for (var i2 = 0, k2 = 0; i2 < 4; i2++) {
          for (var j = 0; j < 4; j++) {
            result[k2++] = this.matrix[j][i2];
          }
        }
        return result;
      },
      translate: function(dx, dy, dz) {
        return new Matrix4x4(this).translateSelf(dx, dy, dz);
      },
      translateSelf: function(dx, dy, dz) {
        if (internals.has.XYZ(dx)) {
          dy = dx.y;
          dz = dx.z;
          dx = dx.x;
        }
        _TEMP.identity();
        _TEMP.setPosition(dx, dy, dz);
        return this.multiplySelf(_TEMP);
      },
      /**
       * Converts the matrix (in-place) between column-major to row-major order
       * (and vice versa).
       *
       * @return itself
       */
      transpose: function() {
        return this.set(
          this.matrix[0][0],
          this.matrix[1][0],
          this.matrix[2][0],
          this.matrix[3][0],
          this.matrix[0][1],
          this.matrix[1][1],
          this.matrix[2][1],
          this.matrix[3][1],
          this.matrix[0][2],
          this.matrix[1][2],
          this.matrix[2][2],
          this.matrix[3][2],
          this.matrix[0][3],
          this.matrix[1][3],
          this.matrix[2][3],
          this.matrix[3][3]
        );
      }
    };
    var _TEMP = new Matrix4x4();
    module.exports = Matrix4x4;
  }
});

// node_modules/toxiclibsjs/geom/Line3D.js
var require_Line3D = __commonJS({
  "node_modules/toxiclibsjs/geom/Line3D.js"(exports, module) {
    init_process();
    init_buffer();
    var mathUtils = require_mathUtils();
    var Ray3D = require_Ray3D();
    var Line3D = function(vec_a, vec_b) {
      this.a = vec_a;
      this.b = vec_b;
    };
    Line3D.prototype = {
      constructor: Line3D,
      closestLineTo: function(l2) {
        var p43 = l2.a.sub(l2.b);
        if (p43.isZeroVector()) {
          return new Line3D.LineIntersection(Line3D.LineIntersection.Type.NON_INTERSECTING);
        }
        var p21 = this.b.sub(this.a);
        if (p21.isZeroVector()) {
          return new Line3D.LineIntersection(Line3D.LineIntersection.Type.NON_INTERSECTING);
        }
        var p13 = this.a.sub(l2.a);
        var d1343 = p13.x * p43.x + p13.y * p43.y + p13.z * p43.z;
        var d4321 = p43.x * p21.x + p43.y * p21.y + p43.z * p21.z;
        var d1321 = p13.x * p21.x + p13.y * p21.y + p13.z * p21.z;
        var d4343 = p43.x * p43.x + p43.y * p43.y + p43.z * p43.z;
        var d2121 = p21.x * p21.x + p21.y * p21.y + p21.z * p21.z;
        var denom = d2121 * d4343 - d4321 * d4321;
        if (Math.abs(denom) < mathUtils.EPS) {
          return new Line3D.LineIntersection(Line3D.LineIntersection.Type.NON_INTERSECTING);
        }
        var numer = d1343 * d4321 - d1321 * d4343;
        var mua = numer / denom;
        var mub = (d1343 + d4321 * mua) / d4343;
        var pa = this.a.add(p21.scaleSelf(mua));
        var pb = l2.a.add(p43.scaleSelf(mub));
        return new Line3D.LineIntersection(Line3D.LineIntersection.Type.INTERSECTING, new Line3D(pa, pb), mua, mub);
      },
      /**
      * Computes the closest point on this line to the given one.
      *
      * @param p
      *            point to check against
      * @return closest point on the line
      */
      closestPointTo: function(p) {
        var v2 = this.b.sub(this.a);
        var t = p.sub(this.a).dot(v2) / v2.magSquared();
        if (t < 0) {
          return this.a.copy();
        } else if (t > 1) {
          return this.b.copy();
        }
        return this.a.add(v2.scaleSelf(t));
      },
      copy: function() {
        return new Line3D(this.a.copy(), this.b.copy());
      },
      equals: function(obj) {
        if (this == obj) {
          return true;
        }
        if (typeof obj != Line3D) {
          return false;
        }
        return (this.a.equals(obj.a) || this.a.equals(l.b)) && (this.b.equals(l.b) || this.b.equals(l.a));
      },
      getDirection: function() {
        return this.b.sub(this.a).normalize();
      },
      getLength: function() {
        return this.a.distanceTo(this.b);
      },
      getLengthSquared: function() {
        return this.a.distanceToSquared(this.b);
      },
      getMidPoint: function() {
        return this.a.add(this.b).scaleSelf(0.5);
      },
      getNormal: function() {
        return this.b.cross(this.a);
      },
      hasEndPoint: function(p) {
        return this.a.equals(p) || this.b.equals(p);
      },
      offsetAndGrowBy: function(offset, scale, ref) {
        var m = this.getMidPoint(), d = this.getDirection(), n = this.a.cross(d).normalize();
        if (ref !== void 0 && m.sub(ref).dot(n) < 0) {
          n.invert();
        }
        n.normalizeTo(offset);
        this.a.addSelf(n);
        this.b.addSelf(n);
        d.scaleSelf(scale);
        this.a.subSelf(d);
        this.b.addSelf(d);
        return this;
      },
      set: function(vec_a, vec_b) {
        this.a = vec_a;
        this.b = vec_b;
        return this;
      },
      splitIntoSegments: function(segments, stepLength, addFirst) {
        return Line3D.splitIntoSegments(this.a, this.b, stepLength, segments, addFirst);
      },
      toRay3D: function() {
        return new Ray3D(this.a.copy(), this.getDirection());
      },
      toString: function() {
        return this.a.toString() + " -> " + this.b.toString();
      }
    };
    Line3D.splitIntoSegments = function(vec_a, vec_b, stepLength, segments, addFirst) {
      if (segments === void 0) {
        segments = [];
      }
      if (addFirst) {
        segments.push(vec_a.copy());
      }
      var dist = vec_a.distanceTo(vec_b);
      if (dist > stepLength) {
        var pos = vec_a.copy();
        var step = vec_b.sub(vec_a).limit(stepLength);
        while (dist > stepLength) {
          pos.addSelf(step);
          segments.push(pos.copy());
          dist -= stepLength;
        }
      }
      segments.push(vec_b.copy());
      return segments;
    };
    Line3D.LineIntersection = function(type, line, mua, mub) {
      this.type = type;
      if (mua === void 0) {
        mua = 0;
      }
      if (mub === void 0) {
        mub = 0;
      }
      this.line = line;
      this.coeff = [mua, mub];
    };
    Line3D.LineIntersection.prototype = {
      getCoefficient: function() {
        return this.coeff;
      },
      getLength: function() {
        if (this.line === void 0) {
          return void 0;
        }
        return this.line.getLength();
      },
      getLine: function() {
        if (this.line === void 0) {
          return void 0;
        }
        return this.line.copy();
      },
      getType: function() {
        return this.type;
      },
      isIntersectionInside: function() {
        return this.type == Line3D.LineIntersection.Type.INTERSECTING && this.coeff[0] >= 0 && this.coeff[0] <= 1 && this.coeff[1] >= 0 && this.coeff[1] <= 1;
      },
      toString: function() {
        return "type: " + this.type + " line: " + this.line;
      }
    };
    Line3D.LineIntersection.Type = {
      NON_INTERSECTING: 0,
      INTERSECTING: 1
    };
    module.exports = Line3D;
  }
});

// node_modules/toxiclibsjs/geom/Ray3D.js
var require_Ray3D = __commonJS({
  "node_modules/toxiclibsjs/geom/Ray3D.js"(exports, module) {
    init_process();
    init_buffer();
    var extend = require_internals().extend;
    var Vec3D = require_Vec3D();
    var Line3D = require_Line3D();
    var Ray3D = function(a2, b2, c2, d) {
      var o, dir;
      if (arguments.length == 4) {
        o = new Vec3D(a2, b2, c2);
        dir = d;
      } else if (arguments.length == 2) {
        o = a2;
        dir = b2;
      } else {
        o = new Vec3D();
        dir = Vec3D.Y_AXIS.copy();
      }
      Vec3D.apply(this, [o]);
      this.dir = dir;
    };
    extend(Ray3D, Vec3D);
    Ray3D.prototype.getDirection = function() {
      return this.dir.copy();
    };
    Ray3D.prototype.getDistanceToPoint = function(p) {
      var sp = p.sub(this);
      return sp.distanceTo(this.dir.scale(sp.dot(this.dir)));
    };
    Ray3D.prototype.getPointAtDistance = function(dist) {
      return this.add(this.dir.scale(dist));
    };
    Ray3D.prototype.setDirection = function(d) {
      this.dir.set(d).normalize();
      return this;
    };
    Ray3D.prototype.toLine3DWithPointAtDistance = function(dist) {
      Line3D = require_Line3D();
      return new Line3D(this, this.getPointAtDistance(dist));
    };
    Ray3D.prototype.toString = function() {
      return "origin: " + this.parent.toString.call(this) + " dir: " + this.dir;
    };
    module.exports = Ray3D;
  }
});

// node_modules/toxiclibsjs/geom/mesh/Face.js
var require_Face = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/Face.js"(exports, module) {
    init_process();
    init_buffer();
    var Face;
    var WEFace;
    (function() {
      var Triangle3D = require_Triangle3D();
      Face = function(a2, b2, c2, uvA, uvB, uvC) {
        this.a = a2;
        this.b = b2;
        this.c = c2;
        var aminusc = this.a.sub(this.c);
        var aminusb = this.a.sub(this.b);
        var cross = aminusc.crossSelf(aminusb);
        this.normal = cross.normalize();
        this.a.addFaceNormal(this.normal);
        this.b.addFaceNormal(this.normal);
        this.c.addFaceNormal(this.normal);
        if (uvA !== void 0) {
          this.uvA = uvA;
          this.uvB = uvB;
          this.uvC = uvC;
        }
      };
      Face.prototype = {
        computeNormal: function() {
          this.normal = this.a.sub(this.c).crossSelf(this.a.sub(this.b)).normalize();
        },
        flipVertexOrder: function() {
          var t = this.a;
          this.a = this.b;
          this.b = t;
          this.normal.invert();
        },
        getCentroid: function() {
          return this.a.add(this.b).addSelf(this.c).scale(1 / 3);
        },
        getClass: function() {
          return "Face";
        },
        getVertices: function(verts) {
          if (verts !== void 0) {
            verts[0] = this.a;
            verts[1] = this.b;
            verts[2] = this.c;
          } else {
            verts = [this.a, this.b, this.c];
          }
          return verts;
        },
        toString: function() {
          return this.getClass() + " " + this.a + ", " + this.b + ", " + this.c;
        },
        /**
         * Creates a generic {@link Triangle3D} instance using this face's vertices.
         * The new instance is made up of copies of the original vertices and
         * manipulating them will not impact the originals.
         *
         * @return triangle copy of this mesh face
         */
        toTriangle: function() {
          return new Triangle3D(this.a.copy(), this.b.copy(), this.c.copy());
        }
      };
    })();
    (function() {
      var internals = require_internals();
      var proto;
      WEFace = function(a2, b2, c2, uvA, uvB, uvC) {
        Face.call(this, a2, b2, c2, uvA, uvB, uvC);
        this.edges = [];
      };
      internals.extend(WEFace, Face);
      proto = WEFace.prototype;
      proto.addEdge = function(edge) {
        this.edges.push(edge);
      };
      proto.getEdges = function() {
        return this.edges;
      };
      proto.getVertices = function(verts) {
        if (verts !== void 0) {
          verts[0] = this.a;
          verts[1] = this.b;
          verts[2] = this.c;
        } else {
          verts = [this.a, this.b, this.c];
        }
        return verts;
      };
    })();
    Face.WEFace = WEFace;
    module.exports = Face;
  }
});

// node_modules/toxiclibsjs/geom/IsectData3D.js
var require_IsectData3D = __commonJS({
  "node_modules/toxiclibsjs/geom/IsectData3D.js"(exports, module) {
    init_process();
    init_buffer();
    var Vec3D = require_Vec3D();
    var IsectData3D = function(isec) {
      if (isec !== void 0) {
        this.isIntersection = isec.isIntersection;
        this.dist = isec.dist;
        this.pos = isec.pos.copy();
        this.dir = isec.dir.copy();
        this.normal = isec.normal.copy();
      } else {
        this.clear();
      }
    };
    IsectData3D.prototype = {
      clear: function() {
        this.isIntersection = false;
        this.dist = 0;
        this.pos = new Vec3D();
        this.dir = new Vec3D();
        this.normal = new Vec3D();
      },
      toString: function() {
        var s = "isec: " + this.isIntersection;
        if (this.isIntersection) {
          s += " at:" + this.pos + " dist:" + this.dist + " normal:" + this.normal;
        }
        return s;
      }
    };
    module.exports = IsectData3D;
  }
});

// node_modules/toxiclibsjs/geom/TriangleIntersector.js
var require_TriangleIntersector = __commonJS({
  "node_modules/toxiclibsjs/geom/TriangleIntersector.js"(exports, module) {
    init_process();
    init_buffer();
    var mathUtils = require_mathUtils();
    var Triangle3D = require_Triangle3D();
    var Vec3D = require_Vec3D();
    var IsectData3D = require_IsectData3D();
    var TriangleIntersector = function(t) {
      this.triangle = t || new Triangle3D();
      this.isectData = new IsectData3D();
    };
    TriangleIntersector.prototype = {
      getIntersectionData: function() {
        return this.isectData;
      },
      getTriangle: function() {
        return this.triangle;
      },
      /**
       * @param {Ray3D} ray
       * @returns {Boolean}
       */
      intersectsRay: function(ray) {
        this.isectData.isIntersection = false;
        var n = this.triangle.computeNormal(), dotprod = n.dot(ray.dir);
        if (dotprod < 0) {
          var rt = ray.sub(this.triangle.a), t = -(n.x * rt.x + n.y * rt.y + n.z * rt.z) / (n.x * ray.dir.x + n.y * ray.dir.y + n.z * ray.dir.z);
          if (t >= mathUtils.EPS) {
            var pos = ray.getPointAtDistance(t);
            if (this.triangle.containsPoint(pos)) {
              this.isectData.isIntersection = true;
              this.isectData.pos = pos;
              this.isectData.normal = n;
              this.isectData.dist = t;
              this.isectData.dir = this.isectData.pos.sub(ray).normalize();
            }
          }
        }
        return this.isectData.isIntersection;
      },
      /**
       * @param {Triangle3D} tri
       * @returns {TriangleIntersector}
       */
      setTriangle: function(tri) {
        this.triangle = tri;
        return this;
      }
    };
    module.exports = TriangleIntersector;
  }
});

// node_modules/toxiclibsjs/geom/Quaternion.js
var require_Quaternion = __commonJS({
  "node_modules/toxiclibsjs/geom/Quaternion.js"(exports, module) {
    init_process();
    init_buffer();
    var mathUtils = require_mathUtils();
    var Matrix4x4 = require_Matrix4x4();
    var Quaternion = function(qw, vx, y2, z2) {
      if (arguments.length == 4) {
        this.w = qw;
        this.x = vx;
        this.y = y2;
        this.z = z2;
      } else if (arguments.length == 2) {
        this.x = vx.x;
        this.y = vx.y;
        this.z = vx.z;
        this.w = qw;
      } else if (arguments.length == 1) {
        this.w = q.w;
        this.x = q.x;
        this.y = q.y;
        this.z = q.z;
      }
    };
    Quaternion.prototype = {
      add: function(q2) {
        return new Quaternion(this.x + q2.x, this.y + q2.y, this.z + q2.z, this.w + q2.w);
      },
      addSelf: function(q2) {
        this.x += q2.x;
        this.y += q2.y;
        this.z += q2.z;
        return this;
      },
      copy: function() {
        return new Quaternion(this.w, this.x, this.y, this.z);
      },
      dot: function(q2) {
        return this.x * q2.x + this.y * q2.y + this.z * q2.z + this.w * q2.w;
      },
      getConjugate: function() {
        var q2 = new Quaternion();
        q2.x = -this.x;
        q2.y = -this.y;
        q2.z = -this.z;
        q2.w = w;
        return q2;
      },
      identity: function() {
        this.w = 1;
        this.x = 0;
        this.y = 0;
        this.z = 0;
        return this;
      },
      interpolateTo: function(target, t, is) {
        return arguments.length == 3 ? this.copy().interpolateTo(target, is.interpolate(0, 1, t)) : this.copy().interpolateToSelf(target, t);
      },
      interpolateToSelf: function(target, t, is) {
        if (arguments.length == 3) {
          t = is.interpolate(0, 1, t);
        }
        var scale, invscale, dot = mathUtils.clip(this.dot(target), -1, 1);
        if (1 - dot >= mathUtils.EPS) {
          var theta = Math.acos(dot);
          var invsintheta = 1 / Math.sin(theta);
          scale = Math.sin(theta * (1 - t)) * invsintheta;
          invscale = Math.sin(theta * t) * invsintheta;
        } else {
          scale = 1 - t;
          invscale = t;
        }
        if (dot < 0) {
          this.w = scale * this.w - invscale * target.w;
          this.x = scale * this.x - invscale * target.x;
          this.y = scale * this.y - invscale * target.y;
          this.z = scale * this.z - invscale * target.z;
        } else {
          this.w = scale * w + invscale * target.w;
          this.x = scale * x + invscale * target.x;
          this.y = scale * y + invscale * target.y;
          this.z = scale * z + invscale * target.z;
        }
        return this;
      },
      magnitude: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      },
      multiply: function(q2) {
        var res = new Quaternion();
        res.w = this.w * q2.w - x * q2.x - y * q2.y - z * q2.z;
        res.x = this.w * q2.x + x * q2.w + y * q2.z - z * q2.y;
        res.y = this.w * q2.y + y * q2.w + z * q2.x - x * q2.z;
        res.z = this.w * q2.z + z * q2.w + x * q2.y - y * q2.x;
        return res;
      },
      normalize: function() {
        var mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        if (mag > mathUtils.EPS) {
          mag = 1 / mag;
          this.x *= mag;
          this.y *= mag;
          this.z *= mag;
          this.w *= mag;
        }
        return this;
      },
      scale: function(t) {
        return new Quaternion(this.x * t, this.y * t, this.z * t, this.w * t);
      },
      scaleSelf: function(t) {
        this.x *= t;
        this.y *= t;
        this.z *= t;
        this.w *= t;
        return this;
      },
      set: function(w2, x2, y2, z2) {
        if (arguments.length == 4) {
          this.w = w2;
          this.x = x2;
          this.y = y2;
          this.z = z2;
        } else if (arguments.length == 2) {
          this.w = w2;
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
        } else {
          this.w = q.w;
          this.x = q.x;
          this.y = q.y;
          this.z = q.z;
        }
        return this;
      },
      sub: function(q2) {
        return new Quaternion(this.x - q2.x, this.y - q2.y, this.z - q2.z, this.w - q2.w);
      },
      subSelf: function(q2) {
        this.x -= q2.x;
        this.y -= q2.y;
        this.z -= q2.z;
        this.w -= q2.w;
        return this;
      },
      toArray: function() {
        return [this.w, this.x, this.y, this.z];
      },
      toAxisAngle: function() {
        var res = [];
        var sa = Math.sqrt(1 - this.w * this.w);
        if (sa < mathUtils.EPS) {
          sa = 1;
        } else {
          sa = 1 / sa;
        }
        res[0] = Math.acos(this.w) * 2;
        res[1] = this.x * sa;
        res[2] = this.y * sa;
        res[3] = this.z * sa;
        return res;
      },
      toMatrix4x4: function(result) {
        if (result === void 0) {
          result = new Matrix4x4();
        }
        var x2 = this.x + this.x;
        var y2 = this.y + this.y;
        var z2 = this.z + this.z;
        var xx = this.x * x2;
        var xy = this.x * y2;
        var xz = this.x * z2;
        var yy = this.y * y2;
        var yz = this.y * z2;
        var zz = this.z * z2;
        var wx = this.w * x2;
        var wy = this.w * y2;
        var wz = this.w * z2;
        var st = x2 + "," + y2 + "," + z2 + "," + xx + "," + xy + "," + xz + "," + yy + "," + yz + "," + zz + "," + wx + "," + wy + "," + wz;
        return result.set(
          1 - (yy + zz),
          xy - wz,
          xz + wy,
          0,
          xy + wz,
          1 - (xx + zz),
          yz - wx,
          0,
          xz - wy,
          yz + wx,
          1 - (xx + yy),
          0,
          0,
          0,
          0,
          1
        );
      },
      toString: function() {
        return "{axis: [" + this.x + "," + this.y + "," + this.z + "], w: " + this.w + "}";
      }
    };
    Quaternion.DOT_THRESHOLD = 0.9995;
    Quaternion.createFromAxisAngle = function(axis, angle) {
      angle *= 0.5;
      var sin = mathUtils.sin(angle), cos = mathUtils.cos(angle), q2 = new Quaternion(cos, axis.getNormalizedTo(sin));
      return q2;
    };
    Quaternion.createFromEuler = function(pitch, yaw, roll) {
      pitch *= 0.5;
      yaw *= 0.5;
      roll *= 0.5;
      var sinPitch = mathUtils.sin(pitch), cosPitch = mathUtils.cos(pitch), sinYaw = mathUtils.sin(yaw), cosYaw = mathUtils.cos(yaw), sinRoll = mathUtils.sin(roll), cosRoll = mathUtils.cos(roll);
      var cosPitchCosYaw = cosPitch * cosYaw, sinPitchSinYaw = sinPitch * sinYaw;
      var q2 = new Quaternion();
      q2.x = sinRoll * cosPitchCosYaw - cosRoll * sinPitchSinYaw;
      q2.y = cosRoll * sinPitch * cosYaw + sinRoll * cosPitch * sinYaw;
      q2.z = cosRoll * cosPitch * sinYaw - sinRoll * sinPitch * cosYaw;
      q2.w = cosRoll * cosPitchCosYaw + sinRoll * sinPitchSinYaw;
      return q2;
    };
    Quaternion.createFromMatrix = function(m) {
      var s = 0;
      var q2 = [];
      var trace = m.matrix[0][0] + m.matrix[1][1] + m.matrix[2][2];
      if (trace > 0) {
        s = Math.sqrt(trace + 1);
        q2[3] = s * 0.5;
        s = 0.5 / s;
        q2[0] = m.matrix[1][2] - m.matrix[2][1] * s;
        q2[1] = m.matrix[2][0] - m.matrix[0][2] * s;
        q2[2] = m.matrix[0][1] - m.matrix[1][0] * s;
      } else {
        var nxt = [1, 2, 0];
        var i2 = 0, j = 0, k2 = 0;
        if (m.matrix[1][1] > m.matrix[0][0]) {
          i2 = 1;
        }
        if (m.matrix[2][2] > m.matrix[i2][i2]) {
          i2 = 2;
        }
        j = nxt[i2];
        k2 = nxt[j];
        s = Math.sqrt(m.matrix[i2][i2] - (m.matrix[j][j] + m.matrix[k2][k2]) + 1);
        q2[i2] = s * 0.5;
        s = 0.5 / s;
        q2[3] = (m.matrix[j][k2] - m.matrix[k2][j]) * s;
        q2[j] = (m.matrix[i2][j] + m.matrix[j][i2]) * s;
        q2[k2] = (m.matrix[i2][k2] + m.matrix[k2][i2]) * s;
      }
      return new Quaternion(q2[3], q2[0], q2[1], q2[2]);
    };
    Quaternion.getAlignmentQuat = function(dir, forward) {
      var target = dir.getNormalized(), axis = forward.cross(target), length = axis.magnitude() + 1e-4, angle = Math.atan2(length, forward.dot(target));
      return this.createFromAxisAngle(axis, angle);
    };
    module.exports = Quaternion;
  }
});

// node_modules/toxiclibsjs/geom/mesh/Vertex.js
var require_Vertex = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/Vertex.js"(exports, module) {
    init_process();
    init_buffer();
    var Vertex;
    var WEVertex;
    (function() {
      var extend = require_internals().extend, Vec3D = require_Vec3D(), proto;
      Vertex = function(v2, id) {
        Vec3D.call(this, v2);
        this.id = id;
        this.normal = new Vec3D();
      };
      extend(Vertex, Vec3D);
      proto = Vertex.prototype;
      proto.addFaceNormal = function(n) {
        this.normal.addSelf(n);
      };
      proto.clearNormal = function() {
        this.normal.clear();
      };
      proto.computeNormal = function() {
        this.normal.normalize();
      };
      proto.toString = function() {
        return this.id + ": p: " + this.parent.toString.call(this) + " n:" + this.normal.toString();
      };
    })();
    (function() {
      var extend = require_internals().extend, proto;
      WEVertex = function(vec3d, id) {
        Vertex.call(this, vec3d, id);
        this.edges = [];
      };
      extend(WEVertex, Vertex);
      proto = WEVertex.prototype;
      proto.addEdge = function(edge) {
        this.edges.push(edge);
      };
      proto.getNeighborInDirection = function(dir, tolerance) {
        var closest, delta = 1 - tolerance;
        var neighbors = this.getNeighbors();
        var d;
        for (var i2 = 0, l2 = neighbors.length; i2 < l2; i2++) {
          d = neighbors[i2].sub(this).normalize().dot(dir);
          if (d > delta) {
            closest = neighbors[i2];
            delta = d;
          }
        }
        return closest;
      };
      proto.getNeighbors = function() {
        var neighbors = [];
        for (var i2 = 0, l2 = this.edges.length; i2 < l2; i2++) {
          neighbors.push(this.edges[i2].getOtherEndFor(this));
        }
        return neighbors;
      };
      proto.removeEdge = function(e) {
        this.edges.splice(this.edges.indexOf(e), 1);
      };
      proto.toString = function() {
        return this.id + " {" + this.x + "," + this.y + "," + this.z + "}";
      };
      return WEVertex;
    })();
    Vertex.WEVertex = WEVertex;
    module.exports = Vertex;
  }
});

// node_modules/toxiclibsjs/geom/Sphere.js
var require_Sphere = __commonJS({
  "node_modules/toxiclibsjs/geom/Sphere.js"(exports, module) {
    init_process();
    init_buffer();
    var Sphere;
    var SphereFunction;
    (function() {
      var internals = require_internals();
      var meshCommon = require_meshCommon();
      var Vec3D = require_Vec3D();
      Sphere = function(a2, b2) {
        if (a2 === void 0) {
          Vec3D.apply(this, [new Vec3D()]);
          this.radius = 1;
        } else if (internals.has.XYZ(a2)) {
          Vec3D.apply(this, [a2]);
          if (internals.is.Sphere(a2)) {
            this.radius = a2.radius;
          } else {
            this.radius = b2;
          }
        } else {
          Vec3D.apply(this, [new Vec3D()]);
          this.radius = a2;
        }
      };
      internals.extend(Sphere, Vec3D);
      Sphere.prototype.containsPoint = function(p) {
        var d = this.sub(p).magSquared();
        return d <= this.radius * this.radius;
      };
      Sphere.prototype.intersectRay = function(ray) {
        var result, a2, b2, t, q2 = ray.sub(this), distSquared = q2.magSquared(), v2 = -q2.dot(ray.getDirection()), d = this.radius * this.radius - (distSquared - v2 * v2);
        if (d >= 0) {
          d = Math.sqrt(d);
          a2 = v2 + d;
          b2 = v2 - d;
          if (!(a2 < 0 && b2 < 0)) {
            if (a2 > 0 && b2 > 0) {
              if (a2 > b2) {
                t = a2;
                a2 = b2;
                b2 = t;
              }
            } else {
              if (b2 > 0) {
                t = a2;
                a2 = b2;
                b2 = t;
              }
            }
          }
          result = [a2, b2];
        }
        return result;
      };
      Sphere.prototype.intersectSphereTriangle = function(t, result) {
        result.set(t.closestPointOnSurface(this));
        var v2 = result.sub(this);
        return v2.magSquared() <= this.radius * this.radius;
      };
      Sphere.prototype.tangentPlaneNormalAt = function(q2) {
        return this.sub(q2).normalize();
      };
      Sphere.prototype.toMesh = function() {
        var opts = {
          mesh: void 0,
          resolution: 0
        };
        if (arguments.length === 1) {
          if (typeof arguments[0] == "object") {
            opts.mesh = arguments[0].mesh;
            opts.resolution = arguments[0].res || arguments[0].resolution;
          } else {
            opts.resolution = arguments[0];
          }
        } else {
          opts.mesh = arguments[0];
          opts.resolution = arguments[1];
        }
        var builder = new meshCommon.SurfaceMeshBuilder(new SphereFunction(this));
        return builder.createMesh(opts.mesh, opts.resolution, 1);
      };
    })();
    (function(Sphere2) {
      var mathUtils = require_mathUtils(), Vec3D = require_Vec3D(), internals = require_internals();
      SphereFunction = function(sphere_or_radius) {
        if (sphere_or_radius === void 0) {
          this.sphere = new Sphere2(new Vec3D(), 1);
        }
        if (internals.is.Sphere(sphere_or_radius)) {
          this.sphere = sphere_or_radius;
        } else {
          this.sphere = new Sphere2(new Vec3D(), sphere_or_radius);
        }
        this.phiRange = mathUtils.PI;
        this.thetaRange = mathUtils.TWO_PI;
      };
      SphereFunction.prototype = {
        computeVertexFor: function(p, phi, theta) {
          phi -= mathUtils.HALF_PI;
          var cosPhi = mathUtils.cos(phi);
          var cosTheta = mathUtils.cos(theta);
          var sinPhi = mathUtils.sin(phi);
          var sinTheta = mathUtils.sin(theta);
          var t = mathUtils.sign(cosPhi) * mathUtils.abs(cosPhi);
          p.x = t * mathUtils.sign(cosTheta) * mathUtils.abs(cosTheta);
          p.y = mathUtils.sign(sinPhi) * mathUtils.abs(sinPhi);
          p.z = t * mathUtils.sign(sinTheta) * mathUtils.abs(sinTheta);
          return p.scaleSelf(this.sphere.radius).addSelf(this.sphere);
        },
        getPhiRange: function() {
          return this.phiRange;
        },
        getPhiResolutionLimit: function(res) {
          return res;
        },
        getThetaRange: function() {
          return this.thetaRange;
        },
        getThetaResolutionLimit: function(res) {
          return res;
        },
        setMaxPhi: function(max) {
          this.phiRange = mathUtils.min(max / 2, mathUtils.PI);
        },
        setMaxTheta: function(max) {
          this.thetaRange = mathUtils.min(max, mathUtils.TWO_PI);
        }
      };
    })(Sphere);
    Sphere.SphereFunction = SphereFunction;
    module.exports = Sphere;
  }
});

// node_modules/toxiclibsjs/geom/mesh/WingedEdge.js
var require_WingedEdge = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/WingedEdge.js"(exports, module) {
    init_process();
    init_buffer();
    var internals = require_internals();
    var Line3D = require_Line3D();
    var WingedEdge;
    var proto;
    WingedEdge = function(va, vb, face, id) {
      Line3D.call(this, va, vb);
      this.id = id;
      this.faces = [];
      this.addFace(face);
    };
    internals.extend(WingedEdge, Line3D);
    proto = WingedEdge.prototype;
    proto.addFace = function(face) {
      this.faces.push(face);
      return this;
    };
    proto.getFaces = function() {
      return this.faces;
    };
    proto.getOtherEndFor = function(wevert) {
      if (this.a === wevert) {
        return this.b;
      }
      if (this.b === wevert) {
        return this.a;
      }
    };
    proto.remove = function() {
      var self = this;
      var rm = function(edges) {
        edges.splice(edges.indexOf(self), 1);
      };
      for (var i2 = 0, l2 = this.faces.length; i2 < l2; i2++) {
        rm(this.faces[i2].edges);
      }
      rm(this.a.edges);
      rm(this.b.edges);
    };
    proto.toString = function() {
      return "id: " + this.id + " " + Line3D.prototype.toString.call(this) + " f: " + this.faces.length;
    };
    module.exports = WingedEdge;
  }
});

// node_modules/toxiclibsjs/geom/mesh/subdiv/EdgeLengthComparator.js
var require_EdgeLengthComparator = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/subdiv/EdgeLengthComparator.js"(exports, module) {
    init_process();
    init_buffer();
    var EdgeLengthComparator = function() {
    };
    EdgeLengthComparator.prototype.compare = function(edge1, edge2) {
      return -parseInt(edge1.getLengthSquared() - edge2.getLengthSquared(), 10);
    };
    module.exports = EdgeLengthComparator;
  }
});

// node_modules/toxiclibsjs/geom/mesh/subdiv/SubdivisionStrategy.js
var require_SubdivisionStrategy = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/subdiv/SubdivisionStrategy.js"(exports, module) {
    init_process();
    init_buffer();
    var EdgeLengthComparator = require_EdgeLengthComparator();
    var SubdivisionStrategy;
    var proto;
    SubdivisionStrategy = function() {
      this._order = SubdivisionStrategy.DEFAULT_ORDERING;
    };
    SubdivisionStrategy.DEFAULT_ORDERING = new EdgeLengthComparator();
    proto = SubdivisionStrategy.prototype;
    proto.getEdgeOrdering = function() {
      return this._order.compare;
    };
    proto.setEdgeOrdering = function(order) {
      this._order = order;
    };
    module.exports = SubdivisionStrategy;
  }
});

// node_modules/toxiclibsjs/geom/mesh/subdiv/MidpointSubdivision.js
var require_MidpointSubdivision = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/subdiv/MidpointSubdivision.js"(exports, module) {
    init_process();
    init_buffer();
    var internals = require_internals();
    var SubdivisionStrategy = require_SubdivisionStrategy();
    var MidpointSubdivison = function() {
      SubdivisionStrategy.call(this);
    };
    internals.extend(MidpointSubdivison, SubdivisionStrategy);
    MidpointSubdivison.prototype.computeSplitPoints = function(edge) {
      var mid = [];
      mid.push(edge.getMidPoint());
      return mid;
    };
    module.exports = MidpointSubdivison;
  }
});

// node_modules/toxiclibsjs/math/Interpolation2D.js
var require_Interpolation2D = __commonJS({
  "node_modules/toxiclibsjs/math/Interpolation2D.js"(exports, module) {
    init_process();
    init_buffer();
    var internals = require_internals();
    var Interpolation2D = {};
    Interpolation2D.bilinear = function(_x, _y, _x1, _y1, _x2, _y2, _tl, _tr, _bl, _br) {
      var x2, y2, x1, y1, x22, y22, tl, tr, bl, br;
      if (internals.has.XY(_x)) {
        x2 = _x.x;
        y2 = _x.y;
        x1 = _y.x;
        y1 = _y.y;
        x22 = _x1.x;
        y22 = _x1.y;
        tl = _y1;
        tr = _x2;
        bl = _y2;
        br = _tl;
      } else {
        x2 = _x;
        y2 = _y;
        x1 = _x1;
        y1 = _y1;
        x22 = _x2;
        y22 = _y2;
        tl = _tl;
        tr = _tr;
        bl = _bl;
        br = _br;
      }
      var denom = 1 / ((x22 - x1) * (y22 - y1));
      var dx1 = (x2 - x1) * denom;
      var dx2 = (x22 - x2) * denom;
      var dy1 = y2 - y1;
      var dy2 = y22 - y2;
      return tl * dx2 * dy2 + tr * dx1 * dy2 + bl * dx2 * dy1 + br * dx1 * dy1;
    };
    module.exports = Interpolation2D;
  }
});

// node_modules/toxiclibsjs/geom/mesh/meshCommon.js
var require_meshCommon = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/meshCommon.js"(exports) {
    init_process();
    init_buffer();
    var TriangleMesh;
    var WETriangleMesh;
    var Terrain;
    var SurfaceMeshBuilder;
    var precision = 1e6;
    var format = function(n) {
      return Math.floor(n * precision) / precision;
    };
    function vertexKeyGenerator(v2) {
      return "[ x: " + format(v2.x) + ", y: " + format(v2.y) + ", z: " + format(v2.z) + "]";
    }
    function edgeKeyGenerator(edge) {
      return edge.a.id + "->" + edge.b.id;
    }
    (function() {
      var internals = require_internals(), mathUtils = require_mathUtils(), Matrix4x4 = require_Matrix4x4(), Face = require_Face(), Vec3D = require_Vec3D(), Triangle3D = require_Triangle3D(), TriangleIntersector = require_TriangleIntersector(), Quaternion = require_Quaternion(), Vertex = require_Vertex();
      TriangleMesh = function(name) {
        if (name === void 0) name = "untitled";
        this.init(name);
        return this;
      };
      TriangleMesh.__vertexKeyGenerator = vertexKeyGenerator;
      TriangleMesh.DEFAULT_NUM_VERTICES = 1e3;
      TriangleMesh.DEFAULT_NUM_FACES = 3e3;
      TriangleMesh.DEFAULT_STRIDE = 4;
      TriangleMesh.prototype = {
        /**
         * add a Face to the mesh
         * @param {Vec3D} a
         * @param {Vec3D} b
         * @param {Vec3D} c
         * @param {Vec3D} [n] the normal
         * @param {Vec2D} [uvA]
         * @param {Vec2D} [uvB]
         * @param {Vec2D} [uvC]
         * @returns itself
         */
        addFace: function(a2, b2, c2, n, uvA, uvB, uvC) {
          if (arguments.length == 6) {
            uvC = uvB;
            uvB = uvA;
            uvA = n;
            n = void 0;
          }
          var va = this.__checkVertex(a2);
          var vb = this.__checkVertex(b2);
          var vc = this.__checkVertex(c2);
          if (va.id === vb.id || va.id === vc.id || vb.id === vc.id) {
          } else {
            if (n != null) {
              var nc = va.sub(vc).crossSelf(va.sub(vb));
              if (n.dot(nc) < 0) {
                var t = va;
                va = vb;
                vb = t;
              }
            }
            var f2 = new Face(va, vb, vc, uvA, uvB, uvC);
            this.faces.push(f2);
          }
          return this;
        },
        /**
         * add the contents of a TriangleMesh to this TriangleMesh
         * @param {TriangleMesh} m
         * @returns itself
         */
        addMesh: function(m) {
          var l2 = m.getFaces().length;
          for (var i2 = 0; i2 < l2; i2++) {
            var f2 = m.getFaces()[i2];
            this.addFace(f2.a, f2.b, f2.c);
          }
          return this;
        },
        center: function(origin) {
          this.computeCentroid();
          var delta = origin != null ? origin.sub(this.centroid) : this.centroid.getInverted();
          var l2 = this.vertices.length;
          for (var i2 = 0; i2 < l2; i2++) {
            var v2 = this.vertices[i2];
            v2.addSelf(delta);
          }
          return this.getBoundingBox();
        },
        __checkVertex: function(v2) {
          var vertex = this.vertexMap.get(v2);
          if (!vertex) {
            vertex = this._createVertex(v2, this.uniqueVertexID++);
            this.vertexMap.put(vertex, vertex);
          }
          return vertex;
        },
        clear: function() {
          this.vertexMap = new internals.LinkedMap(vertexKeyGenerator);
          this.vertices = this.vertexMap.getArray();
          this.faces = [];
          this.bounds = void 0;
          return this;
        },
        computeCentroid: function() {
          this.centroid.clear();
          var l2 = this.vertices.length;
          for (var i2 = 0; i2 < l2; i2++) {
            this.centroid.addSelf(this.vertices[i2]);
          }
          return this.centroid.scaleSelf(1 / this.vertexMap.size()).copy();
        },
        computeFaceNormals: function() {
          var l2 = this.faces.length;
          for (var i2 = 0; i2 < l2; i2++) {
            this.faces[i2].computeNormal();
          }
        },
        computeVertexNormals: function() {
          var l2 = this.vertices.length, i2 = 0;
          for (i2 = 0; i2 < l2; i2++) {
            this.vertices[i2].clearNormal();
          }
          l2 = this.faces.length;
          for (i2 = 0; i2 < l2; i2++) {
            var f2 = this.faces[i2];
            f2.a.addFaceNormal(f2.normal);
            f2.b.addFaceNormal(f2.normal);
            f2.c.addFaceNormal(f2.normal);
          }
          l2 = this.vertices.length;
          for (i2 = 0; i2 < l2; i2++) {
            this.vertices[i2].computeNormal();
          }
          return this;
        },
        copy: function() {
          var m = new TriangleMesh(this.name + "-copy", this.vertexMap.size(), this.faces.length);
          var l2 = this.faces.length;
          for (var i2 = 0; i2 < l2; i2++) {
            var f2 = this.faces[i2];
            m.addFace(f2.a, f2.b, f2.c, f2.normal, f2.uvA, f2.uvB, f2.uvC);
          }
          return m;
        },
        _createVertex: function(vec3D, id) {
          var vertex = new Vertex(vec3D, id);
          return vertex;
        },
        faceOutwards: function() {
          this.computeCentroid();
          var l2 = this.faces.length;
          for (var i2 = 0; i2 < l2; i2++) {
            var f2 = this.faces[i2];
            var n = f2.getCentroid().sub(this.centroid);
            var dot = n.dot(f2.normal);
            if (dot < 0) {
              f2.flipVertexOrder();
            }
          }
          return this;
        },
        flipVertexOrder: function() {
          var l2 = this.faces.length, tuv;
          for (var i2 = 0; i2 < l2; i2++) {
            var f2 = this.faces[i2];
            var t = f2.a;
            f2.a = f2.b;
            f2.b = t;
            if (f2.uvA) {
              tuv = f2.uvA;
              f2.uvA = f2.uvB;
              f2.uvB = tuv;
            }
            f2.normal.invert();
          }
          return this;
        },
        flipYAxis: function() {
          this.transform(new Matrix4x4().scaleSelf(1, -1, 1));
          this.flipVertexOrder();
          return this;
        },
        getBoundingBox: function() {
          var AABB = require_AABB();
          var self = this;
          var minBounds = Vec3D.MAX_VALUE.copy();
          var maxBounds = Vec3D.MIN_VALUE.copy();
          var l2 = self.vertices.length;
          for (var i2 = 0; i2 < l2; i2++) {
            var v2 = self.vertices[i2];
            minBounds.minSelf(v2);
            maxBounds.maxSelf(v2);
          }
          self.bounds = AABB.fromMinMax(minBounds, maxBounds);
          return self.bounds;
        },
        getBoundingSphere: function() {
          var Sphere = require_Sphere();
          var radius = 0;
          this.computeCentroid();
          var l2 = this.vertices.length;
          for (var i2 = 0; i2 < l2; i2++) {
            var v2 = this.vertices[i2];
            radius = mathUtils.max(radius, v2.distanceToSquared(this.centroid));
          }
          var sph = new Sphere(this.centroid, Math.sqrt(radius));
          return sph;
        },
        getClosestVertexToPoint: function(p) {
          var closest, minDist = Number.MAX_VALUE, l2 = this.vertices.length;
          for (var i2 = 0; i2 < l2; i2++) {
            var v2 = this.vertices[i2];
            var d = v2.distanceToSquared(p);
            if (d < minDist) {
              closest = v2;
              minDist = d;
            }
          }
          return closest;
        },
        /**
         * Creates an array of unravelled normal coordinates. For each vertex the
         * normal vector of its parent face is used. This method can be used to
         * translate the internal mesh data structure into a format suitable for
         * OpenGL Vertex Buffer Objects (by choosing stride=4). For more detail,
         * please see {@link #getMeshAsVertexArray(float[], int, int)}
         *
         * @see #getMeshAsVertexArray(float[], int, int)
         *
         * @param normals existing float array or null to automatically create one
         * @param offset start index in array to place normals
         * @param stride stride/alignment setting for individual coordinates (min value = 3)
         * @return array of xyz normal coords
         */
        getFaceNormalsAsArray: function(normals, offset, stride) {
          if (arguments.length === 0) {
            normals = void 0;
            offset = 0;
            stride = TriangleMesh.DEFAULT_STRIDE;
          } else if (arguments.length == 1 && typeof arguments[0] == "object") {
            var opts = arguments[0];
            normals = opts.normals;
            offset = opts.offset;
            stride = opts.stride;
          }
          stride = mathUtils.max(stride, 3);
          if (normals === void 0) {
            normals = [];
          }
          var i2 = offset;
          var l2 = this.faces.length;
          for (var j = 0; j < l2; j++) {
            var f2 = this.faces[j];
            normals[i2] = f2.normal.x;
            normals[i2 + 1] = f2.normal.y;
            normals[i2 + 2] = f2.normal.z;
            i2 += stride;
            normals[i2] = f2.normal.x;
            normals[i2 + 1] = f2.normal.y;
            normals[i2 + 2] = f2.normal.z;
            i2 += stride;
            normals[i2] = f2.normal.x;
            normals[i2 + 1] = f2.normal.y;
            normals[i2 + 2] = f2.normal.z;
            i2 += stride;
          }
          return normals;
        },
        getFaces: function() {
          return this.faces;
        },
        /**
         * Builds an array of vertex indices of all faces. Each vertex ID
         * corresponds to its position in the vertices Array. The
         * resulting array will be 3 times the face count.
         * please see {@link #getUniqueVerticesAsArray([array])}
                  * and {@link #getUniqueVertexNormalsAsArray([array])}
         *
         * @see #getUniqueVerticesAsArray([array])
                  * @see #getUniqueVertexNormalsAsArray([array])
         *
                  * @param {Array|Unit16Array} [faceList] optionally provide an array or typed-array
         * @return array of vertex indices
         */
        getFacesAsArray: function(faceList) {
          faceList = faceList || [];
          var i2 = 0;
          var l2 = this.faces.length;
          for (var j = 0; j < l2; j++) {
            var f2 = this.faces[j];
            faceList[i2++] = f2.a.id;
            faceList[i2++] = f2.b.id;
            faceList[i2++] = f2.c.id;
          }
          return faceList;
        },
        getIntersectionData: function() {
          return this.intersector.getIntersectionData();
        },
        /**
         * Creates an array of unravelled vertex coordinates for all faces. This
         * method can be used to translate the internal mesh data structure into a
         * format suitable for OpenGL Vertex Buffer Objects (by choosing stride=4).
         * The order of the array will be as follows:
         *
         * <ul>
         * <li>Face 1:
         * <ul>
         * <li>Vertex #1
         * <ul>
         * <li>x</li>
         * <li>y</li>
         * <li>z</li>
         * <li>[optional empty indices to match stride setting]</li>
         * </ul>
         * </li>
         * <li>Vertex #2
         * <ul>
         * <li>x</li>
         * <li>y</li>
         * <li>z</li>
         * <li>[optional empty indices to match stride setting]</li>
         * </ul>
         * </li>
         * <li>Vertex #3
         * <ul>
         * <li>x</li>
         * <li>y</li>
         * <li>z</li>
         * <li>[optional empty indices to match stride setting]</li>
         * </ul>
         * </li>
         * </ul>
         * <li>Face 2:
         * <ul>
         * <li>Vertex #1</li>
         * <li>...etc.</li>
         * </ul>
         * </ul>
         *
         * @param verts  an existing target array or null to automatically create one
         * @param offset start index in arrtay to place vertices
         * @param stride stride/alignment setting for individual coordinates
         * @return array of xyz vertex coords
         */
        getMeshAsVertexArray: function(verts, offset, stride) {
          if (verts === void 0) {
            verts = void 0;
          }
          if (offset === void 0) {
            offset = 0;
          }
          if (stride === void 0) {
            stride = TriangleMesh.DEFAULT_STRIDE;
          }
          stride = mathUtils.max(stride, 3);
          if (verts === void 0) {
            verts = [];
          }
          var i2 = 0, l2 = this.faces.length;
          for (var j = 0; j < l2; ++j) {
            var f2 = this.faces[j];
            verts[i2] = f2.a.x;
            verts[i2 + 1] = f2.a.y;
            verts[i2 + 2] = f2.a.z;
            i2 += stride;
            verts[i2] = f2.b.x;
            verts[i2 + 1] = f2.b.y;
            verts[i2 + 2] = f2.b.z;
            i2 += stride;
            verts[i2] = f2.c.x;
            verts[i2 + 1] = f2.c.y;
            verts[i2 + 2] = f2.c.z;
            i2 += stride;
          }
          return verts;
        },
        getNumFaces: function() {
          return this.faces.length;
        },
        getNumVertices: function() {
          return this.vertexMap.size();
        },
        getRotatedAroundAxis: function(axis, theta) {
          return this.copy().rotateAroundAxis(axis, theta);
        },
        getRotatedX: function(theta) {
          return this.copy().rotateX(theta);
        },
        getRotatedY: function(theta) {
          return this.copy().rotateY(theta);
        },
        getRotatedZ: function(theta) {
          return this.copy().rotateZ(theta);
        },
        getScaled: function(scale) {
          return this.copy().scale(scale);
        },
        getTranslated: function(trans) {
          return this.copy().translate(trans);
        },
        /**
         * flatten each vertex once into an array, useful for OpenGL attributes
         * @param {Array|Float32Array} [array] optionally pass in an array or typed-array to reuse
         * @return {Array|Float32Array}
         */
        getUniqueVerticesAsArray: function(array) {
          array = array || [];
          var i2 = 0;
          var l2 = this.vertices.length;
          for (var j = 0; j < l2; j++) {
            var v2 = this.vertices[j];
            array[i2++] = v2.x;
            array[i2++] = v2.y;
            array[i2++] = v2.z;
          }
          return array;
        },
        /**
         * flatten each vertex normal once into an array, useful for OpenGL attributes
         * @param {Array|Float32Array} [array] optionally pass in an array or typed-array to reuse
         * @return {Array|Float32Array}
         */
        getUniqueVertexNormalsAsArray: function(array) {
          array = array || [];
          var n = 0;
          for (i = 0; i < this.vertices.length; i++) {
            var v2 = this.vertices[i];
            array[n++] = v2.normal.x;
            array[n++] = v2.normal.y;
            array[n++] = v2.normal.z;
          }
          return array;
        },
        /**
         * get the UVs of all faces in flattened array that is, usefl for OpenGL attributes
         * any missing UV coordinates are returned as 0
         * @param {Array|Float32Array} [array] optionally pass in an array or typed-array to reuse
         * @return {Array|Float32Array}
         */
        getUVsAsArray: function(array) {
          array = array || [];
          var i2 = 0;
          for (f = 0; f < this.faces.length; f++) {
            var face = this.faces[f];
            array[i2++] = face.uvA ? face.uvA.x : 0;
            array[i2++] = face.uvA ? face.uvA.y : 0;
            array[i2++] = face.uvB ? face.uvB.x : 0;
            array[i2++] = face.uvB ? face.uvB.y : 0;
            array[i2++] = face.uvC ? face.uvC.x : 0;
            array[i2++] = face.uvC ? face.uvC.y : 0;
          }
          return array;
        },
        getVertexAtPoint: function(v2) {
          var index;
          for (var i2 = 0; i2 < this.vertices.length; i2++) {
            if (this.vertices[i2].equals(v2)) {
              index = i2;
            }
          }
          return this.vertices[index];
        },
        //my own method to help
        getVertexIndex: function(vec) {
          var matchedVertex = -1;
          var l2 = this.vertices.length;
          for (var i2 = 0; i2 < l2; i2++) {
            var vert = this.vertices[i2];
            if (vert.equals(vec)) {
              matchedVertex = i2;
            }
          }
          return matchedVertex;
        },
        getVertexForID: function(id) {
          var vertex, l2 = this.vertices.length;
          for (var i2 = 0; i2 < l2; i2++) {
            var v2 = this.vertices[i2];
            if (v2.id == id) {
              vertex = v2;
              break;
            }
          }
          return vertex;
        },
        /**
         * Creates an array of unravelled vertex normal coordinates for all faces.
         * This method can be used to translate the internal mesh data structure
         * into a format suitable for OpenGL Vertex Buffer Objects (by choosing
         * stride=4). For more detail, please see
         * {@link #getMeshAsVertexArray(float[], int, int)}
         *
         * @see #getMeshAsVertexArray(float[], int, int)
         *
         * @param normals existing float array or null to automatically create one
         * @param offset start index in array to place normals
         * @param stride stride/alignment setting for individual coordinates (min value
         *            = 3)
         * @return array of xyz normal coords
         */
        getVertexNormalsAsArray: function(normals, offset, stride) {
          if (offset === void 0) offset = 0;
          if (stride === void 0) stride = TriangleMesh.DEFAULT_STRIDE;
          stride = mathUtils.max(stride, 3);
          if (normals === void 0) {
            normals = [];
          }
          var i2 = offset;
          var l2 = this.faces.length;
          for (var j = 0; j < l2; j++) {
            var f2 = this.faces[j];
            normals[i2] = f2.a.normal.x;
            normals[i2 + 1] = f2.a.normal.y;
            normals[i2 + 2] = f2.a.normal.z;
            i2 += stride;
            normals[i2] = f2.b.normal.x;
            normals[i2 + 1] = f2.b.normal.y;
            normals[i2 + 2] = f2.b.normal.z;
            i2 += stride;
            normals[i2] = f2.c.normal.x;
            normals[i2 + 1] = f2.c.normal.y;
            normals[i2 + 2] = f2.c.normal.z;
            i2 += stride;
          }
          return normals;
        },
        getVertices: function() {
          return this.vertices;
        },
        handleSaveAsSTL: function(stl, useFlippedY) {
          throw new Error("TriangleMesh.handleSaveAsSTL() currently not implemented");
        },
        init: function(name) {
          this.setName(name);
          this.matrix = new Matrix4x4();
          this.centroid = new Vec3D();
          this.vertexMap = new internals.LinkedMap(vertexKeyGenerator);
          this.vertices = this.vertexMap.getArray();
          this.faces = [];
          this.uniqueVertexID = 0;
          this.intersector = new TriangleIntersector();
        },
        intersectsRay: function(ray) {
          var tri = this.intersector.getTriangle();
          var l2 = this.faces.length;
          var f2;
          for (var i2 = 0; i2 < l2; i2++) {
            f2 = this.faces[i2];
            tri.a = f2.a;
            tri.b = f2.b;
            tri.c = f2.c;
            if (this.intersector.intersectsRay(ray)) {
              return true;
            }
          }
          return false;
        },
        perforateFace: function(f2, size) {
          var centroid = f2.getCentroid();
          var d = 1 - size;
          var a2 = f2.a.interpolateTo(centroid, d);
          var b2 = f2.b.interpolateTo(centroid, d);
          var c2 = f2.c.interpolateTo(centroid, d);
          this.removeFace(f2);
          this.addFace(f2.a, b2, a2);
          this.addFace(f2.a, f2.b, b2);
          this.addFace(f2.b, c2, b2);
          this.addFace(f2.b, f2.c, c2);
          this.addFace(f2.c, a2, c2);
          this.addFace(f2.c, f2.a, a2);
          return new Triangle3D(a2, b2, c2);
        },
        /**
         * Rotates the mesh in such a way so that its "forward" axis is aligned with
         * the given direction. This version uses the positive Z-axis as default
         * forward direction.
         *
         * @param dir, new target direction to point in
         * @param [forward], optional vector, defaults to Vec3D.Z_AXIS
         * @return itself
         */
        pointTowards: function(dir, forward) {
          forward = forward || Vec3D.Z_AXIS;
          return this.transform(Quaternion.getAlignmentQuat(dir, forward).toMatrix4x4(this.matrix), true);
        },
        removeFace: function(f2) {
          var index = -1;
          var l2 = this.faces.length;
          for (var i2 = 0; i2 < l2; i2++) {
            if (this.faces[i2] == f2) {
              index = i2;
              break;
            }
          }
          if (index > -1) {
            this.faces.splice(index, 1);
          }
        },
        rotateAroundAxis: function(axis, theta) {
          return this.transform(this.matrix.identity().rotateAroundAxis(axis, theta));
        },
        rotateX: function(theta) {
          return this.transform(this.matrix.identity().rotateX(theta));
        },
        rotateY: function(theta) {
          return this.transform(this.matrix.identity().rotateY(theta));
        },
        rotateZ: function(theta) {
          return this.transform(this.matrix.identity().rotateZ(theta));
        },
        saveAsOBJ: function(obj, saveNormals) {
          if (saveNormals === void 0) {
            saveNormals = true;
          }
          var vOffset = obj.getCurrVertexOffset() + 1, nOffset = obj.getCurrNormalOffset() + 1;
          obj.newObject(this.name);
          var v2 = 0, f2 = 0, vlen = this.vertices.length, flen = this.faces.length, face;
          for (v2 = 0; v2 < vlen; v2++) {
            obj.vertex(this.vertices[v2]);
          }
          if (saveNormals) {
            for (v2 = 0; v2 < vlen; v2++) {
              obj.normal(this.vertices[v2].normal);
            }
            for (f2 = 0; f2 < flen; f2++) {
              face = this.faces[f2];
              obj.faceWithNormals(face.b.id + vOffset, face.a.id + vOffset, face.c.id + vOffset, face.b.id + nOffset, face.a.id + nOffset, face.c.id + nOffset);
            }
          } else {
            for (f2 = 0; f2 < flen; f2++) {
              face = this.faces[f2];
              obj.face(face.b.id + vOffset, face.a.id + vOffset, face.c.id + vOffset);
            }
          }
        },
        saveAsSTL: function(a2, b2, c2) {
          throw new Error("TriangleMesh.saveAsSTL() currently not implemented");
        },
        scale: function(scale) {
          return this.transform(this.matrix.identity().scaleSelf(scale));
        },
        setName: function(name) {
          this.name = name;
          return this;
        },
        toString: function() {
          return "TriangleMesh: " + this.name + " vertices: " + this.getNumVertices() + " faces: " + this.getNumFaces();
        },
        toWEMesh: function() {
          return new WETriangleMesh(this.name).addMesh(this);
        },
        /**
        * Applies the given matrix transform to all mesh vertices. If the
        * updateNormals flag is true, all face normals are updated automatically,
        * however vertex normals need a manual update.
        * @param mat
        * @param updateNormals
        * @return itself
        */
        transform: function(mat, updateNormals) {
          if (updateNormals === void 0) {
            updateNormals = true;
          }
          var l2 = this.vertices.length;
          for (var i2 = 0; i2 < l2; i2++) {
            var v2 = this.vertices[i2];
            v2.set(mat.applyTo(v2));
          }
          if (updateNormals) {
            this.computeFaceNormals();
          }
          return this;
        },
        translate: function(x2, y2, z2) {
          if (arguments.length == 1) {
            y2 = x2.y;
            z2 = x2.z;
            x2 = x2.x;
          }
          return this.transform(this.matrix.identity().translateSelf(x2, y2, z2));
        },
        updateVertex: function(origVec3D, newPos) {
          var vertex = this.vertexMap.get(origVec3D);
          if (vertex !== void 0) {
            this.vertexMap.remove(vertex);
            vertex.set(newPos);
            this.vertexMap.put(newPos, vertex);
          }
          return this;
        }
      };
    })();
    (function(TriangleMesh2) {
      var internals = require_internals();
      var Line3D = require_Line3D();
      var Vec3D = require_Vec3D();
      var WEVertex = require_Vertex().WEVertex;
      var WEFace = require_Face().WEFace;
      var WingedEdge = require_WingedEdge();
      var MidpointSubdivision = require_MidpointSubdivision();
      var proto;
      WETriangleMesh = function(name) {
        name = name || "untitled";
        TriangleMesh2.call(this, name);
      };
      WETriangleMesh.DEFAULT_NUM_FACES = TriangleMesh2.DEFAULT_NUM_FACES;
      WETriangleMesh.DEFAULT_NUM_VERTICES = TriangleMesh2.DEFAULT_NUM_VERTICES;
      internals.extend(WETriangleMesh, TriangleMesh2);
      proto = WETriangleMesh.prototype;
      proto.addFace = function(a2, b2, c2, norm, uvA, uvB, uvC) {
        if (arguments.length === 6) {
          uvC = uvB;
          uvB = uvA;
          uvA = norm;
          norm = void 0;
        }
        var va = this.__checkVertex(a2), vb = this.__checkVertex(b2), vc = this.__checkVertex(c2), nc, t, f2;
        if (va.id === vb.id || va.id === vc.id || vb.id === vc.id) {
          console.log("Ignoring invalid face: " + a2 + "," + b2 + "," + c2);
        } else {
          if (norm !== void 0 && norm !== null) {
            nc = va.sub(vc).crossSelf(va.sub(vb));
            if (norm.dot(nc) < 0) {
              t = va;
              va = vb;
              vb = t;
            }
          }
          f2 = new WEFace(va, vb, vc, uvA, uvB, uvC);
          this.faces.push(f2);
          this.updateEdge(va, vb, f2);
          this.updateEdge(vb, vc, f2);
          this.updateEdge(vc, va, f2);
        }
        return this;
      };
      proto.center = function(origin, callback) {
        TriangleMesh2.prototype.center.call(this, origin, callback);
        this.rebuildIndex();
      };
      proto.clear = function() {
        TriangleMesh2.prototype.clear.call(this);
        this.edgeMap = new internals.LinkedMap(edgeKeyGenerator);
        this.edges = this.edgeMap.getArray();
        return this;
      };
      proto.copy = function() {
        var m = new WETriangleMesh(this.name + "-copy");
        var i2, l2, f2;
        l2 = this.faces.length;
        for (i2 = 0; i2 < l2; i2++) {
          f2 = this.faces[i2];
          m.addFace(f2.a, f2.b, f2.c, f2.normal, f2.uvA, f2.uvB, f2.uvC);
        }
        return m;
      };
      proto._createVertex = function(vec3D, id) {
        var vertex = new WEVertex(vec3D, id);
        return vertex;
      };
      proto.getNumEdges = function() {
        return this.edgeMap.size();
      };
      proto.init = function(name) {
        TriangleMesh2.prototype.init.call(this, name);
        this.edgeMap = new internals.LinkedMap(edgeKeyGenerator);
        this.edges = this.edgeMap.getArray();
        this.__edgeCheck = new Line3D(new Vec3D(), new Vec3D());
        this.__uniqueEdgeID = 0;
      };
      proto.rebuildIndex = function() {
        var newVertexMap = new internals.LinkedMap(vertexKeyGenerator);
        var newEdgeMap = new internals.LinkedMap(edgeKeyGenerator);
        var i2 = 0, arr = this.vertexMap.getArray();
        for (i2 = 0; i2 < arr.length; i2++) {
          newVertexMap.put(arr[i2], arr[i2]);
        }
        arr = this.edgeMap.getArray();
        for (i2 = 0; i2 < arr.length; i2++) {
          newEdgeMap.put(arr[i2], arr[i2]);
        }
        this.vertexMap = newVertexMap;
        this.vertices = newVertexMap.getArray();
        this.edgeMap = newEdgeMap;
        this.edges = newEdgeMap.getArray();
      };
      proto.removeEdge = function(edge) {
        edge.remove();
        var v2 = edge.a;
        if (v2.edges.length === 0) {
          this.vertexMap.remove(v2);
        }
        v2 = edge.b;
        if (v2.edges.length === 0) {
          this.vertexMap.remove(v2);
        }
        for (var i2 = 0; i2 < edge.faces.length; i2++) {
          this.removeFace(edge.faces[i2]);
        }
        var removed = this.edgeMap.remove(this.__edgeCheck.set(edge.a, edge.b));
        if (!removed) {
          this.edgeMap.remove(this.__edgeCheck.set(edge.b, edge.a));
        }
        if (removed !== edge) {
          throw new Error("Can't remove edge");
        }
      };
      proto.removeFace = function(face) {
        var i2 = this.faces.indexOf(face);
        if (i2 > -1) {
          this.faces.splice(i2, 1);
        }
        i2 = 0;
        var edge;
        for (i2 = 0; i2 < face.edges.length; i2++) {
          edge = face.edges[i2];
          edge.faces.splice(edge.faces.indexOf(face), 1);
          if (edge.faces.length === 0) {
            this.removeEdge(edge);
          }
        }
      };
      proto.removeUnusedVertices = function() {
        internals.each(this.vertices, function(vertex, i2) {
          var isUsed = false;
          internals.each(this.faces, function(f2) {
            if (f2.a == vertex || f2.b == vertex || f2.c == vertex) {
              isUsed = true;
              return;
            }
          });
          if (!isUsed) {
            this.vertices.splice(i2, 1);
          }
        });
      };
      proto.removeVertices = function(selection) {
        internals.each(selection, function(vertex) {
          internals.each(vertex.edges, function(edge) {
            internals.each(edge.faces, function(face) {
              this.removeFace(face);
            });
          });
        });
      };
      proto.splitEdge = function(a2, b2, subDiv) {
        var edge, mid;
        if (arguments.length === 3) {
          edge = this.edgeMap.get(this.__edgeCheck.set(a2, b2));
          if (!edge) {
            this.edgeMap.get(this.__edgeCheck.set(b2, a2));
          }
        } else if (arguments.length == 2) {
          edge = a2;
          subDiv = b2;
        }
        mid = subDiv.computeSplitPoints(edge);
        this.splitFace(edge.faces[0], edge, mid);
        if (edge.faces.length > 1) {
          this.splitFace(edge.faces[1], edge, mid);
        }
        this.removeEdge(edge);
      };
      proto.splitFace = function(face, edge, midPoints) {
        var p, i2, ec, prev, num, mid;
        for (i2 = 0; i2 < 3; i2++) {
          ec = face.edges[i2];
          if (!ec.equals(edge)) {
            if (ec.a.equals(edge.a) || ec.a.equals(edge.b)) {
              p = ec.b;
            } else {
              p = ec.a;
            }
            break;
          }
        }
        num = midPoints.length;
        for (i2 = 0; i2 < num; i2++) {
          mid = midPoints[i2];
          if (i2 === 0) {
            this.addFace(p, edge.a, mid, face.normal);
          } else {
            this.addFace(p, prev, mid, face.normal);
          }
          if (i2 === num - 1) {
            this.addFace(p, mid, edge.b, face.normal);
          }
          prev = mid;
        }
      };
      proto.subdivide = function(subDiv, minLength) {
        if (arguments.length === 1) {
          minLength = subDiv;
          subDiv = new MidpointSubdivision();
        }
        this.subdivideEdges(this.edges.slice(0), subDiv, minLength);
      };
      proto.subdivideEdges = function(origEdges, subDiv, minLength) {
        origEdges.sort(subDiv.getEdgeOrdering());
        minLength *= minLength;
        var i2 = 0, l2 = origEdges.length;
        for (i2 = 0; i2 < l2; i2++) {
          var e = origEdges[i2];
          if (this.edges.indexOf(e) > -1) {
            if (e.getLengthSquared() >= minLength) {
              this.splitEdge(e, subDiv);
            }
          }
        }
      };
      proto.subdivideFaceEdges = function(faces, subDiv, minLength) {
        var fedges = [], i2, j, f2, e, fl, el;
        fl = this.faces.length;
        for (i2 = 0; i2 < fl; i2++) {
          f2 = this.faces[i2];
          el = f2.edges.length;
          for (j = 0; j < el; j++) {
            e = f2.edges[j];
            if (fedges.indexOf(e) < 0) {
              fedges.push(e);
            }
          }
        }
        this.subdividEdges(fedges, subDiv, minLength);
      };
      proto.toString = function() {
        return "WETriangleMesh: " + this.name + " vertices: " + this.getNumVertices() + " faces: " + this.getNumFaces() + " edges:" + this.getNumEdges();
      };
      proto.transform = function(matrix, updateNormals) {
        if (updateNormals === void 0 || updateNormals === null) {
          updateNormals = true;
        }
        for (var i2 = 0, l2 = this.vertices.length; i2 < l2; i2++) {
          matrix.applyToSelf(this.vertices[i2]);
        }
        this.rebuildIndex();
        if (updateNormals) {
          this.computeFaceNormals();
        }
        return this;
      };
      proto.updateEdge = function(va, vb, face) {
        this.__edgeCheck.set(va, vb);
        var e = this.edgeMap.get(this.__edgeCheck);
        if (!e) {
          this.__edgeCheck.set(vb, va);
          e = this.edgeMap.get(this.__edgeCheck);
        }
        if (e !== void 0) {
          e.addFace(face);
        } else {
          e = new WingedEdge(va, vb, face, this.__uniqueEdgeID++);
          this.edgeMap.put(e, e);
          va.addEdge(e);
          vb.addEdge(e);
        }
        face.addEdge(e);
      };
    })(TriangleMesh);
    (function(TriangleMesh2) {
      var internals = require_internals(), mathUtils = require_mathUtils(), Interpolation2D = require_Interpolation2D(), Ray3D = require_Ray3D(), TriangleIntersector = require_TriangleIntersector(), Triangle3D = require_Triangle3D(), IsectData3D = require_IsectData3D(), Vec2D = require_vectors().Vec2D, Vec3D = require_vectors().Vec3D;
      Terrain = function(width, depth, scale) {
        this.width = width;
        this._depth = depth;
        if (!internals.has.XY(scale)) {
          scale = new Vec2D(scale, scale);
        }
        this.setScale(scale);
        this.elevation = [];
        var i2 = 0, len = width * depth;
        for (i2 = 0; i2 < len; i2++) {
          this.elevation[i2] = 0;
        }
        this.__elevationLength = this.width * this._depth;
        this.vertices = [];
        var offset = new Vec3D(parseInt(this.width / 2, 10), 0, parseInt(this._depth / 2, 10)), scaleXZ = this.getScale().to3DXZ();
        i2 = 0;
        for (var z2 = 0; z2 < this._depth; z2++) {
          for (var x2 = 0; x2 < this.width; x2++) {
            this.vertices[i2++] = new Vec3D(x2, 0, z2).subSelf(offset).scaleSelf(scaleXZ);
          }
        }
      };
      Terrain.prototype = {
        /**
        * @return number of grid cells along the Z axis.
        */
        getDepth: function() {
          return this._depth;
        },
        getElevation: function() {
          return this.elevation;
        },
        /**
        * @param {Number} x
        * @param {Number} z
        * @return the elevation at grid point
        */
        getHeightAtCell: function(x2, z2) {
          return this.elevation[this._getIndex(x2, z2)];
        },
        /**
        * Computes the elevation of the terrain at the given 2D world coordinate
        * (based on current terrain scale).
        *
        * @param {Number} x scaled world coord x
        * @param {Number} z scaled world coord z
        * @return {Number} interpolated elevation
        */
        getHeightAtPoint: function(x2, z2) {
          var xx = x2 / this._scale.x + this.width * 0.5, zz = z2 / this._scale.y + this._depth * 0.5, y2 = 0, flxx = ~~x2, flzz = ~~zz;
          if (xx >= 0 & xx < this.width && zz >= 0 && zz < this._depth) {
            var x22 = ~~Math.min(xx + 1, this.width - 1), z22 = ~~Math.min(zz + 1, this._depth - 1);
            var a2 = this.getHeightAtCell(flxx, flzz), b2 = this.getHeightAtCell(x22, flzz), c2 = this.getHeightAtCell(flxx, z22), d = this.getHeightAtCell(x22, z22);
            y2 = Interpolation2D.bilinear(xx, zz, flxx, flzz, x22, z22, a2, b2, c2, d);
          }
          return y2;
        },
        /**
        * Computes the array index for the given cell coords & checks if they're in
        * bounds. If not an {@link IndexOutOfBoundsException} is thrown.
        * @param {Number} x
        * @param {Number} z
        * @return {Number} array index
        */
        _getIndex: function(x2, z2) {
          var idx = z2 * this.width + x2;
          if (idx < 0 || idx > this.__elevationLength) {
            throw new Error("the given terrain cell is invalid: " + x2 + ";" + z2);
          }
          return idx;
        },
        /**
         * @return {Vec2D} the scale
         */
        getScale: function() {
          return this._scale;
        },
        getVertexAtCell: function(x2, z2) {
          return this.vertices[this._getIndex(x2, z2)];
        },
        /**
         * @return {Number} number of grid cells along X axis
         */
        getWidth: function() {
          return this.width;
        },
        /**
        * Computes the 3D position (with elevation) and normal vector at the given
        * 2D location in the terrain. The position is in scaled world coordinates
        * based on the given terrain scale. The returned data is encapsulated in a
        * {@link toxi.geom.IsectData3D} instance.
        * @param {Number} x
        * @param {Number} z
        * @return {IsectData3D} intersection data parcel
        */
        intersectAtPoint: function(x2, z2) {
          var xx = x2 / this._scale.x + this.width * 0.5, zz = z2 / this._scale.y + this._depth * 0.5, isec = new IsectData3D();
          if (xx >= 0 && xx < this.width && zz >= 0 && zz < this._depth) {
            var x22 = ~~Math.min(xx + 1, this.width - 1), z22 = ~~Math.min(zz + 1, this._depth - 1), flxx = ~~xx, flzz = ~~zz, a2 = this.getVertexAtCell(flxx, flzz), b2 = this.getVertexAtCell(x22, flzz), c2 = this.getVertexAtCell(x22, z22), d = this.getVertexAtCell(flxx, z22), r = new Ray3D(new Vec3D(x2, 1e4, z2), new Vec3D(0, -1, 0)), i2 = new TriangleIntersector(new Triangle3D(a2, b2, d));
            if (i2.intersectsRay(r)) {
              isec = i2.getIntersectionData();
            } else {
              i2.setTriangle(new Triangle3D(b2, c2, d));
              i2.intersectsRay(r);
              isec = i2.getIntersectionData();
            }
          }
          return isec;
        },
        /**
        * Sets the elevation of all cells to those of the given array values.
        * @param {Array} elevation array of height values
        * @return itself
        */
        setElevation: function(elevation) {
          if (this.__elevationLength == elevation.length) {
            for (var i2 = 0, len = elevation.length; i2 < len; i2++) {
              this.vertices[i2].y = this.elevation[i2] = elevation[i2];
            }
          } else {
            throw new Error("the given elevation array size does not match terrain");
          }
          return this;
        },
        /**
        * Sets the elevation for a single given grid cell.
        * @param {Number} x
        * @param {Number} z
        * @param {Number} h new elevation value
        * @return itself
        */
        setHeightAtCell: function(x2, z2, h) {
          var index = this._getIndex(x2, z2);
          this.elevation[index] = h;
          this.vertices[index].y = h;
          return this;
        },
        setScale: function(scale) {
          if (!internals.has.XY(scale)) {
            scale = new Vec2D(scale, scale);
          }
          this._scale = scale;
        },
        toMesh: function() {
          var opts = {
            mesh: void 0,
            minX: 0,
            minZ: 0,
            maxX: this.width,
            maxZ: this._depth
          };
          var v2 = this.vertices, w2 = this.width, d = this._depth;
          if (arguments.length == 1 && typeof arguments[0] == "object") {
            var args = arguments[0];
            opts.mesh = args.mesh || new TriangleMesh2("terrain");
            opts.minX = args.minX || opts.minX;
            opts.minZ = args.minZ || opts.minZ;
            opts.maxX = args.maxX || opts.maxX;
            opts.maxZ = args.maxZ || opts.maxZ;
          } else if (arguments.length >= 5) {
            opts.mesh = arguments[0];
            opts.minX = arguments[1];
            opts.minZ = arguments[2];
            opts.maxX = arguments[3];
            opts.maxZ = arguments[4];
          }
          opts.mesh = opts.mesh || new TriangleMesh2("terrain");
          opts.minX = mathUtils.clip(opts.minX, 0, w2 - 1);
          opts.maxX = mathUtils.clip(opts.maxX, 0, w2);
          opts.minZ = mathUtils.clip(opts.minZ, 0, d - 1);
          opts.maxZ = mathUtils.clip(opts.maxZ, 0, d);
          opts.minX++;
          opts.minZ++;
          for (var z2 = opts.minZ, idx = opts.minX * w2; z2 < opts.maxZ; z2++, idx += w2) {
            for (var x2 = opts.minX; x2 < opts.maxX; x2++) {
              opts.mesh.addFace(v2[idx - w2 + x2 - 1], v2[idx - w2 + x2], v2[idx + x2 - 1]);
              opts.mesh.addFace(v2[idx - w2 + x2], v2[idx + x2], v2[idx + x2 - 1]);
            }
          }
          return opts.mesh;
        }
      };
    })(TriangleMesh);
    (function(TriangleMesh2) {
      var Vec3D = require_Vec3D(), Vec2D = require_Vec2D();
      SurfaceMeshBuilder = function(func) {
        this.func = func;
      };
      SurfaceMeshBuilder.prototype = {
        /*
        	create a mesh from a surface,
        	parameter options:
        		1 - Object options
        		1 - Number resolution
        		3 - TriangleMesh mesh, Number resolution, Number size
        		4 - TriangleMesh mesh, Number resolution, Number size, boolean isClosed
        */
        createMesh: function() {
          var opts = {
            mesh: void 0,
            resolution: 0,
            size: 1,
            isClosed: true
          };
          if (arguments.length == 1) {
            if (typeof arguments[0] == "object") {
              var arg = arguments[0];
              opts.mesh = arg.mesh;
              opts.resolution = arg.res || arg.resoultion || 0;
              if (arg.size !== void 0) {
                opts.size = arg.size;
              }
              if (arg.isClosed !== void 0) {
                opts.isClosed = arg.isClosed;
              }
            } else {
              opts.resolution = arguments[0];
            }
          } else if (arguments.length > 2) {
            opts.mesh = arguments[0];
            opts.resolution = arguments[1];
            opts.size = arguments[2];
            if (arguments.length == 4) {
              opts.isClosed = arguments[3];
            }
          }
          var mesh = opts.mesh;
          if (mesh === void 0 || mesh === null) {
            mesh = new TriangleMesh2();
          }
          var a2 = new Vec3D(), b2 = new Vec3D(), pa = new Vec3D(), pb = new Vec3D(), a0 = new Vec3D(), b0 = new Vec3D(), phiRes = this.func.getPhiResolutionLimit(opts.resolution), phiRange = this.func.getPhiRange(), thetaRes = this.func.getThetaResolutionLimit(opts.resolution), thetaRange = this.func.getThetaRange(), pres = 1 / phiRes, tres = 1 / thetaRes, ires = 1 / opts.resolution, pauv = new Vec2D(), pbuv = new Vec2D(), auv = new Vec2D(), buv = new Vec2D();
          for (var p = 0; p < phiRes; p++) {
            var phi = p * phiRange * ires;
            var phiNext = (p + 1) * phiRange * ires;
            for (var t = 0; t <= thetaRes; t++) {
              var theta = t * thetaRange * ires;
              var func = this.func;
              a2 = func.computeVertexFor(a2, phiNext, theta).scaleSelf(opts.size);
              auv.set(t * tres, 1 - (p + 1) * pres);
              b2 = func.computeVertexFor(b2, phi, theta).scaleSelf(opts.size);
              buv.set(t * tres, 1 - p * pres);
              if (b2.equalsWithTolerance(a2, 1e-4)) {
                b2.set(a2);
              }
              if (t > 0) {
                if (t == thetaRes && opts.isClosed) {
                  a2.set(a0);
                  b2.set(b0);
                }
                mesh.addFace(pa, pb, a2, pauv.copy(), pbuv.copy(), auv.copy());
                mesh.addFace(pb, b2, a2, pbuv.copy(), buv.copy(), auv.copy());
              } else {
                a0.set(a2);
                b0.set(b2);
              }
              pa.set(a2);
              pb.set(b2);
              pauv.set(auv);
              pbuv.set(buv);
            }
          }
          return mesh;
        },
        /**
        @return the function
        */
        getFunction: function() {
          return this.func;
        },
        setFunction: function(func) {
          this.func = func;
        }
      };
    })(TriangleMesh);
    exports.TriangleMesh = TriangleMesh;
    exports.WETriangleMesh = WETriangleMesh;
    exports.Terrain = Terrain;
    exports.SurfaceMeshBuilder = SurfaceMeshBuilder;
  }
});

// node_modules/toxiclibsjs/geom/AABB.js
var require_AABB = __commonJS({
  "node_modules/toxiclibsjs/geom/AABB.js"(exports, module) {
    init_process();
    init_buffer();
    var internals = require_internals();
    var Vec3D = require_Vec3D();
    var Vec2D = require_Vec2D();
    var mathUtils = require_mathUtils();
    var AABB = function(a2, b2) {
      if (a2 === void 0) {
        Vec3D.call(this);
        this.setExtent(new Vec3D());
      } else if (typeof a2 == "number") {
        Vec3D.call(this, new Vec3D());
        this.setExtent(a2);
      } else if (internals.has.XYZ(a2)) {
        Vec3D.call(this, a2);
        if (b2 === void 0 && internals.is.AABB(a2)) {
          this.setExtent(a2.getExtent());
        } else {
          if (typeof b2 == "number") {
            this.setExtent(new Vec3D(b2, b2, b2));
          } else {
            this.setExtent(b2);
          }
        }
      }
    };
    internals.extend(AABB, Vec3D);
    AABB.fromMinMax = function(min, max) {
      var a2 = Vec3D.min(min, max);
      var b2 = Vec3D.max(min, max);
      return new AABB(a2.interpolateTo(b2, 0.5), b2.sub(a2).scaleSelf(0.5));
    };
    AABB.prototype.containsPoint = function(p) {
      return p.isInAABB(this);
    };
    AABB.prototype.copy = function() {
      return new AABB(this);
    };
    AABB.prototype.getExtent = function() {
      return this.extent.copy();
    };
    AABB.prototype.getMax = function() {
      return this.max.copy();
    };
    AABB.prototype.getMin = function() {
      return this.min.copy();
    };
    AABB.prototype.getNormalForPoint = function(p) {
      p = p.sub(this);
      var pabs = this.extent.sub(p.getAbs());
      var psign = p.getSignum();
      var normal = Vec3D.X_AXIS.scale(psign.x);
      var minDist = pabs.x;
      if (pabs.y < minDist) {
        minDist = pabs.y;
        normal = Vec3D.Y_AXIS.scale(psign.y);
      }
      if (pabs.z < minDist) {
        normal = Vec3D.Z_AXIS.scale(psign.z);
      }
      return normal;
    };
    AABB.prototype.includePoint = function(p) {
      this.min.minSelf(p);
      this.max.maxSelf(p);
      this.set(this.min.interpolateTo(this.max, 0.5));
      this.extent.set(this.max.sub(this.min).scaleSelf(0.5));
      return this;
    };
    AABB.prototype.intersectsBox = function(box) {
      var t = box.sub(this);
      return Math.abs(t.x) <= this.extent.x + box.extent.x && Math.abs(t.y) <= this.extent.y + box.extent.y && Math.abs(t.z) <= this.extent.z + box.extent.z;
    };
    AABB.prototype.intersectsRay = function(ray, minDist, maxDist) {
      var invDir = ray.getDirection().reciprocal();
      var signDirX = invDir.x < 0;
      var signDirY = invDir.y < 0;
      var signDirZ = invDir.z < 0;
      var bbox = signDirX ? this.max : this.min;
      var tmin = (bbox.x - ray.x) * invDir.x;
      bbox = signDirX ? this.min : this.max;
      var tmax = (bbox.x - ray.x) * invDir.x;
      bbox = signDirY ? this.max : this.min;
      var tymin = (bbox.y - ray.y) * invDir.y;
      bbox = signDirY ? this.min : this.max;
      var tymax = (bbox.y - ray.y) * invDir.y;
      if (tmin > tymax || tymin > tmax) {
        return null;
      }
      if (tymin > tmin) {
        tmin = tymin;
      }
      if (tymax < tmax) {
        tmax = tymax;
      }
      bbox = signDirZ ? this.max : this.min;
      var tzmin = (bbox.z - ray.z) * invDir.z;
      bbox = signDirZ ? this.min : this.max;
      var tzmax = (bbox.z - ray.z) * invDir.z;
      if (tmin > tzmax || tzmin > tmax) {
        return null;
      }
      if (tzmin > tmin) {
        tmin = tzmin;
      }
      if (tzmax < tmax) {
        tmax = tzmax;
      }
      if (tmin < maxDist && tmax > minDist) {
        return ray.getPointAtDistance(tmin);
      }
      return void 0;
    };
    AABB.prototype.intersectsSphere = function(c2, r) {
      if (arguments.length == 1) {
        r = c2.radius;
      }
      var s, d = 0;
      if (c2.x < this.min.x) {
        s = c2.x - this.min.x;
        d = s * s;
      } else if (c2.x > this.max.x) {
        s = c2.x - this.max.x;
        d += s * s;
      }
      if (c2.y < this.min.y) {
        s = c2.y - this.min.y;
        d += s * s;
      } else if (c2.y > this.max.y) {
        s = c2.y - this.max.y;
        d += s * s;
      }
      if (c2.z < this.min.z) {
        s = c2.z - this.min.z;
        d += s * s;
      } else if (c2.z > this.max.z) {
        s = c2.z - this.max.z;
        d += s * s;
      }
      return d <= r * r;
    };
    AABB.prototype.intersectsTriangle = function(tri) {
      var v0, v1, v2, normal, e0, e1, e2, f2;
      v0 = tri.a.sub(this);
      v1 = tri.b.sub(this);
      v2 = tri.c.sub(this);
      e0 = v1.sub(v0);
      e1 = v2.sub(v1);
      e2 = v0.sub(v2);
      f2 = e0.getAbs();
      if (this.testAxis(e0.z, -e0.y, f2.z, f2.y, v0.y, v0.z, v2.y, v2.z, this.extent.y, this.extent.z)) {
        return false;
      }
      if (this.testAxis(-e0.z, e0.x, f2.z, f2.x, v0.x, v0.z, v2.x, v2.z, this.extent.x, this.extent.z)) {
        return false;
      }
      if (this.testAxis(e0.y, -e0.x, f2.y, f2.x, v1.x, v1.y, v2.x, v2.y, this.extent.x, this.extent.y)) {
        return false;
      }
      f2 = e1.getAbs();
      if (this.testAxis(e1.z, -e1.y, f2.z, f2.y, v0.y, v0.z, v2.y, v2.z, this.extent.y, this.extent.z)) {
        return false;
      }
      if (this.testAxis(-e1.z, e1.x, f2.z, f2.x, v0.x, v0.z, v2.x, v2.z, this.extent.x, this.extent.z)) {
        return false;
      }
      if (this.testAxis(e1.y, -e1.x, f2.y, f2.x, v0.x, v0.y, v1.x, v1.y, this.extent.x, this.extent.y)) {
        return false;
      }
      f2 = e2.getAbs();
      if (this.testAxis(e2.z, -e2.y, f2.z, f2.y, v0.y, v0.z, v1.y, v1.z, this.extent.y, this.extent.z)) {
        return false;
      }
      if (this.testAxis(-e2.z, e2.x, f2.z, f2.x, v0.x, v0.z, v1.x, v1.z, this.extent.x, this.extent.z)) {
        return false;
      }
      if (this.testAxis(e2.y, -e2.x, f2.y, f2.x, v1.x, v1.y, v2.x, v2.y, this.extent.x, this.extent.y)) {
        return false;
      }
      if (mathUtils.min(v0.x, v1.x, v2.x) > this.extent.x || mathUtils.max(v0.x, v1.x, v2.x) < -this.extent.x) {
        return false;
      }
      if (mathUtils.min(v0.y, v1.y, v2.y) > this.extent.y || mathUtils.max(v0.y, v1.y, v2.y) < -this.extent.y) {
        return false;
      }
      if (mathUtils.min(v0.z, v1.z, v2.z) > this.extent.z || mathUtils.max(v0.z, v1.z, v2.z) < -this.extent.z) {
        return false;
      }
      normal = e0.cross(e1);
      var d = -normal.dot(v0);
      if (!this.planeBoxOverlap(normal, d, this.extent)) {
        return false;
      }
      return true;
    };
    AABB.prototype.planeBoxOverlap = function(normal, d, maxbox) {
      var vmin = new Vec3D();
      var vmax = new Vec3D();
      if (normal.x > 0) {
        vmin.x = -maxbox.x;
        vmax.x = maxbox.x;
      } else {
        vmin.x = maxbox.x;
        vmax.x = -maxbox.x;
      }
      if (normal.y > 0) {
        vmin.y = -maxbox.y;
        vmax.y = maxbox.y;
      } else {
        vmin.y = maxbox.y;
        vmax.y = -maxbox.y;
      }
      if (normal.z > 0) {
        vmin.z = -maxbox.z;
        vmax.z = maxbox.z;
      } else {
        vmin.z = maxbox.z;
        vmax.z = -maxbox.z;
      }
      if (normal.dot(vmin) + d > 0) {
        return false;
      }
      if (normal.dot(vmax) + d >= 0) {
        return true;
      }
      return false;
    };
    AABB.prototype.set = function(a2, b2, c2) {
      if (internals.is.AABB(a2)) {
        this.extent.set(a2.extent);
        return Vec3D.set.apply(this, [a2]);
      }
      if (internals.has.XYZ(a2)) {
        b2 = a2.y;
        c2 = a2.z;
        a2 = a2.a;
      }
      this.x = a2;
      this.y = b2;
      this.z = c2;
      this.updateBounds();
      return this;
    };
    AABB.prototype.setExtent = function(extent) {
      this.extent = extent.copy();
      return this.updateBounds();
    };
    AABB.prototype.testAxis = function(a2, b2, fa, fb, va, vb, wa, wb, ea, eb) {
      var p0 = a2 * va + b2 * vb;
      var p2 = a2 * wa + b2 * wb;
      var min;
      var max;
      if (p0 < p2) {
        min = p0;
        max = p2;
      } else {
        min = p2;
        max = p0;
      }
      var rad = fa * ea + fb * eb;
      return min > rad || max < -rad;
    };
    AABB.prototype.toMesh = function(mesh) {
      if (mesh === void 0) {
        var TriangleMesh = require_meshCommon().TriangleMesh;
        mesh = new TriangleMesh("aabb", 8, 12);
      }
      var a2 = this.min, g = this.max, b2 = new Vec3D(a2.x, a2.y, g.z), c2 = new Vec3D(g.x, a2.y, g.z), d = new Vec3D(g.x, a2.y, a2.z), e = new Vec3D(a2.x, g.y, a2.z), f2 = new Vec3D(a2.x, g.y, g.z), h = new Vec3D(g.x, g.y, a2.z), ua = new Vec2D(0, 0), ub = new Vec2D(1, 0), uc = new Vec2D(1, 1), ud = new Vec2D(0, 1);
      mesh.addFace(a2, b2, f2, ud, uc, ub);
      mesh.addFace(a2, f2, e, ud, ub, ua);
      mesh.addFace(b2, c2, g, ud, uc, ub);
      mesh.addFace(b2, g, f2, ud, ub, ua);
      mesh.addFace(c2, d, h, ud, uc, ub);
      mesh.addFace(c2, h, g, ud, ub, ua);
      mesh.addFace(d, a2, e, ud, uc, ub);
      mesh.addFace(d, e, h, ud, ub, ua);
      mesh.addFace(e, f2, h, ua, ud, ub);
      mesh.addFace(f2, g, h, ud, uc, ub);
      mesh.addFace(a2, d, b2, ud, uc, ua);
      mesh.addFace(b2, d, c2, ua, uc, ub);
      return mesh;
    };
    AABB.prototype.toString = function() {
      return "<aabb> pos: " + Vec3D.prototype.toString.call(this) + " ext: " + this.extent.toString();
    };
    AABB.prototype.updateBounds = function() {
      if (this.extent !== void 0) {
        this.min = this.sub(this.extent);
        this.max = this.add(this.extent);
      }
      return this;
    };
    module.exports = AABB;
  }
});

// node_modules/toxiclibsjs/geom/Triangle3D.js
var require_Triangle3D = __commonJS({
  "node_modules/toxiclibsjs/geom/Triangle3D.js"(exports, module) {
    init_process();
    init_buffer();
    var mathUtils = require_mathUtils();
    var Vec3D = require_Vec3D();
    var Line3D = require_Line3D();
    var AABB = require_AABB();
    var Triangle3D = function(a2, b2, c2) {
      this.a = a2;
      this.b = b2;
      this.c = c2;
    };
    Triangle3D.createEquilateralFrom = function(a2, b2) {
      var c2 = a2.interpolateTo(b2, 0.5);
      var dir = b2.sub(a2);
      var n = a2.cross(dir.normalize());
      c2.addSelf(n.normalizeTo(dir.magnitude() * mathUtils.SQRT3 / 2));
      return new Triangle3D(a2, b2, c2);
    };
    Triangle3D.isClockwiseInXY = function(a2, b2, c2) {
      var determ = (b2.x - a2.x) * (c2.y - a2.y) - (c2.x - a2.x) * (b2.y - a2.y);
      return determ < 0;
    };
    Triangle3D.isClockwiseInXZ = function(a2, b2, c2) {
      var determ = (b2.x - a2.x) * (c2.z - a2.z) - (c2.x - a2.x) * (b2.z - a2.z);
      return determ < 0;
    };
    Triangle3D.isClockwiseInYZ = function(a2, b2, c2) {
      var determ = (b2.y - a2.y) * (c2.z - a2.z) - (c2.y - a2.y) * (b2.z - a2.z);
      return determ < 0;
    };
    Triangle3D.prototype = {
      closestPointOnSurface: function(p) {
        var ab = this.b.sub(this.a);
        var ac = this.c.sub(this.a);
        var bc = this.c.sub(this.b);
        var pa = p.sub(this.a);
        var pb = p.sub(this.b);
        var pc = p.sub(this.c);
        var ap = a.sub(this.p);
        var bp = b.sub(this.p);
        var cp = c.sub(this.p);
        var snom = pa.dot(ab);
        var tnom = pa.dot(ac);
        if (snom <= 0 && tnom <= 0) {
          return this.a;
        }
        var sdenom = pb.dot(this.a.sub(this.b));
        var tdenom = pc.dot(this.a.sub(this.c));
        var unom = pb.dot(bc);
        var udenom = pc.dot(this.b.sub(this.c));
        if (sdenom <= 0 && unom <= 0) {
          return this.b;
        }
        if (tdenom <= 0 && udenom <= 0) {
          return this.c;
        }
        var n = ab.cross(ac);
        var vc = n.dot(ap.crossSelf(bp));
        if (vc <= 0 && snom >= 0 && sdenom >= 0) {
          return this.a.add(ab.scaleSelf(snom / (snom + sdenom)));
        }
        var va = n.dot(bp.crossSelf(cp));
        if (va <= 0 && unom >= 0 && udenom >= 0) {
          return this.b.add(bc.scaleSelf(unom / (unom + udenom)));
        }
        var vb = n.dot(cp.crossSelf(ap));
        if (vb <= 0 && tnom >= 0 && tdenom >= 0) {
          return this.a.add(ac.scaleSelf(tnom / (tnom + tdenom)));
        }
        var u = va / (va + vb + vc);
        var v2 = vb / (va + vb + vc);
        var w2 = 1 - u - v2;
        return this.a.scale(u).addSelf(this.b.scale(v2)).addSelf(this.c.scale(w2));
      },
      computeCentroid: function() {
        this.centroid = this.a.add(this.b).addSelf(this.c).scaleSelf(1 / 3);
        return this.centroid;
      },
      computeNormal: function() {
        this.normal = this.a.sub(this.c).crossSelf(this.a.sub(this.b)).normalize();
        return this.normal;
      },
      containsPoint: function(p) {
        if (p.equals(this.a) || p.equals(this.b) || p.equals(this.c)) {
          return true;
        }
        var v1 = p.sub(this.a).normalize();
        var v2 = p.sub(this.b).normalize();
        var v3 = p.sub(this.c).normalize();
        var total_angles = Math.acos(v1.dot(v2));
        total_angles += Math.acos(v2.dot(v3));
        total_angles += Math.acos(v3.dot(v1));
        return mathUtils.abs(total_angles - mathUtils.TWO_PI) <= 5e-3;
      },
      flipVertexOrder: function() {
        var t = this.a;
        this.a = this.c;
        this.c = this.t;
        return this;
      },
      fromBarycentric: function(p) {
        return new Vec3D(this.a.x * p.x + this.b.x * p.y + this.c.x * p.z, this.a.y * p.x + this.b.y * p.y + this.c.y * p.z, this.a.z * p.x + this.b.z * p.y + this.c.z * p.z);
      },
      getBoundingBox: function() {
        var min = Vec3D.min(Vec3D.min(this.a, this.b), this.c);
        var max = Vec3D.max(Vec3D.max(this.a, this.b), this.c);
        return AABB.fromMinMax(min, max);
      },
      getClosestPointTo: function(p) {
        var edge = new Line3D(this.a, this.b);
        var Rab = edge.closestPointTo(p);
        var Rbc = edge.set(this.b, this.c).closestPointTo(p);
        var Rca = edge.set(this.c, this.a).closestPointTo(p);
        var dAB = p.sub(Rab).magSquared();
        var dBC = p.sub(Rbc).magSquared();
        var dCA = p.sub(Rca).magSquared();
        var min = dAB;
        var result = Rab;
        if (dBC < min) {
          min = dBC;
          result = Rbc;
        }
        if (dCA < min) {
          result = Rca;
        }
        return result;
      },
      isClockwiseInXY: function() {
        return Triangle3D.isClockwiseInXY(this.a, this.b, this.c);
      },
      isClockwiseInXZ: function() {
        return Triangle3D.isClockwiseInXY(this.a, this.b, this.c);
      },
      isClockwiseInYZ: function() {
        return Triangle3D.isClockwiseInXY(this.a, this.b, this.c);
      },
      set: function(a2, b2, c2) {
        this.a = a2;
        this.b = b2;
        this.c = c2;
      },
      toBarycentric: function(p) {
        var e = b.sub(this.a).cross(this.c.sub(this.a));
        var n = e.getNormalized();
        var areaABC = n.dot(e);
        var areaPBC = n.dot(this.b.sub(p).cross(this.c.sub(p)));
        var l1 = areaPBC / areaABC;
        var areaPCA = n.dot(this.c.sub(p).cross(this.a.sub(p)));
        var l2 = areaPCA / areaABC;
        var l3 = 1 - l1 - l2;
        return new Vec3D(l1, l2, l3);
      },
      toString: function() {
        return "Triangle: " + this.a + "," + this.b + "," + this.c;
      }
    };
    module.exports = Triangle3D;
  }
});

// node_modules/toxiclibsjs/geom/BernsteinPolynomial.js
var require_BernsteinPolynomial = __commonJS({
  "node_modules/toxiclibsjs/geom/BernsteinPolynomial.js"(exports, module) {
    init_process();
    init_buffer();
    var BernsteinPolynomial = function(res) {
      this.resolution = res;
      var b0 = [], b1 = [], b2 = [], b3 = [];
      var t = 0;
      var dt = 1 / (res - 1);
      for (var i2 = 0; i2 < res; i2++) {
        var t1 = 1 - t;
        var t12 = t1 * t1;
        var t2 = t * t;
        b0[i2] = t1 * t12;
        b1[i2] = 3 * t * t12;
        b2[i2] = 3 * t2 * t1;
        b3[i2] = t * t2;
        t += dt;
      }
      this.b0 = b0;
      this.b1 = b1;
      this.b2 = b2;
      this.b3 = b3;
    };
    module.exports = BernsteinPolynomial;
  }
});

// node_modules/toxiclibsjs/geom/Line2D.js
var require_Line2D = __commonJS({
  "node_modules/toxiclibsjs/geom/Line2D.js"(exports, module) {
    init_process();
    init_buffer();
    var Ray2D = require_Ray2D();
    var internals = require_internals();
    var mathUtils = require_mathUtils();
    var Line2D = function(a2, b2) {
      this.a = a2;
      this.b = b2;
    };
    Line2D.prototype = {
      constructor: Line2D,
      /**
       * Computes the dot product of these 2 vectors: line start -> point
       * and the perpendicular line direction if the result is negative.
       *
       * @param {Vec2D} p
       * @return classifier Number
       */
      classifyPoint: function(p) {
        var normal = this.b.sub(this.a).perpendicular();
        var d = p.sub(this.a).dot(normal);
        return mathUtils.sign(d);
      },
      /**
         * Computes the closest point on this line to the point given.
         *
         * @param {Vec2D} p point to check against
         * @return closest point on the line
         */
      closestPointTo: function(p) {
        var v2 = this.b.sub(this.a);
        var t = p.sub(this.a).dot(v2) / v2.magSquared();
        if (t < 0) {
          return this.a.copy();
        } else if (t > 1) {
          return this.b.copy();
        }
        return this.a.add(v2.scaleSelf(t));
      },
      copy: function() {
        return new Line2D(this.a.copy(), this.b.copy());
      },
      distanceToPoint: function(p) {
        return this.closestPointTo(p).distanceTo(p);
      },
      distanceToPointSquared: function(p) {
        return this.closestPointTo(p).distanceToSquared(p);
      },
      equals: function(obj) {
        if (this == obj) {
          return true;
        }
        if (!internals.is.Line2D(obj)) {
          return false;
        }
        var l2 = obj;
        return (this.a.equals(l2.a) || this.a.equals(l2.b)) && (this.b.equals(l2.b) || this.b.equals(l2.a));
      },
      getDirection: function() {
        return this.b.sub(this.a).normalize();
      },
      getHeading: function() {
        return this.b.sub(this.a).heading();
      },
      getLength: function() {
        return this.a.distanceTo(this.b);
      },
      getLengthSquared: function() {
        return this.a.distanceToSquared(this.b);
      },
      getMidPoint: function() {
        return this.a.add(this.b).scaleSelf(0.5);
      },
      getNormal: function() {
        return this.b.sub(this.a).perpendicular();
      },
      getTheta: function() {
        return this.a.angleBetween(this.b, true);
      },
      hasEndPoint: function(p) {
        return this.a.equals(p) || this.b.equals(p);
      },
      /**
         * Computes intersection between this and the given line. The returned value
         * is a {@link LineIntersection} instance and contains both the type of
         * intersection as well as the intersection point (if existing).
         *
         * Based on: http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/
         *
         * @param l
         *            line to intersect with
         * @return intersection result
         */
      intersectLine: function(l2) {
        var Type = Line2D.LineIntersection.Type;
        var isec, denom = (l2.b.y - l2.a.y) * (this.b.x - this.a.x) - (l2.b.x - l2.a.x) * (this.b.y - this.a.y), na = (l2.b.x - l2.a.x) * (this.a.y - l2.a.y) - (l2.b.y - l2.a.y) * (this.a.x - l2.a.x), nb = (this.b.x - this.a.x) * (this.a.y - l2.a.y) - (this.b.y - this.a.y) * (this.a.x - l2.a.x);
        if (denom !== 0) {
          var ua = na / denom, ub = nb / denom, vecI = this.a.interpolateTo(this.b, ua);
          if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
            isec = new Line2D.LineIntersection(Type.INTERSECTING, vecI, ua, ub);
          } else {
            isec = new Line2D.LineIntersection(Type.NON_INTERSECTING, vecI, ua, ub);
          }
        } else {
          if (na === 0 && nb === 0) {
            if (this.distanceToPoint(l2.a) === 0) {
              isec = new Line2D.LineIntersection(Type.COINCIDENT, void 0);
            } else {
              isec = new Line2D.LineIntersection(Type.COINCIDENT_NO_INTERSECT, void 0);
            }
          } else {
            isec = new Line2D.LineIntersection(Type.PARALLEL, void 0);
          }
        }
        return isec;
      },
      offsetAndGrowBy: function(offset, scale, ref) {
        var m = this.getMidPoint();
        var d = this.getDirection();
        var n = d.getPerpendicular();
        if (ref !== void 0 && m.sub(ref).dot(n) < 0) {
          n.invert();
        }
        n.normalizeTo(offset);
        this.a.addSelf(n);
        this.b.addSelf(n);
        d.scaleSelf(scale);
        this.a.subSelf(d);
        this.b.addSelf(d);
        return this;
      },
      scale: function(scale) {
        var delta = (1 - scale) * 0.5;
        var newA = this.a.interpolateTo(this.b, delta);
        this.b.interpolateToSelf(this.a, delta);
        this.a.set(newA);
        return this;
      },
      set: function(a2, b2) {
        this.a = a2;
        this.b = b2;
        return this;
      },
      splitIntoSegments: function(segments, stepLength, addFirst) {
        return Line2D.splitIntoSegments(this.a, this.b, stepLength, segments, addFirst);
      },
      toRay2D: function() {
        var Ray2D2 = require_Ray2D();
        return new Ray2D2(this.a.copy(), this.b.sub(this.a).normalize());
      }
    };
    Line2D.splitIntoSegments = function(a2, b2, stepLength, segments, addFirst) {
      if (segments === void 0) {
        segments = [];
      }
      if (addFirst) {
        segments.push(a2.copy());
      }
      var dist = a2.distanceTo(b2);
      if (dist > stepLength) {
        var pos = a2.copy();
        var step = b2.sub(a2).limit(stepLength);
        while (dist > stepLength) {
          pos.addSelf(step);
          segments.push(pos.copy());
          dist -= stepLength;
        }
      }
      segments.push(b2.copy());
      return segments;
    };
    Line2D.LineIntersection = function(type, pos, ua, ub) {
      this.type = type;
      this.pos = pos;
      this.coeff = [ua, ub];
    };
    Line2D.LineIntersection.prototype = {
      getPos: function() {
        return this.pos ? this.pos.copy() : void 0;
      },
      getCoefficients: function() {
        return this.coeff;
      },
      getType: function() {
        return this.type;
      },
      toString: function() {
        return "type: " + this.type + " pos: " + this.pos;
      }
    };
    Line2D.LineIntersection.Type = {
      COINCIDENT: 0,
      COINCIDENT_NO_INTERSECT: 4,
      PARALLEL: 1,
      NON_INTERSECTING: 2,
      INTERSECTING: 3
    };
    module.exports = Line2D;
  }
});

// node_modules/toxiclibsjs/geom/Ray2D.js
var require_Ray2D = __commonJS({
  "node_modules/toxiclibsjs/geom/Ray2D.js"(exports, module) {
    init_process();
    init_buffer();
    var extend = require_internals().extend;
    var Vec2D = require_Vec2D();
    var Line2D = require_Line2D();
    var Ray2D = function(a2, b2, d) {
      var o, dir;
      if (arguments.length == 3) {
        Vec2D.apply(this, [a2, b2]);
        this.dir = d.getNormalized();
      } else if (arguments.length == 2) {
        Vec2D.apply(this, [a2]);
        this.dir = b2.getNormalized();
      } else if (arguments.length === 0) {
        Vec2D.apply(this);
        this.dir = Vec2D.Y_AXIS.copy();
      }
    };
    extend(Ray2D, Vec2D);
    Ray2D.prototype.getDirection = function() {
      return this.dir.copy();
    };
    Ray2D.prototype.getDistanceToPoint = function(p) {
      var sp = p.sub(this);
      return sp.distanceTo(this.dir.scale(sp.dot(this.dir)));
    };
    Ray2D.prototype.getPointAtDistance = function(dist) {
      return this.add(this.dir.scale(dist));
    };
    Ray2D.prototype.setDirection = function(d) {
      this.dir.set(d).normalize();
      return this;
    };
    Ray2D.prototype.toLine2DWithPointAtDistance = function(dist) {
      var Line2D2 = require_Line2D();
      return new Line2D2(this, this.getPointAtDistance(dist));
    };
    Ray2D.prototype.toString = function() {
      return "origin: " + Vec2D.prototype.toString.apply(this) + " dir: " + this.dir;
    };
    module.exports = Ray2D;
  }
});

// node_modules/toxiclibsjs/geom/Ellipse.js
var require_Ellipse = __commonJS({
  "node_modules/toxiclibsjs/geom/Ellipse.js"(exports, module) {
    init_process();
    init_buffer();
    var extend = require_extend();
    var has = require_has();
    var is = require_is();
    var mathUtils = require_mathUtils();
    var Vec2D = require_Vec2D();
    var Ellipse;
    var Circle;
    Ellipse = function(a2, b2, c2, d) {
      this.radius = new Vec2D();
      if (arguments.length === 0) {
        Vec2D.apply(this, [0, 0]);
        this.setRadii(1, 1);
      } else if (has.XY(a2)) {
        Vec2D.apply(this, [a2.x, a2.y]);
        if (has.XY(b2)) {
          this.setRadii(b2.x, b2.y);
        } else {
          this.setRadii(b2, c2);
        }
      } else {
        if (d === void 0) {
          if (c2 === void 0) {
            Vec2D.call(this, 0, 0);
            this.setRadii(a2, b2);
          } else {
            Vec2D.call(this, a2, b2);
            this.setRadii(c2, c2);
          }
        } else {
          Vec2D.call(this, a2, b2);
          this.setRadii(c2, d);
        }
      }
    };
    extend(Ellipse, Vec2D);
    Ellipse.prototype.containsPoint = function(p) {
      if (mathUtils.abs(p.x - this.x) > this.radius.x || mathUtils.abs(p.y - this.y) > this.radius.y) {
        return false;
      }
      var foci = this.getFoci();
      return p.distanceTo(foci[0]) + p.distanceTo(foci[1]) < 2 * mathUtils.max(this.radius.x, this.radius.y);
    };
    Ellipse.prototype.getArea = function() {
      return mathUtils.PI * this.radius.x * this.radius.y;
    };
    Ellipse.prototype.getCircumference = function() {
      return Math.sqrt(0.5 * this.radius.magSquared()) * mathUtils.TWO_PI;
    };
    Ellipse.prototype.getFoci = function() {
      if (this.radius.x > this.radius.y) {
        return [
          this.sub(this.focus, 0),
          this.add(this.focus, 0)
        ];
      }
      return [
        this.sub(0, this.focus),
        this.add(0, this.focus)
      ];
    };
    Ellipse.prototype.getRadii = function() {
      return this.radius.copy();
    };
    Ellipse.prototype.setRadii = function(rx, ry) {
      if (has.XY(rx)) {
        ry = rx.y;
        rx = rx.x;
      }
      this.radius.set(rx, ry);
      if (this.radius.x > this.radius.y) {
        this.focus = Math.sqrt(this.radius.x * this.radius.x - this.radius.y * this.radius.y);
      } else {
        this.focus = Math.sqrt(this.radius.y * this.radius.y - this.radius.x * this.radius.x);
      }
      return this;
    };
    Ellipse.prototype.toPolygon2D = function(res) {
      var Polygon2D = require_Polygon2D();
      var poly = new Polygon2D();
      var step = mathUtils.TWO_PI / res;
      for (var i2 = 0; i2 < res; i2++) {
        var v2 = Vec2D.fromTheta(i2 * step).scaleSelf(this.radius).addSelf(this);
        poly.add(v2);
      }
      return poly;
    };
    exports = module.exports = Ellipse;
    Circle = function(a2, b2, c2) {
      if (arguments.length == 1) {
        if (is.Circle(a2)) {
          Ellipse.apply(this, [a2, a2.radius.x]);
        } else {
          Ellipse.apply(this, [0, 0, a2]);
        }
      } else if (arguments.length == 2) {
        Ellipse.apply(this, [a2, b2]);
      } else {
        Ellipse.apply(this, [a2, b2, c2, c2]);
      }
    };
    extend(Circle, Ellipse);
    Circle.from2Points = function(p1, p2) {
      var m = p1.interpolateTo(p2, 0.5);
      var distanceTo = m.distanceTo(p1);
      return new Circle(m, distanceTo);
    };
    Circle.from3Points = function(p1, p2, p3) {
      var circle, deltaA = p2.sub(p1), deltaB = p3.sub(p2), centroid, radius;
      if (mathUtils.abs(deltaA.x) <= 1e-7 && mathUtils.abs(deltaB.y) <= 1e-7) {
        centroid = new Vec2D(p2.x + p3.x, p1.y + p2.y).scaleSelf(0.5);
        radius = centroid.distanceTo(p1);
        circle = new Circle(centroid, radius);
      } else {
        var aSlope = deltaA.y / deltaA.x;
        var bSlope = deltaB.y / deltaB.x;
        if (mathUtils.abs(aSlope - bSlope) > 1e-7 && aSlope !== 0) {
          var x2 = (aSlope * bSlope * (p1.y - p3.y) + bSlope * (p1.x + p2.x) - aSlope * (p2.x + p3.x)) / (2 * (bSlope - aSlope));
          var y2 = -(x2 - (p1.x + p2.x) / 2) / aSlope + (p1.y + p2.y) / 2;
          centroid = new Vec2D(x2, y2);
          radius = centroid.distanceTo(p1);
          circle = new Circle(centroid, radius);
        }
      }
      return circle;
    };
    Circle.newBoundingCircle = function(vertices) {
      var origin = new Vec2D();
      var maxD = 0;
      var i2 = 0;
      var l2 = vertices.length;
      for (; i2 < l2; i2++) {
        origin.addSelf(vertices[i2]);
      }
      origin.scaleSelf(1 / vertices.length);
      for (i2 = 0; i2 < l2; i2++) {
        var d = origin.distanceToSquared(vertices[i2]);
        if (d > maxD) {
          maxD = d;
        }
      }
      return new Circle(origin, Math.sqrt(maxD));
    };
    Circle.prototype.containsPoint = function(p) {
      return this.distanceToSquared(p) <= this.radius.x * this.radius.x;
    };
    Circle.prototype.getCircumference = function() {
      return mathUtils.TWO_PI * this.radius.x;
    };
    Circle.prototype.getRadius = function() {
      return this.radius.x;
    };
    Circle.prototype.getTangentPoints = function(p) {
      var m = this.interpolateTo(p, 0.5);
      return this.intersectsCircle(new Circle(m, m.distanceTo(p)));
    };
    Circle.prototype.intersectsCircle = function(c2) {
      var res, delta = c2.sub(this), d = delta.magnitude(), r1 = this.radius.x, r2 = c2.radius.x;
      if (d <= r1 + r2 && d >= Math.abs(r1 - r2)) {
        var a2 = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
        d = 1 / d;
        var p = this.add(delta.scale(a2 * d));
        var h = Math.sqrt(r1 * r1 - a2 * a2);
        delta.perpendicular().scaleSelf(h * d);
        var i1 = p.add(delta);
        var i2 = p.sub(delta);
        res = [i1, i2];
      }
      return res;
    };
    Circle.prototype.setRadius = function(r) {
      this.setRadii(r, r);
      return this;
    };
    exports.Circle = Circle;
  }
});

// node_modules/toxiclibsjs/geom/Circle.js
var require_Circle = __commonJS({
  "node_modules/toxiclibsjs/geom/Circle.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_Ellipse().Circle;
  }
});

// node_modules/toxiclibsjs/geom/mesh/TriangleMesh.js
var require_TriangleMesh = __commonJS({
  "node_modules/toxiclibsjs/geom/mesh/TriangleMesh.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_meshCommon().TriangleMesh;
  }
});

// node_modules/toxiclibsjs/geom/Polygon2D.js
var require_Polygon2D = __commonJS({
  "node_modules/toxiclibsjs/geom/Polygon2D.js"(exports, module) {
    init_process();
    init_buffer();
    var MathUtils = require_mathUtils();
    var Vec2D = require_Vec2D();
    var Line2D = require_Line2D();
    var Circle = require_Circle();
    var Rect = require_Rect();
    var TriangleMesh = require_TriangleMesh();
    var has = require_has();
    var is = require_is();
    var Polygon2D = function() {
      this.vertices = [];
      var i2, l2;
      if (arguments.length > 1) {
        for (i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
          this.add(arguments[i2].copy());
        }
      } else if (arguments.length == 1) {
        var arg = arguments[0];
        if (is.Array(arg)) {
          for (i2 = 0, l2 = arg.length; i2 < l2; i2++) {
            this.add(arg[i2].copy());
          }
        }
      }
    };
    Polygon2D.prototype = {
      constructor: Polygon2D,
      add: function(p) {
        if (is.Array(p)) {
          for (var i2 = 0, l2 = p.length; i2 < l2; i2++) {
            if (this.vertices.indexOf(p[i2]) < 0) {
              this.vertices.push(p[i2]);
            }
          }
          return;
        }
        if (this.vertices.indexOf(p) < 0) {
          this.vertices.push(p);
        }
      },
      /**
      * centers the polygon so that its new centroid is at the given point
      * @param {Vec2D} [origin]
      * @return itself
      */
      center: function(origin) {
        var centroid = this.getCentroid();
        var delta = origin !== void 0 ? origin.sub(centroid) : centroid.invert();
        for (var i2 = 0, l2 = this.vertices.length; i2 < l2; i2++) {
          this.vertices[i2].addSelf(delta);
        }
        return this;
      },
      containsPoint: function(p) {
        var num = this.vertices.length, i2 = 0, j = num - 1, oddNodes = false, px = p.x, py = p.y;
        for (i2 = 0; i2 < num; i2++) {
          var vi = this.vertices[i2], vj = this.vertices[j];
          if (vi.y < py && vj.y >= py || vj.y < py && vi.y >= py) {
            if (vi.x + (py - vi.y) / (vj.y - vi.y) * (vj.x - vi.x) < px) {
              oddNodes = !oddNodes;
            }
          }
          j = i2;
        }
        return oddNodes;
      },
      containsPolygon: function(poly) {
        for (var i2 = 0, num = poly.vertices.length; i2 < num; i2++) {
          if (!this.containsPoint(poly.vertices[i2])) {
            return false;
          }
        }
        return true;
      },
      copy: function() {
        return new Polygon2D(this.vertices);
      },
      flipVertexOrder: function() {
        this.vertices.reverse();
        return this;
      },
      /**
      * Returns the vertex at the given index. This function follows Python
      * convention, in that if the index is negative, it is considered relative
      * to the list end. Therefore the vertex at index -1 is the last vertex in
      * the list.
      * @param {Number} i index
      * @return vertex
      */
      get: function(i2) {
        if (i2 < 0) {
          i2 += this.vertices.length;
        }
        return this.vertices[i2];
      },
      /**
      * Computes the length of this polygon's apothem. This will only be valid if
      * the polygon is regular. More info: http://en.wikipedia.org/wiki/Apothem
      * @return apothem length
      */
      getApothem: function() {
        return this.vertices[0].interpolateTo(this.vertices[1], 0.5).distanceTo(this.getCentroid());
      },
      getArea: function() {
        var area = 0, numPoints = this.vertices.length;
        for (var i2 = 0; i2 < numPoints; i2++) {
          var a2 = this.vertices[i2], b2 = this.vertices[(i2 + 1) % numPoints];
          area += a2.x * b2.y;
          area -= a2.y * b2.x;
        }
        area *= 0.5;
        return area;
      },
      getBoundingCircle: function() {
        var Circle2 = require_Circle();
        return Circle2.newBoundingCircle(this.vertices);
      },
      getBounds: function() {
        var Rect2 = require_Rect();
        return Rect2.getBoundingRect(this.vertices);
      },
      getCentroid: function() {
        var res = new Vec2D(), numPoints = this.vertices.length;
        for (var i2 = 0; i2 < numPoints; i2++) {
          var a2 = this.vertices[i2], b2 = this.vertices[(i2 + 1) % numPoints], factor = a2.x * b2.y - b2.x * a2.y;
          res.x += (a2.x + b2.x) * factor;
          res.y += (a2.y + b2.y) * factor;
        }
        return res.scale(1 / (this.getArea() * 6));
      },
      getCircumference: function() {
        var circ = 0;
        for (var i2 = 0, num = this.vertices.length; i2 < num; i2++) {
          circ += this.vertices[i2].distanceTo(this.vertices[(i2 + 1) % num]);
        }
        return circ;
      },
      getClosestPointTo: function(p) {
        var minD = Number.MAX_VALUE;
        var q2, c2, d;
        var edges = this.getEdges();
        for (var i2 = 0, len = edges.length; i2 < len; i2++) {
          c2 = edges[i2].closestPointTo(p);
          d = c2.distanceToSquared(p);
          if (d < minD) {
            q2 = c2;
            minD = d;
          }
        }
        return q2;
      },
      getClosestVertexTo: function(p) {
        var minD = Number.MAX_VALUE;
        var q2, d, i2 = 0, len = this.vertices.length;
        for (; i2 < len; i2++) {
          d = this.vertices[i2].distanceToSquared(p);
          if (d < minD) {
            q2 = this.vertices[i2];
            minD = d;
          }
        }
        return q2;
      },
      getEdges: function() {
        var num = this.vertices.length, edges = [];
        for (var i2 = 0; i2 < num; i2++) {
          edges[i2] = new Line2D(this.vertices[i2], this.vertices[(i2 + 1) % num]);
        }
        return edges;
      },
      //@deprecated
      getNumPoints: function() {
        return this.getNumVertices();
      },
      getNumVertices: function() {
        return this.vertices.length;
      },
      getRandomPoint: function() {
        var edges = this.getEdges();
        var numEdges = edges.length;
        var ea = edges[MathUtils.random(numEdges)], eb;
        while (eb === void 0 || eb.equals(ea)) {
          eb = edges[MathUtils.random(numEdges)];
        }
        var p = ea.a.interpolateTo(ea.b, Math.random());
        return p.interpolateToSelf(
          eb.a.interpolateTo(eb.b, Math.random()),
          Math.random()
        );
      },
      /**
      * Repeatedly inserts vertices as mid points of the longest edges until the
      * new vertex count is reached.
      * @param {Number} count new vertex count
      * @return itself
      */
      increaseVertexCount: function(count) {
        var num = this.vertices.length, longestID = 0, maxD = 0, i2 = 0, d, m;
        while (num < count) {
          longestID = 0;
          maxD = 0;
          for (i2 = 0; i2 < num; i2++) {
            d = this.vertices[i2].distanceToSquared(this.vertices[(i2 + 1) % num]);
            if (d > maxD) {
              longestID = i2;
              maxD = d;
            }
          }
          m = this.vertices[longestID].add(this.vertices[(longestID + 1) % num]).scaleSelf(0.5);
          this.vertices.splice(longestID + 1, 0, m);
          num++;
        }
        return this;
      },
      intersectsPolygon: function(poly) {
        if (!this.containsPolygon(poly)) {
          var edges = this.getEdges();
          var pedges = poly.getEdges();
          for (var i2 = 0, n = edges.length; i2 < n; i2++) {
            for (var j = 0, m = pedges.length, e = edges[i2]; j < m; j++) {
              if (e.intersectLine(pedges[j]).getType() == Line2D.LineIntersection.Type.INTERSECTING) {
                return true;
              }
            }
          }
          return false;
        } else {
          return true;
        }
      },
      isClockwise: function() {
        return this.getArea() > 0;
      },
      /**
      * Checks if the polygon is convex.
      * @return true, if convex.
      */
      isConvex: function() {
        var isPositive = false, num = this.vertices.length, prev, next, d0, d1, newIsP;
        for (var i2 = 0; i2 < num; i2++) {
          prev = i2 === 0 ? num - 1 : i2 - 1;
          next = i2 === num - 1 ? 0 : i2 + 1;
          d0 = this.vertices[i2].sub(this.vertices[prev]);
          d1 = this.vertices[next].sub(this.vertices[i2]);
          newIsP = d0.cross(d1) > 0;
          if (i2 === 0) {
            isPositive = true;
          } else if (isPositive != newIsP) {
            return false;
          }
        }
        return true;
      },
      /**
      * Given the sequentially connected points p1, p2, p3, this function returns
      * a bevel-offset replacement for point p2.
      *
      * Note: If vectors p1->p2 and p2->p3 are exactly 180 degrees opposed, or if
      * either segment is zero then no offset will be applied.
      *
      * @param x1
      * @param y1
      * @param x2
      * @param y2
      * @param x3
      * @param y3
      * @param distance
      * @param out
      *
      * @see http://alienryderflex.com/polygon_inset/
      */
      _offsetCorner: function(x1, y1, x2, y2, x3, y3, distance, out) {
        var c1 = x2, d1 = y2, c2 = x2, d2 = y2;
        var dx1, dy1, dist1, dx2, dy2, dist2, insetX, insetY;
        dx1 = x2 - x1;
        dy1 = y2 - y1;
        dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
        dx2 = x3 - x2;
        dy2 = y3 - y2;
        dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
        if (dist1 < MathUtils.EPS || dist2 < MathUtils.EPS) {
          return;
        }
        dist1 = distance / dist1;
        dist2 = distance / dist2;
        insetX = dy1 * dist1;
        insetY = -dx1 * dist1;
        x1 += insetX;
        c1 += insetX;
        y1 += insetY;
        d1 += insetY;
        insetX = dy2 * dist2;
        insetY = -dx2 * dist2;
        x3 += insetX;
        c2 += insetX;
        y3 += insetY;
        d2 += insetY;
        if (c1 === c2 && d1 === d2) {
          out.set(c1, d1);
          return;
        }
        var l1 = new Line2D(new Vec2D(x1, y1), new Vec2D(c1, d1)), l2 = new Line2D(new Vec2D(c2, d2), new Vec2D(x3, y3)), isec = l1.intersectLine(l2), ipos = isec.getPos();
        if (ipos !== null || ipos !== void 0) {
          out.set(ipos);
        }
      },
      /**
      * Moves each line segment of the polygon in/outward perpendicular by the
      * given distance. New line segments and polygon vertices are created by
      * computing the intersection points of the displaced segments. Choosing an
      * too large displacement amount will result in deformation/undefined
      * behavior with various self intersections. Should that happen, please try
      * to clean up the shape using the {@link #toOutline()} method.
      *
      * @param distance
      *            offset/inset distance (negative for inset)
      * @return itself
      */
      offsetShape: function(distance) {
        var v2 = this.vertices;
        var num = v2.length - 1;
        if (num > 1) {
          var startX = v2[0].x, startY = v2[0].y, c2 = v2[num].x, d = v2[num].y, e = startX, f2 = startY, a2, b2;
          for (var i2 = 0; i2 < num; i2++) {
            a2 = c2;
            b2 = d;
            c2 = e;
            d = f2;
            e = v2[i2 + 1].x;
            f2 = v2[i2 + 1].y;
            this._offsetCorner(a2, b2, c2, d, e, f2, distance, v2[i2]);
          }
          this._offsetCorner(c2, d, e, f2, startX, startY, distance, v2[num]);
        }
        return this;
      },
      /**
      * Reduces the number of vertices in the polygon based on the given minimum
      * edge length. Only vertices with at least this distance between them will
      * be kept.
      *
      * @param minEdgeLen
      * @return itself
      */
      reduceVertices: function(minEdgeLen) {
        minEdgeLen *= minEdgeLen;
        var vs = this.vertices, reduced = [], prev = vs[0], num = vs.length - 1, vec;
        reduced.push(prev);
        for (var i2 = 0; i2 < num; i2++) {
          vec = vs[i2];
          if (prev.distanceToSquared(vec) >= minEdgeLen) {
            reduced.push(vec);
            prev = vec;
          }
        }
        if (vs[0].distanceToSquared(vs[num]) >= minEdgeLen) {
          reduced.push(vs[num]);
        }
        this.vertices = reduced;
        return this;
      },
      /**
      * Removes duplicate vertices from the polygon. Only successive points are
      * recognized as duplicates.
      * @param {Number} tolerance snap distance for finding duplicates
      * @return itself
      */
      removeDuplicates: function(tolerance) {
        var equals = tolerance ? "equalsWithTolerance" : "equals";
        var p, prev, i2 = 0, num = this.vertices.length;
        var last;
        for (; i2 < num; i2++) {
          p = this.vertices[i2];
          if (p[equals](prev, tolerance)) {
            this.vertices.splice(i2, 1);
            i2--;
            num--;
          } else {
            prev = p;
          }
        }
        num = this.vertices.length;
        if (num > 0) {
          last = this.vertices[num - 1];
          if (last[equals](this.vertices[0], tolerance)) {
            this.vertices.splice(num - 1, 1);
          }
        }
        return this;
      },
      rotate: function(theta) {
        for (var i2 = 0, num = this.vertices.length; i2 < num; i2++) {
          this.vertices[i2].rotate(theta);
        }
        return this;
      },
      scale: function(x2, y2) {
        if (arguments.length == 1) {
          var arg = arguments[0];
          if (has.XY(arg)) {
            x2 = arg.x;
            y2 = arg.y;
          } else {
            x2 = arg;
            y2 = arg;
          }
        } else if (arguments.length == 2) {
          x2 = arguments[0];
          y2 = arguments[1];
        } else {
          throw "Invalid argument(s) passed.";
        }
        for (var i2 = 0, num = this.vertices.length; i2 < num; i2++) {
          this.vertices[i2].scaleSelf(x2, y2);
        }
        return this;
      },
      scaleSize: function(x2, y2) {
        var centroid;
        if (arguments.length === 1) {
          var arg = arguments[0];
          if (has.XY(arg)) {
            x2 = arg.x;
            y2 = arg.y;
          } else {
            x2 = arg;
            y2 = arg;
          }
        } else if (arguments.length === 2) {
          x2 = arguments[0];
          y2 = arguments[1];
        } else {
          throw new Error("Invalid argument(s) passed.");
        }
        centroid = this.getCentroid();
        for (var i2 = 0, l2 = this.vertices.length; i2 < l2; i2++) {
          var v2 = this.vertices[i2];
          v2.subSelf(centroid).scaleSelf(x2, y2).addSelf(centroid);
        }
        return this;
      },
      smooth: function(amount, baseWeight) {
        var centroid = this.getCentroid();
        var num = this.vertices.length;
        var filtered = [];
        for (var i2 = 0, j = num - 1, k2 = 1; i2 < num; i2++) {
          var a2 = this.vertices[i2];
          var dir = this.vertices[j].sub(a2).addSelf(this.vertices[k2].sub(a2)).addSelf(a2.sub(centroid).scaleSelf(baseWeight));
          filtered.push(a2.add(dir.scaleSelf(amount)));
          j++;
          if (j == num) {
            j = 0;
          }
          k2++;
          if (k2 == num) {
            k2 = 0;
          }
        }
        this.vertices = filtered;
        return this;
      },
      toMesh: function(mesh, centroid2D, extrude) {
        mesh = mesh || new TriangleMesh();
        var num = this.vertices.length;
        centroid2D = centroid2D || this.getCentroid();
        var centroid = centroid2D.to3DXY();
        centroid.z = extrude;
        var bounds = this.getBounds(), boundScale = new Vec2D(1 / bounds.width, 1 / bounds.height), uvC = centroid2D.sub(bounds.getTopLeft()).scaleSelf(boundScale), a2, b2, uvA, uvB;
        for (var i2 = 1; i2 <= num; i2++) {
          a2 = this.vertices[i2 % num];
          b2 = this.vertices[i2 - 1];
          uvA = a2.sub(bounds.getTopLeft()).scaleSelf(boundScale);
          uvB = b2.sub(bounds.getTopLeft()).scaleSelf(boundScale);
          mesh.addFace(centroid, a2.to3DXY(), b2.to3DXY(), uvC, uvA, uvB);
        }
        return mesh;
      },
      toPolygon2D: function() {
        return this;
      },
      toString: function() {
        var s = "";
        for (var i2 = 0; i2 < this.vertices.length; i2++) {
          s += this.vertices[i2];
          if (i2 < this.vertices.length - 1) {
            s += ", ";
          }
        }
        return s;
      },
      translate: function() {
        var x2, y2;
        if (arguments.length == 1 && has.XY(arguments[0])) {
          x2 = arguments[0].x;
          y2 = arguments[0].y;
        } else if (arguments.length == 2) {
          x2 = arguments[0];
          y2 = arguments[1];
        } else {
          throw "Invalid argument(s) passed.";
        }
        for (var i2 = 0, num = this.vertices.length; i2 < num; i2++) {
          this.vertices[i2].addSelf(x2, y2);
        }
        return this;
      }
    };
    Polygon2D.fromBaseEdge = function(baseA, baseB, res) {
      var theta = -(MathUtils.PI - MathUtils.PI * (res - 2) / res), dir = baseB.sub(baseA), prev = baseB, poly = new Polygon2D(baseA, baseB), p;
      for (var i2 = 0; i2 < res - 1; i2++) {
        p = prev.add(dir.getRotated(theta * i2));
        poly.add(p);
        prev = p;
      }
      return poly;
    };
    Polygon2D.fromEdgeLength = function(len, res) {
      var Circle2 = require_Circle();
      return new Circle2(Polygon2D.getRadiusForEdgeLength(len, res)).toPolygon2D(res);
    };
    Polygon2D.getRadiusForEdgeLength = function(len, res) {
      return len / (2 * MathUtils.sin(MathUtils.PI / res));
    };
    module.exports = Polygon2D;
  }
});

// node_modules/toxiclibsjs/geom/Rect.js
var require_Rect = __commonJS({
  "node_modules/toxiclibsjs/geom/Rect.js"(exports, module) {
    init_process();
    init_buffer();
    var internals = require_internals();
    var mathUtils = require_mathUtils();
    var Vec2D = require_Vec2D();
    var Line2D = require_Line2D();
    var Rect = function(a2, b2, width, height) {
      if (arguments.length === 2) {
        if (!internals.has.XY(a2)) {
          throw new Error("Rect received incorrect parameters");
        } else {
          this.x = a2.x;
          this.y = a2.y;
          this.width = b2.x - this.x;
          this.height = b2.y - this.y;
        }
      } else if (arguments.length == 4) {
        this.x = a2;
        this.y = b2;
        this.width = width;
        this.height = height;
      } else if (arguments.length === 1) {
        var o = arguments[0];
        if (internals.has.XYWidthHeight(o)) {
          this.x = o.x;
          this.y = o.y;
          this.width = o.width;
          this.height = o.height;
        }
      } else if (arguments.length > 0) {
        throw new Error("Rect received incorrect parameters");
      }
    };
    Rect.fromCenterExtent = function(center, extent) {
      return new Rect(center.sub(extent), center.add(extent));
    };
    Rect.getBoundingRect = function(points) {
      var first = points[0];
      var bounds = new Rect(first.x, first.y, 0, 0);
      for (var i2 = 1, num = points.length; i2 < num; i2++) {
        bounds.growToContainPoint(points[i2]);
      }
      return bounds;
    };
    Rect.prototype = {
      containsPoint: function(p) {
        var px = p.x;
        var py = p.y;
        if (px < this.x || px >= this.x + this.width) {
          return false;
        }
        if (py < this.y || py >= this.y + this.height) {
          return false;
        }
        return true;
      },
      copy: function() {
        return new Rect(this.x, this.y, this.width, this.height);
      },
      getArea: function() {
        return this.width * this.height;
      },
      getAspect: function() {
        return this.width / this.height;
      },
      getBottom: function() {
        return this.y + this.height;
      },
      getBottomRight: function() {
        return new Vec2D(this.x + this.width, this.y + this.height);
      },
      getCentroid: function() {
        return new Vec2D(this.x + this.width * 0.5, this.y + this.height * 0.5);
      },
      getDimensions: function() {
        return new Vec2D(this.width, this.height);
      },
      getEdge: function(id) {
        var edge;
        switch (id) {
          case 0:
            edge = new Line2D(
              new Vec2D(this.x, this.y),
              new Vec2D(this.x + this.width, this.y)
            );
            break;
          case 1:
            edge = new Line2D(
              new Vec2D(this.x + this.width, this.y),
              new Vec2D(this.x + this.width, this.y + this.height)
            );
            break;
          case 2:
            edge = new Line2D(
              new Vec2D(this.x, this.y + this.height),
              new Vec2D(this.x + this.width, this.y + this.height)
            );
            break;
          case 3:
            edge = new Line2D(
              new Vec2D(this.x, this.y),
              new Vec2D(this.x, this.y + this.height)
            );
            break;
          default:
            throw new Error("edge ID needs to be 0...3");
        }
        return edge;
      },
      getLeft: function() {
        return this.x;
      },
      getRight: function() {
        return this.x + this.width;
      },
      getTop: function() {
        return this.y;
      },
      getTopLeft: function() {
        return new Vec2D(this.x, this.y);
      },
      growToContainPoint: function(p) {
        if (!this.containsPoint(p)) {
          if (p.x < this.x) {
            this.width = this.getRight() - p.x;
            this.x = p.x;
          } else if (p.x > this.getRight()) {
            this.width = p.x - this.x;
          }
          if (p.y < this.y) {
            this.height = this.getBottom() - p.y;
            this.y = p.y;
          } else if (p.y > this.getBottom()) {
            this.height = p.y - this.y;
          }
        }
        return this;
      },
      intersectsRay: function(ray, minDist, maxDist) {
        var invDir = ray.getDirection().reciprocal();
        var signDirX = invDir.x < 0;
        var signDirY = invDir.y < 0;
        var min = this.getTopLeft();
        var max = this.getBottomRight();
        var bbox = signDirX ? max : min;
        var tmin = (bbox.x - ray.x) * invDir.x;
        bbox = signDirX ? min : max;
        var tmax = (bbox.x - ray.x) * invDir.x;
        bbox = signDirY ? max : min;
        var tymin = (bbox.y - ray.y) * invDir.y;
        bbox = signDirY ? min : max;
        var tymax = (bbox.y - ray.y) * invDir.y;
        if (tmin > tymax || tymin > tmax) {
          return void 0;
        }
        if (tymin > tmin) {
          tmin = tymin;
        }
        if (tymax < tmax) {
          tmax = tymax;
        }
        if (tmin < maxDist && tmax > minDist) {
          return ray.getPointAtDistance(tmin);
        }
        return void 0;
      },
      intersectsRect: function(r) {
        return !(this.x > r.x + r.width || this.x + this.width < r.x || this.y > r.y + r.height || this.y + this.height < r.y);
      },
      scale: function(s) {
        var c2 = this.getCentroid();
        this.width *= s;
        this.height *= s;
        this.x = c2.x - this.width * 0.5;
        this.y = c2.y - this.height * 0.5;
        return this;
      },
      set: function(x2, y2, width, height) {
        if (arguments.length === 1) {
          this.y = x2.y;
          this.width = x2.width;
          this.height = x2.height;
          this.x = x2.x;
        } else if (arguments.length === 4) {
          this.x = x2;
          this.y = y2;
          this.width = width;
          this.height = height;
        } else {
          throw new Error("Rect set() received wrong parameters");
        }
      },
      setDimensions: function(dim) {
        if (arguments.length == 2) {
          dim = { x: arguments[0], y: arguments[1] };
        }
        this.width = dim.x;
        this.height = dim.y;
        return this;
      },
      setPosition: function(pos) {
        this.x = pos.x;
        this.y = pos.y;
        return this;
      },
      toPolygon2D: function() {
        var Polygon2D = require_Polygon2D();
        var poly = new Polygon2D();
        poly.add(new Vec2D(this.x, this.y));
        poly.add(new Vec2D(this.x + this.width, this.y));
        poly.add(new Vec2D(this.x + this.width, this.y + this.height));
        poly.add(new Vec2D(this.x, this.y + this.height));
        return poly;
      },
      toString: function() {
        return "rect: {x: " + this.x + ", y: " + this.y + ", width: " + this.width + ", height: " + this.height + "}";
      },
      union: function(r) {
        var tmp = mathUtils.max(this.x + this.width, r.x + r.width);
        this.x = mathUtils.min(this.x, r.x);
        this.width = tmp - this.x;
        tmp = mathUtils.max(this.y + this.height, r.y + r.height);
        this.y = mathUtils.min(this.y, r.y);
        this.height = tmp - this.y;
        return this;
      }
    };
    module.exports = Rect;
  }
});

// node_modules/toxiclibsjs/geom/Spline2D.js
var require_Spline2D = __commonJS({
  "node_modules/toxiclibsjs/geom/Spline2D.js"(exports, module) {
    init_process();
    init_buffer();
    var Vec2D = require_Vec2D();
    var is = require_is();
    var BernsteinPolynomial = require_BernsteinPolynomial();
    var Spline2D = function(points, bernsteinPoly, tightness) {
      if (arguments.length === 1 && !is.Array(points) && is.Object(points)) {
        bernsteinPoly = bernsteinPoly || points.bernsteinPoly;
        tightness = tightness || points.tightness;
        points = points.points;
      }
      var i2 = 0, l2;
      this.pointList = [];
      if (typeof tightness !== "number") {
        tightness = Spline2D.DEFAULT_TIGHTNESS;
      }
      this.setTightness(tightness);
      this.bernstein = bernsteinPoly;
      if (points !== void 0) {
        for (i2 = 0, l2 = points.length; i2 < l2; i2++) {
          this.add(points[i2].copy());
        }
      }
      this.coeffA = [];
      this.delta = [];
      this.bi = [];
      for (i2 = 0; i2 < this.numP; i2++) {
        this.coeffA[i2] = new Vec2D();
        this.delta[i2] = new Vec2D();
        this.bi[i2] = 0;
      }
      this.bi = [];
    };
    Spline2D.prototype = {
      add: function(p) {
        this.pointList.push(p.copy());
        this.numP = this.pointList.length;
        return this;
      },
      computeVertices: function(res) {
        this.updateCoefficients();
        if (res < 1) {
          res = 1;
        }
        res++;
        if (this.bernstein === void 0 || this.bernstein.resolution != res) {
          this.bernstein = new BernsteinPolynomial(res);
        }
        var bst = this.bernstein;
        this.findCPoints();
        var deltaP = new Vec2D();
        var deltaQ = new Vec2D();
        res--;
        var verticeCount = (this.numP - 1) * res + 1;
        if (typeof this.vertices == "undefined" || this.vertices.length != verticeCount) {
          this.vertices = Array.apply(null, Array(verticeCount)).map(function() {
            return new Vec2D();
          });
        }
        var vertexIdx = 0;
        for (var i2 = 0; i2 < this.numP - 1; i2++) {
          var p = this.points[i2];
          var q2 = this.points[i2 + 1];
          deltaP.x = this.delta[i2].x + p.x;
          deltaP.y = this.delta[i2].y + p.y;
          deltaQ.x = q2.x - this.delta[i2 + 1].x;
          deltaQ.y = q2.y - this.delta[i2 + 1].y;
          for (var k2 = 0; k2 < res; k2++) {
            var x2 = p.x * bst.b0[k2] + deltaP.x * bst.b1[k2] + deltaQ.x * bst.b2[k2] + q2.x * bst.b3[k2];
            var y2 = p.y * bst.b0[k2] + deltaP.y * bst.b1[k2] + deltaQ.y * bst.b2[k2] + q2.y * bst.b3[k2];
            this.vertices[vertexIdx].x = x2;
            this.vertices[vertexIdx].y = y2;
            vertexIdx++;
          }
        }
        this.vertices[vertexIdx].x = this.vertices[vertexIdx - 1].x;
        this.vertices[vertexIdx].y = this.vertices[vertexIdx - 1].y;
        return this.vertices;
      },
      findCPoints: function() {
        this.bi[1] = -0.25;
        var i2, p0, p2, d0;
        p0 = this.pointList[0];
        p2 = this.pointList[2];
        d0 = this.delta[0];
        this.coeffA[1].x = (p2.x - p0.x - d0.x) * this.tightness;
        this.coeffA[1].y = (p2.y - p0.y - d0.y) * this.tightness;
        for (i2 = 2; i2 < this.numP - 1; i2++) {
          this.bi[i2] = -1 / (this.invTightness + this.bi[i2 - 1]);
          this.coeffA[i2].x = -(this.points[i2 + 1].x - this.points[i2 - 1].x - this.coeffA[i2 - 1].x) * this.bi[i2];
          this.coeffA[i2].y = -(this.points[i2 + 1].y - this.points[i2 - 1].y - this.coeffA[i2 - 1].y) * this.bi[i2];
        }
        for (i2 = this.numP - 2; i2 > 0; i2--) {
          this.delta[i2].x = this.coeffA[i2].x + this.delta[i2 + 1].x * this.bi[i2];
          this.delta[i2].y = this.coeffA[i2].y + this.delta[i2 + 1].y * this.bi[i2];
        }
      },
      getDecimatedVertices: function(step, doAddFinalVertex) {
        if (doAddFinalVertex === void 0) doAddFinalVertex = true;
        if (this.vertices === void 0 || this.vertices.length < 2) {
          this.computeVertices(Spline2D.DEFAULT_RES);
        }
        var arcLen = this.getEstimatedArcLength();
        var uniform = [];
        var delta = step / arcLen;
        var currIdx = 0;
        for (var t = 0; t < 1; t += delta) {
          var currT = t * arcLen;
          while (currT >= this.arcLenIndex[currIdx]) {
            currIdx++;
          }
          var p = this.vertices[currIdx - 1];
          var q2 = this.vertices[currIdx];
          var frac = (currT - this.arcLenIndex[currIdx - 1]) / (this.arcLenIndex[currIdx] - this.arcLenIndex[currIdx - 1]);
          var i2 = p.interpolateTo(q2, frac);
          uniform.push(i2);
        }
        if (doAddFinalVertex) {
          uniform.push(this.vertices[this.vertices.length - 1]);
        }
        return uniform;
      },
      getEstimatedArcLength: function() {
        var len;
        var arcLen = 0;
        if (this.arcLenIndex === void 0 || this.arcLenIndex !== void 0 && this.arcLenIndex.length != this.vertices.length) {
          this.arcLenIndex = [0];
          len = this.vertices.length;
        } else {
          len = this.arcLenIndex.length;
        }
        for (var i2 = 1; i2 < len; i2++) {
          var p = this.vertices[i2 - 1];
          var q2 = this.vertices[i2];
          arcLen += p.distanceTo(q2);
          this.arcLenIndex[i2] = arcLen;
        }
        return arcLen;
      },
      getNumPoints: function() {
        return this.numP;
      },
      getPointList: function() {
        return this.pointList;
      },
      getTightness: function() {
        return this.tightness;
      },
      setPointList: function(plist) {
        this.pointList = plist.slice(0);
        return this;
      },
      setTightness: function(tight) {
        this.tightness = tight;
        this.invTightness = 1 / this.tightness;
        return this;
      },
      updateCoefficients: function() {
        this.numP = this.pointList.length;
        if (this.points === void 0 || this.points !== void 0 && this.points.length != this.numP) {
          this.coeffA = [];
          this.delta = [];
          this.bi = [];
          for (var i2 = 0; i2 < this.numP; i2++) {
            this.coeffA[i2] = new Vec2D();
            this.delta[i2] = new Vec2D();
          }
          this.setTightness(this.tightness);
        }
        this.points = this.pointList.slice(0);
      }
    };
    Spline2D.DEFAULT_TIGHTNESS = 0.25;
    Spline2D.DEFAULT_RES = 16;
    module.exports = Spline2D;
  }
});

export {
  require_Vec3D,
  require_Matrix4x4,
  require_Ray3D,
  require_Line3D,
  require_Triangle3D,
  require_Face,
  require_IsectData3D,
  require_Quaternion,
  require_Vertex,
  require_Sphere,
  require_meshCommon,
  require_AABB,
  require_TriangleMesh,
  require_BernsteinPolynomial,
  require_Ray2D,
  require_Line2D,
  require_Rect,
  require_Polygon2D,
  require_Ellipse,
  require_Circle,
  require_Spline2D
};
//# sourceMappingURL=chunk-EOWBUYU7.js.map
